var D = Object.defineProperty;
var A = (r, e, t) => e in r ? D(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var c = (r, e, t) => (A(r, typeof e != "symbol" ? e + "" : e, t), t);
const B = (r) => {
  const e = new I(r);
  return new Proxy(r, {
    get(t, s, n) {
      return s in e ? e[s] : Reflect.get(t, s, n);
    }
  });
};
class I {
  constructor(e) {
    c(this, "context");
    c(this, "fn");
    c(this, "fnGenerator");
    c(this, "fnCounter", Number.MIN_SAFE_INTEGER);
    c(this, "fnMap", /* @__PURE__ */ new Map());
    /** Similar to the original newFunction, but no matter how many new functions are generated, newFunction is called only once. */
    c(this, "newFunction", (e, t) => {
      this.fnCounter++;
      const s = this.fnCounter;
      return this.fnMap.set(s, t), this.context.unwrapResult(
        this.context.callFunction(
          this.fnGenerator,
          this.context.undefined,
          this.context.newString(e),
          this.context.newNumber(t.length),
          this.context.newNumber(s),
          this.fn
        )
      );
    });
    this.context = e;
    const t = this.fnMap;
    this.fn = this.context.newFunction("", function(s, ...n) {
      const o = e.getNumber(s), i = t.get(o);
      if (!i)
        throw new Error("function is not registered");
      return i.call(this, ...n);
    }), this.fnGenerator = e.unwrapResult(
      e.evalCode(`((name, length, id, f) => {
        const fn = function(...args) {
          return f.call(this, id, ...args);
        };
        fn.name = name;
        fn.length = length;
        return fn;
      })`)
    );
  }
  disposeEx() {
    this.fnGenerator.dispose(), this.fn.dispose();
  }
}
const T = [
  // basic objects
  [Symbol, "Symbol"],
  [Symbol.prototype, "Symbol.prototype"],
  [Object, "Object"],
  [Object.prototype, "Object.prototype"],
  [Function, "Function"],
  [Function.prototype, "Function.prototype"],
  [Boolean, "Boolean"],
  [Boolean.prototype, "Boolean.prototype"],
  [Array, "Array"],
  [Array.prototype, "Array.prototype"],
  // [BigInt, "BigInt"],
  // [BigInt.prototype, "BigInt.prototype"],
  // errors
  [Error, "Error"],
  [Error.prototype, "Error.prototype"],
  [EvalError, "EvalError"],
  [EvalError.prototype, "EvalError.prototype"],
  [RangeError, "RangeError"],
  [RangeError.prototype, "RangeError.prototype"],
  [ReferenceError, "ReferenceError"],
  [ReferenceError.prototype, "ReferenceError.prototype"],
  [SyntaxError, "SyntaxError"],
  [SyntaxError.prototype, "SyntaxError.prototype"],
  [TypeError, "TypeError"],
  [TypeError.prototype, "TypeError.prototype"],
  [URIError, "URIError"],
  [URIError.prototype, "URIError.prototype"],
  // built-in symbols
  ...Object.getOwnPropertyNames(Symbol).filter((r) => typeof Symbol[r] == "symbol").map((r) => [Symbol[r], `Symbol.${r}`])
];
function G(r, e) {
  const t = r.unwrapResult(r.evalCode(e)), s = (n, ...o) => r.unwrapResult(r.callFunction(t, n != null ? n : r.undefined, ...o));
  return s.dispose = () => t.dispose(), s.alive = !0, Object.defineProperty(s, "alive", {
    get: () => t.alive
  }), s;
}
function y(r, e, t, ...s) {
  const n = G(r, e);
  try {
    return n(t, ...s);
  } finally {
    n.dispose();
  }
}
function J(r, e, t) {
  return r.dump(y(r, "Object.is", void 0, e, t));
}
function U(r, e, t) {
  return r.dump(y(r, "(a, b) => a instanceof b", void 0, e, t));
}
function W(r, e) {
  return r.dump(
    y(r, 'a => typeof a === "object" && a !== null || typeof a === "function"', void 0, e)
  );
}
function z(r, e) {
  const t = JSON.stringify(e);
  return t ? y(r, "JSON.parse", void 0, r.newString(t)) : r.undefined;
}
function be(r, e) {
  try {
    return e(r);
  } finally {
    for (const t of r)
      t.alive && t.dispose();
  }
}
function $([r, e], t) {
  try {
    return t(r);
  } finally {
    e && r.dispose();
  }
}
function g(r, e) {
  try {
    return e(...r.map((t) => t[0]));
  } finally {
    for (const [t, s] of r)
      s && t.dispose();
  }
}
function q(r) {
  return "handle" in r;
}
function Q(r) {
  return q(r) ? r.handle : r;
}
function V(r, e, t, s) {
  var o;
  let n;
  for (const i of s)
    if (n = i(e, r), n)
      break;
  return n ? (o = t(e, n)) != null ? o : n : void 0;
}
function L(r, e) {
  return typeof r != "symbol" ? void 0 : y(
    e,
    "d => Symbol(d)",
    void 0,
    r.description ? e.newString(r.description) : e.undefined
  );
}
function X(r, e) {
  return r instanceof Date ? y(e, "d => new Date(d)", void 0, e.newNumber(r.getTime())) : void 0;
}
const Y = [L, X];
function Z(r) {
  return typeof r == "function" && /^class\s/.test(Function.prototype.toString.call(r));
}
function v(r) {
  return typeof r == "function" || typeof r == "object" && r !== null;
}
function E(r, e) {
  const t = /* @__PURE__ */ new Set(), s = (n) => {
    if (!(!v(n) || t.has(n) || (e == null ? void 0 : e(n, t)) === !1)) {
      if (t.add(n), Array.isArray(n)) {
        for (const o of n)
          s(o);
        return;
      }
      if (typeof n == "object") {
        const o = Object.getPrototypeOf(n);
        o && o !== Object.prototype && s(o);
      }
      for (const o of Object.values(Object.getOwnPropertyDescriptors(n)))
        "value" in o && s(o.value), "get" in o && s(o.get), "set" in o && s(o.set);
    }
  };
  return s(r), t;
}
function ve(r, e) {
  return E(r, e ? (t, s) => s.size < e : void 0).size;
}
function K() {
  let r = () => {
  }, e = () => {
  };
  return {
    promise: new Promise((s, n) => {
      r = s, e = n;
    }),
    resolve: r,
    reject: e
  };
}
function R(r, e, t, s) {
  const n = r.newObject(), o = (a, u) => {
    const p = s(a), l = typeof u.value == "undefined" ? void 0 : s(u.value), f = typeof u.get == "undefined" ? void 0 : s(u.get), d = typeof u.set == "undefined" ? void 0 : s(u.set);
    r.newObject().consume((m) => {
      Object.entries(u).forEach(([h, _]) => {
        const b = h === "value" ? l : h === "get" ? f : h === "set" ? d : _ ? r.true : r.false;
        b && r.setProp(m, h, b);
      }), r.setProp(n, p, m);
    });
  }, i = Object.getOwnPropertyDescriptors(e);
  Object.entries(i).forEach(([a, u]) => o(a, u)), Object.getOwnPropertySymbols(i).forEach((a) => o(a, i[a])), y(r, "Object.defineProperties", void 0, t, n).dispose(), n.dispose();
}
function x(r, e, t, s, n, o) {
  var u;
  if (typeof e != "function")
    return;
  const i = r.newFunction(e.name, function(...p) {
    const l = s(this), f = p.map((d) => s(d));
    if (Z(e) && v(l)) {
      const d = new e(...f);
      return Object.entries(d).forEach(([m, h]) => {
        r.setProp(this, m, t(h));
      }), this;
    }
    return t(o ? o(e, l, f) : e.apply(l, f));
  }).consume(
    (p) => (
      // fucntions created by vm.newFunction are not callable as a class constrcutor
      y(
        r,
        `Cls => {
          const fn = function(...args) { return Cls.apply(this, args); };
          fn.name = Cls.name;
          fn.length = Cls.length;
          return fn;
        }`,
        void 0,
        p
      )
    )
  ), a = (u = n(e, i)) != null ? u : i;
  return R(r, e, i, t), a;
}
function ee(r, e, t) {
  var o;
  const s = z(r, e);
  return (o = t(e, s)) != null ? o : s;
}
function te(r, e, t, s) {
  var u;
  if (typeof e != "object" || e === null)
    return;
  const n = Array.isArray(e) ? r.newArray() : r.newObject(), o = (u = s(e, n)) != null ? u : n, i = Object.getPrototypeOf(e), a = i && i !== Object.prototype && i !== Array.prototype ? t(i) : void 0;
  return a && y(r, "Object.setPrototypeOf", void 0, o, a).dispose(), R(r, e, n, t), o;
}
function re(r, e) {
  switch (typeof e) {
    case "undefined":
      return r.undefined;
    case "number":
      return r.newNumber(e);
    case "string":
      return r.newString(e);
    case "boolean":
      return e ? r.true : r.false;
    case "object":
      return e === null ? r.null : void 0;
  }
}
function ne(r, e, t, s) {
  var o;
  if (!(e instanceof Promise))
    return;
  const n = r.newPromise();
  return e.then(
    (i) => n.resolve(t(i)),
    (i) => n.reject(t(i))
  ), (o = s(e, n)) != null ? o : n.handle;
}
function M(r, e) {
  var l, f, d, m, h;
  const { ctx: t, unmarshal: s, isMarshalable: n, find: o, pre: i } = e;
  {
    const _ = re(t, r);
    if (_)
      return _;
  }
  {
    const _ = o(r);
    if (_)
      return _;
  }
  const a = n == null ? void 0 : n(r);
  if (a === !1)
    return t.undefined;
  const u = (_, b) => i(_, b, a);
  if (a === "json")
    return ee(t, r, u);
  const p = (_) => M(_, e);
  return (h = (m = (d = (f = V(t, r, u, [...Y, ...(l = e.custom) != null ? l : []])) != null ? f : ne(t, r, p, u)) != null ? d : x(t, r, p, s, u, e.preApply)) != null ? m : te(t, r, p, u)) != null ? h : t.undefined;
}
function se(r, e, t, s) {
  var o;
  let n;
  for (const i of s)
    if (n = i(e, r), n)
      break;
  return n ? (o = t(n, e)) != null ? o : n : void 0;
}
function oe(r, e) {
  if (e.typeof(r) !== "symbol")
    return;
  const t = e.getString(e.getProp(r, "description"));
  return Symbol(t);
}
function ie(r, e) {
  if (!e.dump(y(e, "a => a instanceof Date", void 0, r)))
    return;
  const t = e.getNumber(y(e, "a => a.getTime()", void 0, r));
  return new Date(t);
}
const ue = [oe, ie];
function k(r, e, t, s) {
  r.newFunction("", (n, o) => {
    const [i] = s(n);
    if (typeof i != "string" && typeof i != "number" && typeof i != "symbol")
      return;
    const a = [
      ["value", !0],
      ["get", !0],
      ["set", !0],
      ["configurable", !1],
      ["enumerable", !1],
      ["writable", !1]
    ].reduce((u, [p, l]) => {
      const f = r.getProp(o, p), d = r.typeof(f);
      if (d === "undefined")
        return u;
      if (!l && d === "boolean")
        return u[p] = r.dump(r.getProp(o, p)), u;
      const [m, h] = s(f);
      return h && f.dispose(), u[p] = m, u;
    }, {});
    Object.defineProperty(t, i, a);
  }).consume((n) => {
    y(
      r,
      `(o, fn) => {
        const descs = Object.getOwnPropertyDescriptors(o);
        Object.entries(descs).forEach(([k, v]) => fn(k, v));
        Object.getOwnPropertySymbols(descs).forEach(k => fn(k, descs[k]));
      }`,
      void 0,
      e,
      n
    ).dispose();
  });
}
function ae(r, e, t, s, n) {
  var a;
  if (r.typeof(e) !== "function")
    return;
  const o = function(...u) {
    return g(
      [t(this), ...u.map((p) => t(p))],
      (p, ...l) => {
        if (new.target) {
          const [h] = s(
            y(r, "(Cls, ...args) => new Cls(...args)", p, e, ...l)
          );
          return Object.defineProperties(this, Object.getOwnPropertyDescriptors(h)), this;
        }
        const f = r.unwrapResult(r.callFunction(e, p, ...l)), [d, m] = s(f);
        return m && f.dispose(), d;
      }
    );
  }, i = (a = n(o, e)) != null ? a : o;
  return k(r, e, o, s), i;
}
function pe(r, e, t, s) {
  var a;
  if (r.typeof(e) !== "object" || // null check
  r.unwrapResult(r.evalCode("o => o === null")).consume((u) => r.dump(r.unwrapResult(r.callFunction(u, r.undefined, e)))))
    return;
  const n = y(r, "Array.isArray", void 0, e).consume((u) => r.dump(u)) ? [] : {}, o = (a = s(n, e)) != null ? a : n, i = y(
    r,
    `o => {
      const p = Object.getPrototypeOf(o);
      return !p || p === Object.prototype || p === Array.prototype ? undefined : p;
    }`,
    void 0,
    e
  ).consume((u) => {
    if (r.typeof(u) === "undefined")
      return;
    const [p] = t(u);
    return p;
  });
  return typeof i == "object" && Object.setPrototypeOf(o, i), k(r, e, n, t), o;
}
function fe(r, e) {
  const t = r.typeof(e);
  return t === "undefined" || t === "number" || t === "string" || t === "boolean" ? [r.dump(e), !0] : t === "object" && r.unwrapResult(r.evalCode("a => a === null")).consume((n) => r.dump(r.unwrapResult(r.callFunction(n, r.undefined, e)))) ? [null, !0] : [void 0, !1];
}
function ce(r, e, t, s) {
  var p;
  if (!le(r, e))
    return;
  const n = K(), [o, i] = t(n.resolve), [a, u] = t(n.reject);
  return y(r, "(p, res, rej) => { p.then(res, rej); }", void 0, e, o, a), i && o.dispose(), u && a.dispose(), (p = s(n.promise, e)) != null ? p : n.promise;
}
function le(r, e) {
  return e.owner ? r.unwrapResult(r.evalCode("Promise")).consume((t) => e.owner ? U(r, e, t) : !1) : !1;
}
function de(r, e) {
  const [t] = C(r, e);
  return t;
}
function C(r, e) {
  var u, p, l, f;
  const { ctx: t, marshal: s, find: n, pre: o } = e;
  {
    const [d, m] = fe(t, r);
    if (m)
      return [d, !1];
  }
  {
    const d = n(r);
    if (d)
      return [d, !0];
  }
  const i = (d) => C(d, e);
  return [(f = (l = (p = se(t, r, o, [...ue, ...(u = e.custom) != null ? u : []])) != null ? p : ce(t, r, s, o)) != null ? l : ae(t, r, s, i, o)) != null ? f : pe(t, r, i, o), !1];
}
class S {
  constructor(e) {
    c(this, "ctx");
    c(this, "_map1", /* @__PURE__ */ new Map());
    c(this, "_map2", /* @__PURE__ */ new Map());
    c(this, "_map3", /* @__PURE__ */ new Map());
    c(this, "_map4", /* @__PURE__ */ new Map());
    c(this, "_counterMap", /* @__PURE__ */ new Map());
    c(this, "_disposables", /* @__PURE__ */ new Set());
    c(this, "_mapGet");
    c(this, "_mapSet");
    c(this, "_mapDelete");
    c(this, "_mapClear");
    c(this, "_counter", Number.MIN_SAFE_INTEGER);
    this.ctx = e;
    const t = e.unwrapResult(
      e.evalCode(`() => {
        const mapSym = new Map();
        let map = new WeakMap();
        let map2 = new WeakMap();
        const isObj = o => typeof o === "object" && o !== null || typeof o === "function";
        return {
          get: key => mapSym.get(key) ?? map.get(key) ?? map2.get(key) ?? -1,
          set: (key, value, key2) => {
            if (typeof key === "symbol") mapSym.set(key, value);
            if (isObj(key)) map.set(key, value);
            if (isObj(key2)) map2.set(key2, value);
          },
          delete: (key, key2) => {
            mapSym.delete(key);
            map.delete(key);
            map2.delete(key2);
          },
          clear: () => {
            mapSym.clear();
            map = new WeakMap();
            map2 = new WeakMap();
          }
        };
      }`)
    ).consume((s) => this._call(s, void 0));
    this._mapGet = e.getProp(t, "get"), this._mapSet = e.getProp(t, "set"), this._mapDelete = e.getProp(t, "delete"), this._mapClear = e.getProp(t, "clear"), t.dispose(), this._disposables.add(this._mapGet), this._disposables.add(this._mapSet), this._disposables.add(this._mapDelete), this._disposables.add(this._mapClear);
  }
  set(e, t, s, n) {
    var a;
    if (!t.alive || n && !n.alive)
      return !1;
    const o = (a = this.get(e)) != null ? a : this.get(s);
    if (o)
      return o === t || o === n;
    const i = this._counter++;
    return this._map1.set(e, i), this._map3.set(i, t), this._counterMap.set(i, e), s && (this._map2.set(s, i), n && this._map4.set(i, n)), this.ctx.newNumber(i).consume((u) => {
      this._call(this._mapSet, void 0, t, u, n != null ? n : this.ctx.undefined);
    }), !0;
  }
  merge(e) {
    if (e)
      for (const t of e)
        t && t[1] && this.set(t[0], t[1], t[2], t[3]);
  }
  get(e) {
    var n;
    const t = (n = this._map1.get(e)) != null ? n : this._map2.get(e), s = typeof t == "number" ? this._map3.get(t) : void 0;
    if (s) {
      if (!s.alive) {
        this.delete(e);
        return;
      }
      return s;
    }
  }
  getByHandle(e) {
    if (e.alive)
      return this._counterMap.get(this.ctx.getNumber(this._call(this._mapGet, void 0, e)));
  }
  has(e) {
    return !!this.get(e);
  }
  hasHandle(e) {
    return typeof this.getByHandle(e) != "undefined";
  }
  keys() {
    return this._map1.keys();
  }
  delete(e, t) {
    var i;
    const s = (i = this._map1.get(e)) != null ? i : this._map2.get(e);
    if (typeof s == "undefined")
      return;
    const n = this._map3.get(s), o = this._map4.get(s);
    this._call(
      this._mapDelete,
      void 0,
      ...[n, o].filter((a) => !!(a != null && a.alive))
    ), this._map1.delete(e), this._map2.delete(e), this._map3.delete(s), this._map4.delete(s);
    for (const [a, u] of this._map1)
      if (u === s) {
        this._map1.delete(a);
        break;
      }
    for (const [a, u] of this._map2)
      if (u === s) {
        this._map2.delete(a);
        break;
      }
    for (const [a, u] of this._counterMap)
      if (u === e) {
        this._counterMap.delete(a);
        break;
      }
    t && (n != null && n.alive && n.dispose(), o != null && o.alive && o.dispose());
  }
  deleteByHandle(e, t) {
    const s = this.getByHandle(e);
    typeof s != "undefined" && this.delete(s, t);
  }
  clear() {
    this._counter = 0, this._map1.clear(), this._map2.clear(), this._map3.clear(), this._map4.clear(), this._counterMap.clear(), this._mapClear.alive && this._call(this._mapClear, void 0);
  }
  dispose() {
    for (const e of this._disposables.values())
      e.alive && e.dispose();
    for (const e of this._map3.values())
      e.alive && e.dispose();
    for (const e of this._map4.values())
      e.alive && e.dispose();
    this._disposables.clear(), this.clear();
  }
  get size() {
    return this._map1.size;
  }
  [Symbol.iterator]() {
    const e = this._map1.keys();
    return {
      next: () => {
        for (; ; ) {
          const t = e.next();
          if (t.done)
            return { value: void 0, done: !0 };
          const s = this._map1.get(t.value);
          if (typeof s == "undefined")
            continue;
          const n = this._map3.get(s), o = this._map4.get(s);
          if (!n)
            continue;
          const i = this._get2(s);
          return { value: [t.value, n, i, o], done: !1 };
        }
      }
    };
  }
  _get2(e) {
    for (const [t, s] of this._map2)
      if (s === e)
        return t;
  }
  _call(e, t, ...s) {
    return this.ctx.unwrapResult(
      this.ctx.callFunction(
        e,
        typeof t == "undefined" ? this.ctx.undefined : t,
        ...s
      )
    );
  }
}
function me(r, e, t, s, n, o, i) {
  if (!v(e) || e instanceof Promise || e instanceof Date || i && !i(e))
    return;
  if (ye(e, t))
    return e;
  const a = new Proxy(e, {
    get(u, p) {
      return p === t ? u : Reflect.get(u, p);
    },
    set(u, p, l, f) {
      var h;
      const d = w(l, t), m = (h = o == null ? void 0 : o(f)) != null ? h : "host";
      return m !== "vm" && !Reflect.set(u, p, d, f) || m === "host" || !r.alive || g(
        [n(f), n(p), n(d)],
        (_, b, P) => {
          const [O, H] = j(r, _, s);
          H ? O.consume((N) => r.setProp(N, b, P)) : r.setProp(O, b, P);
        }
      ), !0;
    },
    deleteProperty(u, p) {
      var f;
      const l = (f = o == null ? void 0 : o(a)) != null ? f : "host";
      return g([n(a), n(p)], (d, m) => {
        const [h, _] = j(r, d, s);
        if (l === "vm" || Reflect.deleteProperty(u, p)) {
          if (l === "host" || !r.alive)
            return !0;
          _ ? h.consume((b) => y(r, "(a, b) => delete a[b]", void 0, b, m)) : y(r, "(a, b) => delete a[b]", void 0, h, m);
        }
        return !0;
      });
    }
  });
  return a;
}
function he(r, e, t, s, n, o, i) {
  if (!W(r, e) || i && !i(e, r))
    return [void 0, !1];
  if (F(r, e, s))
    return [e, !1];
  const a = (l) => {
    const f = o == null ? void 0 : o(n(l));
    return typeof f == "string" ? r.newString(f) : r.undefined;
  }, u = (l, f, d) => {
    const m = n(l);
    if (!m)
      return;
    const h = n(f);
    if (h === "__proto__")
      return;
    const _ = n(d);
    w(m, t)[h] = _;
  }, p = (l, f) => {
    const d = n(l);
    if (!d)
      return;
    const m = n(f);
    delete w(d, t)[m];
  };
  return r.newFunction("proxyFuncs", (l, ...f) => {
    switch (r.getNumber(l)) {
      case 1:
        return a(f[0]);
      case 2:
        return u(f[0], f[1], f[2]);
      case 3:
        return p(f[0], f[1]);
    }
    return r.undefined;
  }).consume((l) => [
    y(
      r,
      `(target, sym, proxyFuncs) => {
          const rec =  new Proxy(target, {
            get(obj, key, receiver) {
              return key === sym ? obj : Reflect.get(obj, key, receiver)
            },
            set(obj, key, value, receiver) {
              const v = typeof value === "object" && value !== null || typeof value === "function"
                ? value[sym] ?? value
                : value;
              const sync = proxyFuncs(1, receiver) ?? "vm";
              if (sync === "host" || Reflect.set(obj, key, v, receiver)) {
                if (sync !== "vm") {
                  proxyFuncs(2, receiver, key, v);
                }
              }
              return true;
            },
            deleteProperty(obj, key) {
              const sync = proxyFuncs(1, rec) ?? "vm";
              if (sync === "host" || Reflect.deleteProperty(obj, key)) {
                if (sync !== "vm") {
                  proxyFuncs(3, rec, key);
                }
              }
              return true;
            },
          });
          return rec;
        }`,
      void 0,
      e,
      s,
      l
    ),
    !0
  ]);
}
function w(r, e) {
  var t;
  return v(r) && (t = r[e]) != null ? t : r;
}
function j(r, e, t) {
  return F(r, e, t) ? [r.getProp(e, t), !0] : [e, !1];
}
function ye(r, e) {
  return v(r) && !!r[e];
}
function F(r, e, t) {
  return !!r.dump(
    y(
      r,
      // promise and date cannot be wrapped
      '(a, s) => (a instanceof Promise) || (a instanceof Date) || (typeof a === "object" && a !== null || typeof a === "function") && !!a[s]',
      void 0,
      e,
      t
    )
  );
}
class we {
  /** Constructs a new Arena instance. It requires a quickjs-emscripten context initialized with `quickjs.newContext()`. */
  constructor(e, t) {
    c(this, "context");
    c(this, "_map");
    c(this, "_registeredMap");
    c(this, "_registeredMapDispose", /* @__PURE__ */ new Set());
    c(this, "_sync", /* @__PURE__ */ new Set());
    c(this, "_temporalSync", /* @__PURE__ */ new Set());
    c(this, "_symbol", Symbol());
    c(this, "_symbolHandle");
    c(this, "_options");
    c(this, "_isMarshalable", (e) => {
      var s, n;
      const t = (s = this._options) == null ? void 0 : s.isMarshalable;
      return (n = typeof t == "function" ? t(this._unwrap(e)) : t) != null ? n : "json";
    });
    c(this, "_marshalFind", (e) => {
      var n, o, i;
      const t = this._unwrap(e);
      return (i = (o = (n = this._registeredMap.get(e)) != null ? n : t !== e ? this._registeredMap.get(t) : void 0) != null ? o : this._map.get(e)) != null ? i : t !== e ? this._map.get(t) : void 0;
    });
    c(this, "_marshalPre", (e, t, s) => {
      var n;
      if (s !== "json")
        return (n = this._register(e, Q(t), this._map)) == null ? void 0 : n[1];
    });
    c(this, "_marshalPreApply", (e, t, s) => {
      const n = v(t) ? this._unwrap(t) : void 0;
      n && this._temporalSync.add(n);
      try {
        return e.apply(t, s);
      } finally {
        n && this._temporalSync.delete(n);
      }
    });
    c(this, "_marshal", (e) => {
      var n, o;
      const t = this._registeredMap.get(e);
      if (t)
        return [t, !1];
      const s = M((n = this._wrap(e)) != null ? n : e, {
        ctx: this.context,
        unmarshal: this._unmarshal,
        isMarshalable: this._isMarshalable,
        find: this._marshalFind,
        pre: this._marshalPre,
        preApply: this._marshalPreApply,
        custom: (o = this._options) == null ? void 0 : o.customMarshaller
      });
      return [s, !this._map.hasHandle(s)];
    });
    c(this, "_preUnmarshal", (e, t) => {
      var s;
      return (s = this._register(e, t, void 0, !0)) == null ? void 0 : s[0];
    });
    c(this, "_unmarshalFind", (e) => {
      var t;
      return (t = this._registeredMap.getByHandle(e)) != null ? t : this._map.getByHandle(e);
    });
    c(this, "_unmarshal", (e) => {
      var n;
      const t = this._registeredMap.getByHandle(e);
      if (typeof t != "undefined")
        return t;
      const [s] = this._wrapHandle(e);
      return de(s != null ? s : e, {
        ctx: this.context,
        marshal: this._marshal,
        find: this._unmarshalFind,
        pre: this._preUnmarshal,
        custom: (n = this._options) == null ? void 0 : n.customUnmarshaller
      });
    });
    c(this, "_syncMode", (e) => {
      const t = this._unwrap(e);
      return this._sync.has(t) || this._temporalSync.has(t) ? "both" : void 0;
    });
    c(this, "_unwrapIfNotSynced", (e) => {
      const t = this._unwrap(e);
      return t instanceof Promise || !this._sync.has(t) ? t : e;
    });
    var s;
    t != null && t.compat && !("runtime" in e) && (e.runtime = {
      hasPendingJob: () => e.hasPendingJob(),
      executePendingJobs: (n) => e.executePendingJobs(n)
    }), this.context = t != null && t.experimentalContextEx ? B(e) : e, this._options = t, this._symbolHandle = e.unwrapResult(e.evalCode("Symbol()")), this._map = new S(e), this._registeredMap = new S(e), this.registerAll((s = t == null ? void 0 : t.registeredObjects) != null ? s : T);
  }
  /**
   * Dispose of the arena and managed handles. This method won't dispose the VM itself, so the VM has to be disposed of manually.
   */
  dispose() {
    var e, t;
    this._map.dispose(), this._registeredMap.dispose(), this._symbolHandle.dispose(), (t = (e = this.context).disposeEx) == null || t.call(e);
  }
  /**
   * Evaluate JS code in the VM and get the result as an object on the host side. It also converts and re-throws error objects when an error is thrown during evaluation.
   */
  evalCode(e) {
    const t = this.context.evalCode(e);
    return this._unwrapResultAndUnmarshal(t);
  }
  /**
   * Almost same as `vm.executePendingJobs()`, but it converts and re-throws error objects when an error is thrown during evaluation.
   */
  executePendingJobs(e) {
    const t = this.context.runtime.executePendingJobs(e);
    if ("value" in t)
      return t.value;
    throw this._unwrapIfNotSynced(t.error.consume(this._unmarshal));
  }
  /**
   * Expose objects as global objects in the VM.
   *
   * By default, exposed objects are not synchronized between the host and the VM.
   * If you want to sync an objects, first wrap the object with sync method, and then expose the wrapped object.
   */
  expose(e) {
    for (const [t, s] of Object.entries(e))
      $(this._marshal(s), (n) => {
        this.context.setProp(this.context.global, t, n);
      });
  }
  /**
   * Enables sync for the object between the host and the VM and returns objects wrapped with proxies.
   *
   * The return value is necessary in order to reflect changes to the object from the host to the VM. Please note that setting a value in the field or deleting a field in the original object will not synchronize it.
   */
  sync(e) {
    const t = this._wrap(e);
    return typeof t == "undefined" ? e : (E(t, (s) => {
      const n = this._unwrap(s);
      this._sync.add(n);
    }), t);
  }
  /**
   * Register a pair of objects that will be considered the same between the host and the QuickJS VM.
   *
   * Instead of a string, you can also pass a QuickJSHandle directly. In that case, however, when  you have to dispose them manually when destroying the VM.
   */
  register(e, t) {
    if (this._registeredMap.has(e))
      return;
    const s = typeof t == "string" ? this._unwrapResult(this.context.evalCode(t)) : t;
    J(this.context, s, this.context.undefined) || (typeof t == "string" && this._registeredMapDispose.add(e), this._registeredMap.set(e, s));
  }
  /**
   * Execute `register` methods for each pair.
   */
  registerAll(e) {
    for (const [t, s] of e)
      this.register(t, s);
  }
  /**
   * Unregister a pair of objects that were registered with `registeredObjects` option and `register` method.
   */
  unregister(e, t) {
    this._registeredMap.delete(e, this._registeredMapDispose.has(e) || t), this._registeredMapDispose.delete(e);
  }
  /**
   * Execute `unregister` methods for each target.
   */
  unregisterAll(e, t) {
    for (const s of e)
      this.unregister(s, t);
  }
  startSync(e) {
    if (!v(e))
      return;
    const t = this._unwrap(e);
    this._sync.add(t);
  }
  endSync(e) {
    this._sync.delete(this._unwrap(e));
  }
  _unwrapResult(e) {
    if ("value" in e)
      return e.value;
    throw this._unwrapIfNotSynced(e.error.consume(this._unmarshal));
  }
  _unwrapResultAndUnmarshal(e) {
    if (e)
      return this._unwrapIfNotSynced(this._unwrapResult(e).consume(this._unmarshal));
  }
  _register(e, t, s = this._map, n) {
    if (this._registeredMap.has(e) || this._registeredMap.hasHandle(t))
      return;
    let o = this._wrap(e);
    const [i] = this._wrapHandle(t), a = e instanceof Promise;
    if (!i || !o && !a)
      return;
    a && (o = e);
    const u = this._unwrap(e), [p, l] = this._unwrapHandle(t);
    if (s.set(o, i, u, p))
      n && this._sync.add(u);
    else
      throw l && p.dispose(), new Error("already registered");
    return [o, i];
  }
  _wrap(e) {
    var t;
    return me(
      this.context,
      e,
      this._symbol,
      this._symbolHandle,
      this._marshal,
      this._syncMode,
      (t = this._options) == null ? void 0 : t.isWrappable
    );
  }
  _unwrap(e) {
    return w(e, this._symbol);
  }
  _wrapHandle(e) {
    var t;
    return he(
      this.context,
      e,
      this._symbol,
      this._symbolHandle,
      this._unmarshal,
      this._syncMode,
      (t = this._options) == null ? void 0 : t.isHandleWrappable
    );
  }
  _unwrapHandle(e) {
    return j(this.context, e, this._symbolHandle);
  }
}
export {
  we as Arena,
  S as VMMap,
  y as call,
  ve as complexity,
  be as consumeAll,
  T as defaultRegisteredObjects,
  J as eq,
  Z as isES2015Class,
  W as isHandleObject,
  v as isObject,
  z as json,
  M as marshal,
  de as unmarshal,
  E as walkObject
};
