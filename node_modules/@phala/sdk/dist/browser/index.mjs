var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from5, except, desc) => {
  if (from5 && typeof from5 === "object" || typeof from5 === "function") {
    for (let key of __getOwnPropNames(from5))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc(from5, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// node_modules/@esbuild-plugins/node-globals-polyfill/process.js
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop() {
}
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener, once, off, removeListener, removeAllListeners, emit, performance, performanceNow, startTime, process, defines;
var init_process = __esm({
  "node_modules/@esbuild-plugins/node-globals-polyfill/process.js"() {
    "use strict";
    cachedSetTimeout = defaultSetTimout;
    cachedClearTimeout = defaultClearTimeout;
    if (typeof globalThis.setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    }
    if (typeof globalThis.clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    }
    queue = [];
    draining = false;
    queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser";
    platform = "browser";
    browser = true;
    env = {};
    argv = [];
    version = "";
    versions = {};
    release = {};
    config = {};
    on = noop;
    addListener = noop;
    once = noop;
    off = noop;
    removeListener = noop;
    removeAllListeners = noop;
    emit = noop;
    performance = globalThis.performance || {};
    performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
    startTime = /* @__PURE__ */ new Date();
    process = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on,
      addListener,
      once,
      off,
      removeListener,
      removeAllListeners,
      emit,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    };
    defines = {};
    Object.keys(defines).forEach((key) => {
      const segs = key.split(".");
      let target = process;
      for (let i = 0; i < segs.length; i++) {
        const seg = segs[i];
        if (i === segs.length - 1) {
          target[seg] = defines[key];
        } else {
          target = target[seg] || (target[seg] = {});
        }
      }
    });
  }
});

// node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function base64toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function base64fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(
      encodeChunk(
        uint8,
        i,
        i + maxChunkLength > len2 ? len2 : i + maxChunkLength
      )
    );
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill3, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill3 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill3, encoding) : createBuffer(that, size).fill(fill3);
  }
  return createBuffer(that, size);
}
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError(
    "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
  );
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError(
      "Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes"
    );
  }
  return length | 0;
}
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(
          buffer,
          val,
          byteOffset
        );
      } else {
        return Uint8Array.prototype.lastIndexOf.call(
          buffer,
          val,
          byteOffset
        );
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(
    utf8ToBytes(string, buf.length - offset),
    buf,
    offset,
    length
  );
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(
    utf16leToBytes(string, buf.length - offset),
    buf,
    offset,
    length
  );
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64fromByteArray(buf);
  } else {
    return base64fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(
      buf,
      value,
      offset,
      4,
      34028234663852886e22,
      -34028234663852886e22
    );
  }
  ieee754write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(
      buf,
      value,
      offset,
      8,
      17976931348623157e292,
      -17976931348623157e292
    );
  }
  ieee754write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return base64toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
function ieee754read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function ieee754write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s * 128;
}
var lookup, revLookup, Arr, inited, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
var init_Buffer = __esm({
  "node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js"() {
    "use strict";
    init_process();
    init_buffer();
    lookup = [];
    revLookup = [];
    Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited = false;
    Buffer.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
    Buffer.poolSize = 8192;
    Buffer._augment = function(arr) {
      arr.__proto__ = Buffer.prototype;
      return arr;
    };
    Buffer.from = function(value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };
    Buffer.kMaxLength = kMaxLength();
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype;
      Buffer.__proto__ = Uint8Array;
      if (typeof Symbol !== "undefined" && Symbol.species && Buffer[Symbol.species] === Buffer) {
      }
    }
    Buffer.alloc = function(size, fill3, encoding) {
      return alloc(null, size, fill3, encoding);
    };
    Buffer.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer.isBuffer = isBuffer;
    Buffer.compare = function compare(a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer.byteLength = byteLength;
    Buffer.prototype._isBuffer = true;
    Buffer.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer.prototype.toString = function toString() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer.prototype.equals = function equals(b) {
      if (!internalIsBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer.compare(this, b) === 0;
    };
    Buffer.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    Buffer.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
            return asciiWrite(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH = 4096;
    Buffer.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer(sliceLen, void 0);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }
      return newBuf;
    };
    Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length);
      }
      var val = this[offset + --byteLength3];
      var mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul;
      }
      return val;
    };
    Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var i = byteLength3;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754read(this, offset, true, 23, 4);
    };
    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754read(this, offset, false, 23, 4);
    };
    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754read(this, offset, true, 52, 8);
    };
    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754read(this, offset, false, 52, 8);
    };
    Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      var i = byteLength3 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i = byteLength3 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (!Buffer.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i;
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js
var init_buffer = __esm({
  "node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js"() {
    "use strict";
    init_Buffer();
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback2(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = EventEmitter2;
    function EventEmitter2() {
      this._listeners = {};
    }
    EventEmitter2.prototype.on = function on3(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter2.prototype.off = function off3(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners2 = this._listeners[evt];
          for (var i = 0; i < listeners2.length; )
            if (listeners2[i].fn === fn)
              listeners2.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter2.prototype.emit = function emit4(evt) {
      var listeners2 = this._listeners[evt];
      if (listeners2) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners2.length; )
          listeners2[i].fn.apply(listeners2[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = pool;
    function pool(alloc3, slice3, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc3(size2);
        if (offset + size2 > SIZE) {
          slab = alloc3(SIZE);
          offset = 0;
        }
        var buf = slice3.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from5(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof globalThis !== "undefined" && globalThis && globalThis.process && globalThis.process.versions && globalThis.process.versions.node);
    util.global = util.isNode && globalThis || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString2(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject2(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer3 = util.inquire("buffer").Buffer;
        return Buffer3.prototype.utf8Write ? Buffer3 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys2 = Object.keys(src), i = 0; i < keys2.length; ++i)
        if (dst[keys2[i]] === void 0 || !ifNotSet)
          dst[keys2[i]] = src[keys2[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get() {
            return name;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys2 = Object.keys(this), i2 = keys2.length - 1; i2 > -1; --i2)
          if (fieldMap[keys2[i2]] === 1 && this[keys2[i2]] !== void 0 && this[keys2[i2]] !== null)
            return keys2[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer3 = util.Buffer;
      if (!Buffer3) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer3.from !== Uint8Array.from && Buffer3.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer3(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer3.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer3(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop3() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop3, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc3(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop3, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop3, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback2) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback2)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback2(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback2(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback2(err2);
              }
            }
            self2.emit("data", response, method);
            return callback2(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback2(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = require_index_minimal();
  }
});

// src/pruntime/proto/index.js
var require_proto = __commonJS({
  "src/pruntime/proto/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var $protobuf = require_minimal2();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.prpc = function() {
      var prpc2 = {};
      prpc2.PrpcError = function() {
        function PrpcError(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        PrpcError.prototype.message = "";
        PrpcError.create = function create(properties) {
          return new PrpcError(properties);
        };
        PrpcError.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.message);
          return writer;
        };
        PrpcError.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        PrpcError.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.prpc.PrpcError();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.message = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        PrpcError.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        PrpcError.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.message != null && message.hasOwnProperty("message")) {
            if (!$util.isString(message.message))
              return "message: string expected";
          }
          return null;
        };
        PrpcError.fromObject = function fromObject3(object) {
          if (object instanceof $root.prpc.PrpcError)
            return object;
          var message = new $root.prpc.PrpcError();
          if (object.message != null)
            message.message = String(object.message);
          return message;
        };
        PrpcError.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults)
            object.message = "";
          if (message.message != null && message.hasOwnProperty("message"))
            object.message = message.message;
          return object;
        };
        PrpcError.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        PrpcError.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/prpc.PrpcError";
        };
        return PrpcError;
      }();
      return prpc2;
    }();
    $root.pruntime_rpc = function() {
      var pruntime_rpc2 = {};
      pruntime_rpc2.PhactoryAPI = function() {
        function PhactoryAPI2(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }
        (PhactoryAPI2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = PhactoryAPI2;
        PhactoryAPI2.create = function create(rpcImpl, requestDelimited, responseDelimited) {
          return new this(rpcImpl, requestDelimited, responseDelimited);
        };
        Object.defineProperty(PhactoryAPI2.prototype.getInfo = function getInfo(request, callback2) {
          return this.rpcCall(getInfo, $root.google.protobuf.Empty, $root.pruntime_rpc.PhactoryInfo, request, callback2);
        }, "name", { value: "GetInfo" });
        Object.defineProperty(PhactoryAPI2.prototype.syncHeader = function syncHeader(request, callback2) {
          return this.rpcCall(syncHeader, $root.pruntime_rpc.HeadersToSync, $root.pruntime_rpc.SyncedTo, request, callback2);
        }, "name", { value: "SyncHeader" });
        Object.defineProperty(PhactoryAPI2.prototype.syncParaHeader = function syncParaHeader(request, callback2) {
          return this.rpcCall(syncParaHeader, $root.pruntime_rpc.ParaHeadersToSync, $root.pruntime_rpc.SyncedTo, request, callback2);
        }, "name", { value: "SyncParaHeader" });
        Object.defineProperty(PhactoryAPI2.prototype.syncCombinedHeaders = function syncCombinedHeaders(request, callback2) {
          return this.rpcCall(syncCombinedHeaders, $root.pruntime_rpc.CombinedHeadersToSync, $root.pruntime_rpc.HeadersSyncedTo, request, callback2);
        }, "name", { value: "SyncCombinedHeaders" });
        Object.defineProperty(PhactoryAPI2.prototype.dispatchBlocks = function dispatchBlocks(request, callback2) {
          return this.rpcCall(dispatchBlocks, $root.pruntime_rpc.Blocks, $root.pruntime_rpc.SyncedTo, request, callback2);
        }, "name", { value: "DispatchBlocks" });
        Object.defineProperty(PhactoryAPI2.prototype.initRuntime = function initRuntime(request, callback2) {
          return this.rpcCall(initRuntime, $root.pruntime_rpc.InitRuntimeRequest, $root.pruntime_rpc.InitRuntimeResponse, request, callback2);
        }, "name", { value: "InitRuntime" });
        Object.defineProperty(PhactoryAPI2.prototype.getRuntimeInfo = function getRuntimeInfo(request, callback2) {
          return this.rpcCall(getRuntimeInfo, $root.pruntime_rpc.GetRuntimeInfoRequest, $root.pruntime_rpc.InitRuntimeResponse, request, callback2);
        }, "name", { value: "GetRuntimeInfo" });
        Object.defineProperty(PhactoryAPI2.prototype.getEgressMessages = function getEgressMessages(request, callback2) {
          return this.rpcCall(getEgressMessages, $root.google.protobuf.Empty, $root.pruntime_rpc.GetEgressMessagesResponse, request, callback2);
        }, "name", { value: "GetEgressMessages" });
        Object.defineProperty(PhactoryAPI2.prototype.contractQuery = function contractQuery(request, callback2) {
          return this.rpcCall(contractQuery, $root.pruntime_rpc.ContractQueryRequest, $root.pruntime_rpc.ContractQueryResponse, request, callback2);
        }, "name", { value: "ContractQuery" });
        Object.defineProperty(PhactoryAPI2.prototype.getWorkerState = function getWorkerState(request, callback2) {
          return this.rpcCall(getWorkerState, $root.pruntime_rpc.GetWorkerStateRequest, $root.pruntime_rpc.WorkerState, request, callback2);
        }, "name", { value: "GetWorkerState" });
        Object.defineProperty(PhactoryAPI2.prototype.addEndpoint = function addEndpoint(request, callback2) {
          return this.rpcCall(addEndpoint, $root.pruntime_rpc.AddEndpointRequest, $root.pruntime_rpc.GetEndpointResponse, request, callback2);
        }, "name", { value: "AddEndpoint" });
        Object.defineProperty(PhactoryAPI2.prototype.refreshEndpointSigningTime = function refreshEndpointSigningTime(request, callback2) {
          return this.rpcCall(refreshEndpointSigningTime, $root.google.protobuf.Empty, $root.pruntime_rpc.GetEndpointResponse, request, callback2);
        }, "name", { value: "RefreshEndpointSigningTime" });
        Object.defineProperty(PhactoryAPI2.prototype.getEndpointInfo = function getEndpointInfo(request, callback2) {
          return this.rpcCall(getEndpointInfo, $root.google.protobuf.Empty, $root.pruntime_rpc.GetEndpointResponse, request, callback2);
        }, "name", { value: "GetEndpointInfo" });
        Object.defineProperty(PhactoryAPI2.prototype.signEndpointInfo = function signEndpointInfo(request, callback2) {
          return this.rpcCall(signEndpointInfo, $root.pruntime_rpc.SignEndpointsRequest, $root.pruntime_rpc.GetEndpointResponse, request, callback2);
        }, "name", { value: "SignEndpointInfo" });
        Object.defineProperty(PhactoryAPI2.prototype.derivePhalaI2pKey = function derivePhalaI2pKey(request, callback2) {
          return this.rpcCall(derivePhalaI2pKey, $root.google.protobuf.Empty, $root.pruntime_rpc.DerivePhalaI2pKeyResponse, request, callback2);
        }, "name", { value: "DerivePhalaI2pKey" });
        Object.defineProperty(PhactoryAPI2.prototype.echo = function echo(request, callback2) {
          return this.rpcCall(echo, $root.pruntime_rpc.EchoMessage, $root.pruntime_rpc.EchoMessage, request, callback2);
        }, "name", { value: "Echo" });
        Object.defineProperty(PhactoryAPI2.prototype.handoverCreateChallenge = function handoverCreateChallenge(request, callback2) {
          return this.rpcCall(handoverCreateChallenge, $root.google.protobuf.Empty, $root.pruntime_rpc.HandoverChallenge, request, callback2);
        }, "name", { value: "HandoverCreateChallenge" });
        Object.defineProperty(PhactoryAPI2.prototype.handoverStart = function handoverStart(request, callback2) {
          return this.rpcCall(handoverStart, $root.pruntime_rpc.HandoverChallengeResponse, $root.pruntime_rpc.HandoverWorkerKey, request, callback2);
        }, "name", { value: "HandoverStart" });
        Object.defineProperty(PhactoryAPI2.prototype.handoverAcceptChallenge = function handoverAcceptChallenge(request, callback2) {
          return this.rpcCall(handoverAcceptChallenge, $root.pruntime_rpc.HandoverChallenge, $root.pruntime_rpc.HandoverChallengeResponse, request, callback2);
        }, "name", { value: "HandoverAcceptChallenge" });
        Object.defineProperty(PhactoryAPI2.prototype.handoverReceive = function handoverReceive(request, callback2) {
          return this.rpcCall(handoverReceive, $root.pruntime_rpc.HandoverWorkerKey, $root.google.protobuf.Empty, request, callback2);
        }, "name", { value: "HandoverReceive" });
        Object.defineProperty(PhactoryAPI2.prototype.configNetwork = function configNetwork(request, callback2) {
          return this.rpcCall(configNetwork, $root.pruntime_rpc.NetworkConfig, $root.google.protobuf.Empty, request, callback2);
        }, "name", { value: "ConfigNetwork" });
        Object.defineProperty(PhactoryAPI2.prototype.httpFetch = function httpFetch(request, callback2) {
          return this.rpcCall(httpFetch, $root.pruntime_rpc.HttpRequest, $root.pruntime_rpc.HttpResponse, request, callback2);
        }, "name", { value: "HttpFetch" });
        Object.defineProperty(PhactoryAPI2.prototype.getContractInfo = function getContractInfo(request, callback2) {
          return this.rpcCall(getContractInfo, $root.pruntime_rpc.GetContractInfoRequest, $root.pruntime_rpc.GetContractInfoResponse, request, callback2);
        }, "name", { value: "GetContractInfo" });
        Object.defineProperty(PhactoryAPI2.prototype.getClusterInfo = function getClusterInfo(request, callback2) {
          return this.rpcCall(getClusterInfo, $root.google.protobuf.Empty, $root.pruntime_rpc.GetClusterInfoResponse, request, callback2);
        }, "name", { value: "GetClusterInfo" });
        Object.defineProperty(PhactoryAPI2.prototype.uploadSidevmCode = function uploadSidevmCode(request, callback2) {
          return this.rpcCall(uploadSidevmCode, $root.pruntime_rpc.SidevmCode, $root.google.protobuf.Empty, request, callback2);
        }, "name", { value: "UploadSidevmCode" });
        Object.defineProperty(PhactoryAPI2.prototype.calculateContractId = function calculateContractId(request, callback2) {
          return this.rpcCall(calculateContractId, $root.pruntime_rpc.ContractParameters, $root.pruntime_rpc.ContractId, request, callback2);
        }, "name", { value: "CalculateContractId" });
        Object.defineProperty(PhactoryAPI2.prototype.getNetworkConfig = function getNetworkConfig(request, callback2) {
          return this.rpcCall(getNetworkConfig, $root.google.protobuf.Empty, $root.pruntime_rpc.NetworkConfigResponse, request, callback2);
        }, "name", { value: "GetNetworkConfig" });
        Object.defineProperty(PhactoryAPI2.prototype.loadChainState = function loadChainState(request, callback2) {
          return this.rpcCall(loadChainState, $root.pruntime_rpc.ChainState, $root.google.protobuf.Empty, request, callback2);
        }, "name", { value: "LoadChainState" });
        Object.defineProperty(PhactoryAPI2.prototype.stop = function stop(request, callback2) {
          return this.rpcCall(stop, $root.pruntime_rpc.StopOptions, $root.google.protobuf.Empty, request, callback2);
        }, "name", { value: "Stop" });
        Object.defineProperty(PhactoryAPI2.prototype.loadStorageProof = function loadStorageProof(request, callback2) {
          return this.rpcCall(loadStorageProof, $root.pruntime_rpc.StorageProof, $root.google.protobuf.Empty, request, callback2);
        }, "name", { value: "LoadStorageProof" });
        Object.defineProperty(PhactoryAPI2.prototype.takeCheckpoint = function takeCheckpoint(request, callback2) {
          return this.rpcCall(takeCheckpoint, $root.google.protobuf.Empty, $root.pruntime_rpc.SyncedTo, request, callback2);
        }, "name", { value: "TakeCheckpoint" });
        Object.defineProperty(PhactoryAPI2.prototype.statistics = function statistics(request, callback2) {
          return this.rpcCall(statistics, $root.pruntime_rpc.StatisticsReqeust, $root.pruntime_rpc.StatisticsResponse, request, callback2);
        }, "name", { value: "Statistics" });
        Object.defineProperty(PhactoryAPI2.prototype.generateClusterStateRequest = function generateClusterStateRequest(request, callback2) {
          return this.rpcCall(generateClusterStateRequest, $root.google.protobuf.Empty, $root.pruntime_rpc.SaveClusterStateArguments, request, callback2);
        }, "name", { value: "GenerateClusterStateRequest" });
        Object.defineProperty(PhactoryAPI2.prototype.saveClusterState = function saveClusterState(request, callback2) {
          return this.rpcCall(saveClusterState, $root.pruntime_rpc.SaveClusterStateArguments, $root.pruntime_rpc.SaveClusterStateResponse, request, callback2);
        }, "name", { value: "SaveClusterState" });
        Object.defineProperty(PhactoryAPI2.prototype.loadClusterState = function loadClusterState(request, callback2) {
          return this.rpcCall(loadClusterState, $root.pruntime_rpc.SaveClusterStateResponse, $root.google.protobuf.Empty, request, callback2);
        }, "name", { value: "LoadClusterState" });
        Object.defineProperty(PhactoryAPI2.prototype.tryUpgradePinkRuntime = function tryUpgradePinkRuntime(request, callback2) {
          return this.rpcCall(tryUpgradePinkRuntime, $root.pruntime_rpc.PinkRuntimeVersion, $root.google.protobuf.Empty, request, callback2);
        }, "name", { value: "TryUpgradePinkRuntime" });
        return PhactoryAPI2;
      }();
      pruntime_rpc2.PhactoryInfo = function() {
        function PhactoryInfo(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        PhactoryInfo.prototype.initialized = false;
        PhactoryInfo.prototype.registered = false;
        PhactoryInfo.prototype.genesisBlockHash = null;
        PhactoryInfo.prototype.publicKey = null;
        PhactoryInfo.prototype.ecdhPublicKey = null;
        PhactoryInfo.prototype.headernum = 0;
        PhactoryInfo.prototype.paraHeadernum = 0;
        PhactoryInfo.prototype.blocknum = 0;
        PhactoryInfo.prototype.stateRoot = "";
        PhactoryInfo.prototype.devMode = false;
        PhactoryInfo.prototype.pendingMessages = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        PhactoryInfo.prototype.score = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        PhactoryInfo.prototype.gatekeeper = null;
        PhactoryInfo.prototype.version = "";
        PhactoryInfo.prototype.gitRevision = "";
        PhactoryInfo.prototype.memoryUsage = null;
        PhactoryInfo.prototype.waitingForParaheaders = false;
        PhactoryInfo.prototype.system = null;
        PhactoryInfo.prototype.canLoadChainState = false;
        PhactoryInfo.prototype.safeModeLevel = 0;
        PhactoryInfo.prototype.currentBlockTime = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        PhactoryInfo.prototype.maxSupportedPinkRuntimeVersion = "";
        var $oneOfFields;
        Object.defineProperty(PhactoryInfo.prototype, "_genesisBlockHash", {
          get: $util.oneOfGetter($oneOfFields = ["genesisBlockHash"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        Object.defineProperty(PhactoryInfo.prototype, "_publicKey", {
          get: $util.oneOfGetter($oneOfFields = ["publicKey"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        Object.defineProperty(PhactoryInfo.prototype, "_ecdhPublicKey", {
          get: $util.oneOfGetter($oneOfFields = ["ecdhPublicKey"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        PhactoryInfo.create = function create(properties) {
          return new PhactoryInfo(properties);
        };
        PhactoryInfo.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.initialized != null && Object.hasOwnProperty.call(message, "initialized"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).bool(message.initialized);
          if (message.registered != null && Object.hasOwnProperty.call(message, "registered"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).bool(message.registered);
          if (message.genesisBlockHash != null && Object.hasOwnProperty.call(message, "genesisBlockHash"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.genesisBlockHash);
          if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).string(message.publicKey);
          if (message.ecdhPublicKey != null && Object.hasOwnProperty.call(message, "ecdhPublicKey"))
            writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).string(message.ecdhPublicKey);
          if (message.headernum != null && Object.hasOwnProperty.call(message, "headernum"))
            writer.uint32(
              /* id 7, wireType 0 =*/
              56
            ).uint32(message.headernum);
          if (message.paraHeadernum != null && Object.hasOwnProperty.call(message, "paraHeadernum"))
            writer.uint32(
              /* id 8, wireType 0 =*/
              64
            ).uint32(message.paraHeadernum);
          if (message.blocknum != null && Object.hasOwnProperty.call(message, "blocknum"))
            writer.uint32(
              /* id 9, wireType 0 =*/
              72
            ).uint32(message.blocknum);
          if (message.stateRoot != null && Object.hasOwnProperty.call(message, "stateRoot"))
            writer.uint32(
              /* id 10, wireType 2 =*/
              82
            ).string(message.stateRoot);
          if (message.devMode != null && Object.hasOwnProperty.call(message, "devMode"))
            writer.uint32(
              /* id 11, wireType 0 =*/
              88
            ).bool(message.devMode);
          if (message.pendingMessages != null && Object.hasOwnProperty.call(message, "pendingMessages"))
            writer.uint32(
              /* id 12, wireType 0 =*/
              96
            ).uint64(message.pendingMessages);
          if (message.score != null && Object.hasOwnProperty.call(message, "score"))
            writer.uint32(
              /* id 13, wireType 0 =*/
              104
            ).uint64(message.score);
          if (message.gatekeeper != null && Object.hasOwnProperty.call(message, "gatekeeper"))
            $root.pruntime_rpc.GatekeeperStatus.encode(message.gatekeeper, writer.uint32(
              /* id 14, wireType 2 =*/
              114
            ).fork()).ldelim();
          if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(
              /* id 15, wireType 2 =*/
              122
            ).string(message.version);
          if (message.gitRevision != null && Object.hasOwnProperty.call(message, "gitRevision"))
            writer.uint32(
              /* id 16, wireType 2 =*/
              130
            ).string(message.gitRevision);
          if (message.memoryUsage != null && Object.hasOwnProperty.call(message, "memoryUsage"))
            $root.pruntime_rpc.MemoryUsage.encode(message.memoryUsage, writer.uint32(
              /* id 18, wireType 2 =*/
              146
            ).fork()).ldelim();
          if (message.waitingForParaheaders != null && Object.hasOwnProperty.call(message, "waitingForParaheaders"))
            writer.uint32(
              /* id 21, wireType 0 =*/
              168
            ).bool(message.waitingForParaheaders);
          if (message.system != null && Object.hasOwnProperty.call(message, "system"))
            $root.pruntime_rpc.SystemInfo.encode(message.system, writer.uint32(
              /* id 23, wireType 2 =*/
              186
            ).fork()).ldelim();
          if (message.canLoadChainState != null && Object.hasOwnProperty.call(message, "canLoadChainState"))
            writer.uint32(
              /* id 24, wireType 0 =*/
              192
            ).bool(message.canLoadChainState);
          if (message.safeModeLevel != null && Object.hasOwnProperty.call(message, "safeModeLevel"))
            writer.uint32(
              /* id 25, wireType 0 =*/
              200
            ).uint32(message.safeModeLevel);
          if (message.currentBlockTime != null && Object.hasOwnProperty.call(message, "currentBlockTime"))
            writer.uint32(
              /* id 26, wireType 0 =*/
              208
            ).uint64(message.currentBlockTime);
          if (message.maxSupportedPinkRuntimeVersion != null && Object.hasOwnProperty.call(message, "maxSupportedPinkRuntimeVersion"))
            writer.uint32(
              /* id 27, wireType 2 =*/
              218
            ).string(message.maxSupportedPinkRuntimeVersion);
          return writer;
        };
        PhactoryInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        PhactoryInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.PhactoryInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.initialized = reader.bool();
                break;
              }
              case 2: {
                message.registered = reader.bool();
                break;
              }
              case 4: {
                message.genesisBlockHash = reader.string();
                break;
              }
              case 5: {
                message.publicKey = reader.string();
                break;
              }
              case 6: {
                message.ecdhPublicKey = reader.string();
                break;
              }
              case 7: {
                message.headernum = reader.uint32();
                break;
              }
              case 8: {
                message.paraHeadernum = reader.uint32();
                break;
              }
              case 9: {
                message.blocknum = reader.uint32();
                break;
              }
              case 10: {
                message.stateRoot = reader.string();
                break;
              }
              case 11: {
                message.devMode = reader.bool();
                break;
              }
              case 12: {
                message.pendingMessages = reader.uint64();
                break;
              }
              case 13: {
                message.score = reader.uint64();
                break;
              }
              case 14: {
                message.gatekeeper = $root.pruntime_rpc.GatekeeperStatus.decode(reader, reader.uint32());
                break;
              }
              case 15: {
                message.version = reader.string();
                break;
              }
              case 16: {
                message.gitRevision = reader.string();
                break;
              }
              case 18: {
                message.memoryUsage = $root.pruntime_rpc.MemoryUsage.decode(reader, reader.uint32());
                break;
              }
              case 21: {
                message.waitingForParaheaders = reader.bool();
                break;
              }
              case 23: {
                message.system = $root.pruntime_rpc.SystemInfo.decode(reader, reader.uint32());
                break;
              }
              case 24: {
                message.canLoadChainState = reader.bool();
                break;
              }
              case 25: {
                message.safeModeLevel = reader.uint32();
                break;
              }
              case 26: {
                message.currentBlockTime = reader.uint64();
                break;
              }
              case 27: {
                message.maxSupportedPinkRuntimeVersion = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        PhactoryInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        PhactoryInfo.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.initialized != null && message.hasOwnProperty("initialized")) {
            if (typeof message.initialized !== "boolean")
              return "initialized: boolean expected";
          }
          if (message.registered != null && message.hasOwnProperty("registered")) {
            if (typeof message.registered !== "boolean")
              return "registered: boolean expected";
          }
          if (message.genesisBlockHash != null && message.hasOwnProperty("genesisBlockHash")) {
            properties._genesisBlockHash = 1;
            if (!$util.isString(message.genesisBlockHash))
              return "genesisBlockHash: string expected";
          }
          if (message.publicKey != null && message.hasOwnProperty("publicKey")) {
            properties._publicKey = 1;
            if (!$util.isString(message.publicKey))
              return "publicKey: string expected";
          }
          if (message.ecdhPublicKey != null && message.hasOwnProperty("ecdhPublicKey")) {
            properties._ecdhPublicKey = 1;
            if (!$util.isString(message.ecdhPublicKey))
              return "ecdhPublicKey: string expected";
          }
          if (message.headernum != null && message.hasOwnProperty("headernum")) {
            if (!$util.isInteger(message.headernum))
              return "headernum: integer expected";
          }
          if (message.paraHeadernum != null && message.hasOwnProperty("paraHeadernum")) {
            if (!$util.isInteger(message.paraHeadernum))
              return "paraHeadernum: integer expected";
          }
          if (message.blocknum != null && message.hasOwnProperty("blocknum")) {
            if (!$util.isInteger(message.blocknum))
              return "blocknum: integer expected";
          }
          if (message.stateRoot != null && message.hasOwnProperty("stateRoot")) {
            if (!$util.isString(message.stateRoot))
              return "stateRoot: string expected";
          }
          if (message.devMode != null && message.hasOwnProperty("devMode")) {
            if (typeof message.devMode !== "boolean")
              return "devMode: boolean expected";
          }
          if (message.pendingMessages != null && message.hasOwnProperty("pendingMessages")) {
            if (!$util.isInteger(message.pendingMessages) && !(message.pendingMessages && $util.isInteger(message.pendingMessages.low) && $util.isInteger(message.pendingMessages.high)))
              return "pendingMessages: integer|Long expected";
          }
          if (message.score != null && message.hasOwnProperty("score")) {
            if (!$util.isInteger(message.score) && !(message.score && $util.isInteger(message.score.low) && $util.isInteger(message.score.high)))
              return "score: integer|Long expected";
          }
          if (message.gatekeeper != null && message.hasOwnProperty("gatekeeper")) {
            var error = $root.pruntime_rpc.GatekeeperStatus.verify(message.gatekeeper);
            if (error)
              return "gatekeeper." + error;
          }
          if (message.version != null && message.hasOwnProperty("version")) {
            if (!$util.isString(message.version))
              return "version: string expected";
          }
          if (message.gitRevision != null && message.hasOwnProperty("gitRevision")) {
            if (!$util.isString(message.gitRevision))
              return "gitRevision: string expected";
          }
          if (message.memoryUsage != null && message.hasOwnProperty("memoryUsage")) {
            var error = $root.pruntime_rpc.MemoryUsage.verify(message.memoryUsage);
            if (error)
              return "memoryUsage." + error;
          }
          if (message.waitingForParaheaders != null && message.hasOwnProperty("waitingForParaheaders")) {
            if (typeof message.waitingForParaheaders !== "boolean")
              return "waitingForParaheaders: boolean expected";
          }
          if (message.system != null && message.hasOwnProperty("system")) {
            var error = $root.pruntime_rpc.SystemInfo.verify(message.system);
            if (error)
              return "system." + error;
          }
          if (message.canLoadChainState != null && message.hasOwnProperty("canLoadChainState")) {
            if (typeof message.canLoadChainState !== "boolean")
              return "canLoadChainState: boolean expected";
          }
          if (message.safeModeLevel != null && message.hasOwnProperty("safeModeLevel")) {
            if (!$util.isInteger(message.safeModeLevel))
              return "safeModeLevel: integer expected";
          }
          if (message.currentBlockTime != null && message.hasOwnProperty("currentBlockTime")) {
            if (!$util.isInteger(message.currentBlockTime) && !(message.currentBlockTime && $util.isInteger(message.currentBlockTime.low) && $util.isInteger(message.currentBlockTime.high)))
              return "currentBlockTime: integer|Long expected";
          }
          if (message.maxSupportedPinkRuntimeVersion != null && message.hasOwnProperty("maxSupportedPinkRuntimeVersion")) {
            if (!$util.isString(message.maxSupportedPinkRuntimeVersion))
              return "maxSupportedPinkRuntimeVersion: string expected";
          }
          return null;
        };
        PhactoryInfo.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.PhactoryInfo)
            return object;
          var message = new $root.pruntime_rpc.PhactoryInfo();
          if (object.initialized != null)
            message.initialized = Boolean(object.initialized);
          if (object.registered != null)
            message.registered = Boolean(object.registered);
          if (object.genesisBlockHash != null)
            message.genesisBlockHash = String(object.genesisBlockHash);
          if (object.publicKey != null)
            message.publicKey = String(object.publicKey);
          if (object.ecdhPublicKey != null)
            message.ecdhPublicKey = String(object.ecdhPublicKey);
          if (object.headernum != null)
            message.headernum = object.headernum >>> 0;
          if (object.paraHeadernum != null)
            message.paraHeadernum = object.paraHeadernum >>> 0;
          if (object.blocknum != null)
            message.blocknum = object.blocknum >>> 0;
          if (object.stateRoot != null)
            message.stateRoot = String(object.stateRoot);
          if (object.devMode != null)
            message.devMode = Boolean(object.devMode);
          if (object.pendingMessages != null) {
            if ($util.Long)
              (message.pendingMessages = $util.Long.fromValue(object.pendingMessages)).unsigned = true;
            else if (typeof object.pendingMessages === "string")
              message.pendingMessages = parseInt(object.pendingMessages, 10);
            else if (typeof object.pendingMessages === "number")
              message.pendingMessages = object.pendingMessages;
            else if (typeof object.pendingMessages === "object")
              message.pendingMessages = new $util.LongBits(object.pendingMessages.low >>> 0, object.pendingMessages.high >>> 0).toNumber(true);
          }
          if (object.score != null) {
            if ($util.Long)
              (message.score = $util.Long.fromValue(object.score)).unsigned = true;
            else if (typeof object.score === "string")
              message.score = parseInt(object.score, 10);
            else if (typeof object.score === "number")
              message.score = object.score;
            else if (typeof object.score === "object")
              message.score = new $util.LongBits(object.score.low >>> 0, object.score.high >>> 0).toNumber(true);
          }
          if (object.gatekeeper != null) {
            if (typeof object.gatekeeper !== "object")
              throw TypeError(".pruntime_rpc.PhactoryInfo.gatekeeper: object expected");
            message.gatekeeper = $root.pruntime_rpc.GatekeeperStatus.fromObject(object.gatekeeper);
          }
          if (object.version != null)
            message.version = String(object.version);
          if (object.gitRevision != null)
            message.gitRevision = String(object.gitRevision);
          if (object.memoryUsage != null) {
            if (typeof object.memoryUsage !== "object")
              throw TypeError(".pruntime_rpc.PhactoryInfo.memoryUsage: object expected");
            message.memoryUsage = $root.pruntime_rpc.MemoryUsage.fromObject(object.memoryUsage);
          }
          if (object.waitingForParaheaders != null)
            message.waitingForParaheaders = Boolean(object.waitingForParaheaders);
          if (object.system != null) {
            if (typeof object.system !== "object")
              throw TypeError(".pruntime_rpc.PhactoryInfo.system: object expected");
            message.system = $root.pruntime_rpc.SystemInfo.fromObject(object.system);
          }
          if (object.canLoadChainState != null)
            message.canLoadChainState = Boolean(object.canLoadChainState);
          if (object.safeModeLevel != null)
            message.safeModeLevel = object.safeModeLevel >>> 0;
          if (object.currentBlockTime != null) {
            if ($util.Long)
              (message.currentBlockTime = $util.Long.fromValue(object.currentBlockTime)).unsigned = true;
            else if (typeof object.currentBlockTime === "string")
              message.currentBlockTime = parseInt(object.currentBlockTime, 10);
            else if (typeof object.currentBlockTime === "number")
              message.currentBlockTime = object.currentBlockTime;
            else if (typeof object.currentBlockTime === "object")
              message.currentBlockTime = new $util.LongBits(object.currentBlockTime.low >>> 0, object.currentBlockTime.high >>> 0).toNumber(true);
          }
          if (object.maxSupportedPinkRuntimeVersion != null)
            message.maxSupportedPinkRuntimeVersion = String(object.maxSupportedPinkRuntimeVersion);
          return message;
        };
        PhactoryInfo.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.initialized = false;
            object.registered = false;
            object.headernum = 0;
            object.paraHeadernum = 0;
            object.blocknum = 0;
            object.stateRoot = "";
            object.devMode = false;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.pendingMessages = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.pendingMessages = options2.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.score = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.score = options2.longs === String ? "0" : 0;
            object.gatekeeper = null;
            object.version = "";
            object.gitRevision = "";
            object.memoryUsage = null;
            object.waitingForParaheaders = false;
            object.system = null;
            object.canLoadChainState = false;
            object.safeModeLevel = 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.currentBlockTime = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.currentBlockTime = options2.longs === String ? "0" : 0;
            object.maxSupportedPinkRuntimeVersion = "";
          }
          if (message.initialized != null && message.hasOwnProperty("initialized"))
            object.initialized = message.initialized;
          if (message.registered != null && message.hasOwnProperty("registered"))
            object.registered = message.registered;
          if (message.genesisBlockHash != null && message.hasOwnProperty("genesisBlockHash")) {
            object.genesisBlockHash = message.genesisBlockHash;
            if (options2.oneofs)
              object._genesisBlockHash = "genesisBlockHash";
          }
          if (message.publicKey != null && message.hasOwnProperty("publicKey")) {
            object.publicKey = message.publicKey;
            if (options2.oneofs)
              object._publicKey = "publicKey";
          }
          if (message.ecdhPublicKey != null && message.hasOwnProperty("ecdhPublicKey")) {
            object.ecdhPublicKey = message.ecdhPublicKey;
            if (options2.oneofs)
              object._ecdhPublicKey = "ecdhPublicKey";
          }
          if (message.headernum != null && message.hasOwnProperty("headernum"))
            object.headernum = message.headernum;
          if (message.paraHeadernum != null && message.hasOwnProperty("paraHeadernum"))
            object.paraHeadernum = message.paraHeadernum;
          if (message.blocknum != null && message.hasOwnProperty("blocknum"))
            object.blocknum = message.blocknum;
          if (message.stateRoot != null && message.hasOwnProperty("stateRoot"))
            object.stateRoot = message.stateRoot;
          if (message.devMode != null && message.hasOwnProperty("devMode"))
            object.devMode = message.devMode;
          if (message.pendingMessages != null && message.hasOwnProperty("pendingMessages"))
            if (typeof message.pendingMessages === "number")
              object.pendingMessages = options2.longs === String ? String(message.pendingMessages) : message.pendingMessages;
            else
              object.pendingMessages = options2.longs === String ? $util.Long.prototype.toString.call(message.pendingMessages) : options2.longs === Number ? new $util.LongBits(message.pendingMessages.low >>> 0, message.pendingMessages.high >>> 0).toNumber(true) : message.pendingMessages;
          if (message.score != null && message.hasOwnProperty("score"))
            if (typeof message.score === "number")
              object.score = options2.longs === String ? String(message.score) : message.score;
            else
              object.score = options2.longs === String ? $util.Long.prototype.toString.call(message.score) : options2.longs === Number ? new $util.LongBits(message.score.low >>> 0, message.score.high >>> 0).toNumber(true) : message.score;
          if (message.gatekeeper != null && message.hasOwnProperty("gatekeeper"))
            object.gatekeeper = $root.pruntime_rpc.GatekeeperStatus.toObject(message.gatekeeper, options2);
          if (message.version != null && message.hasOwnProperty("version"))
            object.version = message.version;
          if (message.gitRevision != null && message.hasOwnProperty("gitRevision"))
            object.gitRevision = message.gitRevision;
          if (message.memoryUsage != null && message.hasOwnProperty("memoryUsage"))
            object.memoryUsage = $root.pruntime_rpc.MemoryUsage.toObject(message.memoryUsage, options2);
          if (message.waitingForParaheaders != null && message.hasOwnProperty("waitingForParaheaders"))
            object.waitingForParaheaders = message.waitingForParaheaders;
          if (message.system != null && message.hasOwnProperty("system"))
            object.system = $root.pruntime_rpc.SystemInfo.toObject(message.system, options2);
          if (message.canLoadChainState != null && message.hasOwnProperty("canLoadChainState"))
            object.canLoadChainState = message.canLoadChainState;
          if (message.safeModeLevel != null && message.hasOwnProperty("safeModeLevel"))
            object.safeModeLevel = message.safeModeLevel;
          if (message.currentBlockTime != null && message.hasOwnProperty("currentBlockTime"))
            if (typeof message.currentBlockTime === "number")
              object.currentBlockTime = options2.longs === String ? String(message.currentBlockTime) : message.currentBlockTime;
            else
              object.currentBlockTime = options2.longs === String ? $util.Long.prototype.toString.call(message.currentBlockTime) : options2.longs === Number ? new $util.LongBits(message.currentBlockTime.low >>> 0, message.currentBlockTime.high >>> 0).toNumber(true) : message.currentBlockTime;
          if (message.maxSupportedPinkRuntimeVersion != null && message.hasOwnProperty("maxSupportedPinkRuntimeVersion"))
            object.maxSupportedPinkRuntimeVersion = message.maxSupportedPinkRuntimeVersion;
          return object;
        };
        PhactoryInfo.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        PhactoryInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.PhactoryInfo";
        };
        return PhactoryInfo;
      }();
      pruntime_rpc2.SystemInfo = function() {
        function SystemInfo(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        SystemInfo.prototype.registered = false;
        SystemInfo.prototype.publicKey = "";
        SystemInfo.prototype.ecdhPublicKey = "";
        SystemInfo.prototype.gatekeeper = null;
        SystemInfo.prototype.numberOfClusters = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        SystemInfo.prototype.numberOfContracts = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        SystemInfo.prototype.maxSupportedConsensusVersion = 0;
        SystemInfo.prototype.genesisBlock = 0;
        SystemInfo.create = function create(properties) {
          return new SystemInfo(properties);
        };
        SystemInfo.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.registered != null && Object.hasOwnProperty.call(message, "registered"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).bool(message.registered);
          if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.publicKey);
          if (message.ecdhPublicKey != null && Object.hasOwnProperty.call(message, "ecdhPublicKey"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.ecdhPublicKey);
          if (message.gatekeeper != null && Object.hasOwnProperty.call(message, "gatekeeper"))
            $root.pruntime_rpc.GatekeeperStatus.encode(message.gatekeeper, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          if (message.numberOfClusters != null && Object.hasOwnProperty.call(message, "numberOfClusters"))
            writer.uint32(
              /* id 5, wireType 0 =*/
              40
            ).uint64(message.numberOfClusters);
          if (message.numberOfContracts != null && Object.hasOwnProperty.call(message, "numberOfContracts"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).uint64(message.numberOfContracts);
          if (message.maxSupportedConsensusVersion != null && Object.hasOwnProperty.call(message, "maxSupportedConsensusVersion"))
            writer.uint32(
              /* id 7, wireType 0 =*/
              56
            ).uint32(message.maxSupportedConsensusVersion);
          if (message.genesisBlock != null && Object.hasOwnProperty.call(message, "genesisBlock"))
            writer.uint32(
              /* id 8, wireType 0 =*/
              64
            ).uint32(message.genesisBlock);
          return writer;
        };
        SystemInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        SystemInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.SystemInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.registered = reader.bool();
                break;
              }
              case 2: {
                message.publicKey = reader.string();
                break;
              }
              case 3: {
                message.ecdhPublicKey = reader.string();
                break;
              }
              case 4: {
                message.gatekeeper = $root.pruntime_rpc.GatekeeperStatus.decode(reader, reader.uint32());
                break;
              }
              case 5: {
                message.numberOfClusters = reader.uint64();
                break;
              }
              case 6: {
                message.numberOfContracts = reader.uint64();
                break;
              }
              case 7: {
                message.maxSupportedConsensusVersion = reader.uint32();
                break;
              }
              case 8: {
                message.genesisBlock = reader.uint32();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        SystemInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        SystemInfo.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.registered != null && message.hasOwnProperty("registered")) {
            if (typeof message.registered !== "boolean")
              return "registered: boolean expected";
          }
          if (message.publicKey != null && message.hasOwnProperty("publicKey")) {
            if (!$util.isString(message.publicKey))
              return "publicKey: string expected";
          }
          if (message.ecdhPublicKey != null && message.hasOwnProperty("ecdhPublicKey")) {
            if (!$util.isString(message.ecdhPublicKey))
              return "ecdhPublicKey: string expected";
          }
          if (message.gatekeeper != null && message.hasOwnProperty("gatekeeper")) {
            var error = $root.pruntime_rpc.GatekeeperStatus.verify(message.gatekeeper);
            if (error)
              return "gatekeeper." + error;
          }
          if (message.numberOfClusters != null && message.hasOwnProperty("numberOfClusters")) {
            if (!$util.isInteger(message.numberOfClusters) && !(message.numberOfClusters && $util.isInteger(message.numberOfClusters.low) && $util.isInteger(message.numberOfClusters.high)))
              return "numberOfClusters: integer|Long expected";
          }
          if (message.numberOfContracts != null && message.hasOwnProperty("numberOfContracts")) {
            if (!$util.isInteger(message.numberOfContracts) && !(message.numberOfContracts && $util.isInteger(message.numberOfContracts.low) && $util.isInteger(message.numberOfContracts.high)))
              return "numberOfContracts: integer|Long expected";
          }
          if (message.maxSupportedConsensusVersion != null && message.hasOwnProperty("maxSupportedConsensusVersion")) {
            if (!$util.isInteger(message.maxSupportedConsensusVersion))
              return "maxSupportedConsensusVersion: integer expected";
          }
          if (message.genesisBlock != null && message.hasOwnProperty("genesisBlock")) {
            if (!$util.isInteger(message.genesisBlock))
              return "genesisBlock: integer expected";
          }
          return null;
        };
        SystemInfo.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.SystemInfo)
            return object;
          var message = new $root.pruntime_rpc.SystemInfo();
          if (object.registered != null)
            message.registered = Boolean(object.registered);
          if (object.publicKey != null)
            message.publicKey = String(object.publicKey);
          if (object.ecdhPublicKey != null)
            message.ecdhPublicKey = String(object.ecdhPublicKey);
          if (object.gatekeeper != null) {
            if (typeof object.gatekeeper !== "object")
              throw TypeError(".pruntime_rpc.SystemInfo.gatekeeper: object expected");
            message.gatekeeper = $root.pruntime_rpc.GatekeeperStatus.fromObject(object.gatekeeper);
          }
          if (object.numberOfClusters != null) {
            if ($util.Long)
              (message.numberOfClusters = $util.Long.fromValue(object.numberOfClusters)).unsigned = true;
            else if (typeof object.numberOfClusters === "string")
              message.numberOfClusters = parseInt(object.numberOfClusters, 10);
            else if (typeof object.numberOfClusters === "number")
              message.numberOfClusters = object.numberOfClusters;
            else if (typeof object.numberOfClusters === "object")
              message.numberOfClusters = new $util.LongBits(object.numberOfClusters.low >>> 0, object.numberOfClusters.high >>> 0).toNumber(true);
          }
          if (object.numberOfContracts != null) {
            if ($util.Long)
              (message.numberOfContracts = $util.Long.fromValue(object.numberOfContracts)).unsigned = true;
            else if (typeof object.numberOfContracts === "string")
              message.numberOfContracts = parseInt(object.numberOfContracts, 10);
            else if (typeof object.numberOfContracts === "number")
              message.numberOfContracts = object.numberOfContracts;
            else if (typeof object.numberOfContracts === "object")
              message.numberOfContracts = new $util.LongBits(object.numberOfContracts.low >>> 0, object.numberOfContracts.high >>> 0).toNumber(true);
          }
          if (object.maxSupportedConsensusVersion != null)
            message.maxSupportedConsensusVersion = object.maxSupportedConsensusVersion >>> 0;
          if (object.genesisBlock != null)
            message.genesisBlock = object.genesisBlock >>> 0;
          return message;
        };
        SystemInfo.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.registered = false;
            object.publicKey = "";
            object.ecdhPublicKey = "";
            object.gatekeeper = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.numberOfClusters = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.numberOfClusters = options2.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.numberOfContracts = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.numberOfContracts = options2.longs === String ? "0" : 0;
            object.maxSupportedConsensusVersion = 0;
            object.genesisBlock = 0;
          }
          if (message.registered != null && message.hasOwnProperty("registered"))
            object.registered = message.registered;
          if (message.publicKey != null && message.hasOwnProperty("publicKey"))
            object.publicKey = message.publicKey;
          if (message.ecdhPublicKey != null && message.hasOwnProperty("ecdhPublicKey"))
            object.ecdhPublicKey = message.ecdhPublicKey;
          if (message.gatekeeper != null && message.hasOwnProperty("gatekeeper"))
            object.gatekeeper = $root.pruntime_rpc.GatekeeperStatus.toObject(message.gatekeeper, options2);
          if (message.numberOfClusters != null && message.hasOwnProperty("numberOfClusters"))
            if (typeof message.numberOfClusters === "number")
              object.numberOfClusters = options2.longs === String ? String(message.numberOfClusters) : message.numberOfClusters;
            else
              object.numberOfClusters = options2.longs === String ? $util.Long.prototype.toString.call(message.numberOfClusters) : options2.longs === Number ? new $util.LongBits(message.numberOfClusters.low >>> 0, message.numberOfClusters.high >>> 0).toNumber(true) : message.numberOfClusters;
          if (message.numberOfContracts != null && message.hasOwnProperty("numberOfContracts"))
            if (typeof message.numberOfContracts === "number")
              object.numberOfContracts = options2.longs === String ? String(message.numberOfContracts) : message.numberOfContracts;
            else
              object.numberOfContracts = options2.longs === String ? $util.Long.prototype.toString.call(message.numberOfContracts) : options2.longs === Number ? new $util.LongBits(message.numberOfContracts.low >>> 0, message.numberOfContracts.high >>> 0).toNumber(true) : message.numberOfContracts;
          if (message.maxSupportedConsensusVersion != null && message.hasOwnProperty("maxSupportedConsensusVersion"))
            object.maxSupportedConsensusVersion = message.maxSupportedConsensusVersion;
          if (message.genesisBlock != null && message.hasOwnProperty("genesisBlock"))
            object.genesisBlock = message.genesisBlock;
          return object;
        };
        SystemInfo.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        SystemInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.SystemInfo";
        };
        return SystemInfo;
      }();
      pruntime_rpc2.GatekeeperRole = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "None"] = 0;
        values[valuesById[1] = "Dummy"] = 1;
        values[valuesById[2] = "Active"] = 2;
        return values;
      }();
      pruntime_rpc2.GatekeeperStatus = function() {
        function GatekeeperStatus(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        GatekeeperStatus.prototype.role = 0;
        GatekeeperStatus.prototype.masterPublicKey = "";
        GatekeeperStatus.create = function create(properties) {
          return new GatekeeperStatus(properties);
        };
        GatekeeperStatus.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.role != null && Object.hasOwnProperty.call(message, "role"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.role);
          if (message.masterPublicKey != null && Object.hasOwnProperty.call(message, "masterPublicKey"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.masterPublicKey);
          return writer;
        };
        GatekeeperStatus.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        GatekeeperStatus.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.GatekeeperStatus();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.role = reader.int32();
                break;
              }
              case 2: {
                message.masterPublicKey = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        GatekeeperStatus.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        GatekeeperStatus.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.role != null && message.hasOwnProperty("role"))
            switch (message.role) {
              default:
                return "role: enum value expected";
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey")) {
            if (!$util.isString(message.masterPublicKey))
              return "masterPublicKey: string expected";
          }
          return null;
        };
        GatekeeperStatus.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.GatekeeperStatus)
            return object;
          var message = new $root.pruntime_rpc.GatekeeperStatus();
          switch (object.role) {
            default:
              if (typeof object.role === "number") {
                message.role = object.role;
                break;
              }
              break;
            case "None":
            case 0:
              message.role = 0;
              break;
            case "Dummy":
            case 1:
              message.role = 1;
              break;
            case "Active":
            case 2:
              message.role = 2;
              break;
          }
          if (object.masterPublicKey != null)
            message.masterPublicKey = String(object.masterPublicKey);
          return message;
        };
        GatekeeperStatus.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.role = options2.enums === String ? "None" : 0;
            object.masterPublicKey = "";
          }
          if (message.role != null && message.hasOwnProperty("role"))
            object.role = options2.enums === String ? $root.pruntime_rpc.GatekeeperRole[message.role] === void 0 ? message.role : $root.pruntime_rpc.GatekeeperRole[message.role] : message.role;
          if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
            object.masterPublicKey = message.masterPublicKey;
          return object;
        };
        GatekeeperStatus.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        GatekeeperStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.GatekeeperStatus";
        };
        return GatekeeperStatus;
      }();
      pruntime_rpc2.MemoryUsage = function() {
        function MemoryUsage(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        MemoryUsage.prototype.rustUsed = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        MemoryUsage.prototype.rustPeakUsed = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        MemoryUsage.prototype.totalPeakUsed = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        MemoryUsage.prototype.free = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        MemoryUsage.prototype.rustSpike = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        MemoryUsage.create = function create(properties) {
          return new MemoryUsage(properties);
        };
        MemoryUsage.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.rustUsed != null && Object.hasOwnProperty.call(message, "rustUsed"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).uint64(message.rustUsed);
          if (message.rustPeakUsed != null && Object.hasOwnProperty.call(message, "rustPeakUsed"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint64(message.rustPeakUsed);
          if (message.totalPeakUsed != null && Object.hasOwnProperty.call(message, "totalPeakUsed"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint64(message.totalPeakUsed);
          if (message.free != null && Object.hasOwnProperty.call(message, "free"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).uint64(message.free);
          if (message.rustSpike != null && Object.hasOwnProperty.call(message, "rustSpike"))
            writer.uint32(
              /* id 5, wireType 0 =*/
              40
            ).uint64(message.rustSpike);
          return writer;
        };
        MemoryUsage.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        MemoryUsage.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.MemoryUsage();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.rustUsed = reader.uint64();
                break;
              }
              case 2: {
                message.rustPeakUsed = reader.uint64();
                break;
              }
              case 3: {
                message.totalPeakUsed = reader.uint64();
                break;
              }
              case 4: {
                message.free = reader.uint64();
                break;
              }
              case 5: {
                message.rustSpike = reader.uint64();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        MemoryUsage.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        MemoryUsage.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.rustUsed != null && message.hasOwnProperty("rustUsed")) {
            if (!$util.isInteger(message.rustUsed) && !(message.rustUsed && $util.isInteger(message.rustUsed.low) && $util.isInteger(message.rustUsed.high)))
              return "rustUsed: integer|Long expected";
          }
          if (message.rustPeakUsed != null && message.hasOwnProperty("rustPeakUsed")) {
            if (!$util.isInteger(message.rustPeakUsed) && !(message.rustPeakUsed && $util.isInteger(message.rustPeakUsed.low) && $util.isInteger(message.rustPeakUsed.high)))
              return "rustPeakUsed: integer|Long expected";
          }
          if (message.totalPeakUsed != null && message.hasOwnProperty("totalPeakUsed")) {
            if (!$util.isInteger(message.totalPeakUsed) && !(message.totalPeakUsed && $util.isInteger(message.totalPeakUsed.low) && $util.isInteger(message.totalPeakUsed.high)))
              return "totalPeakUsed: integer|Long expected";
          }
          if (message.free != null && message.hasOwnProperty("free")) {
            if (!$util.isInteger(message.free) && !(message.free && $util.isInteger(message.free.low) && $util.isInteger(message.free.high)))
              return "free: integer|Long expected";
          }
          if (message.rustSpike != null && message.hasOwnProperty("rustSpike")) {
            if (!$util.isInteger(message.rustSpike) && !(message.rustSpike && $util.isInteger(message.rustSpike.low) && $util.isInteger(message.rustSpike.high)))
              return "rustSpike: integer|Long expected";
          }
          return null;
        };
        MemoryUsage.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.MemoryUsage)
            return object;
          var message = new $root.pruntime_rpc.MemoryUsage();
          if (object.rustUsed != null) {
            if ($util.Long)
              (message.rustUsed = $util.Long.fromValue(object.rustUsed)).unsigned = true;
            else if (typeof object.rustUsed === "string")
              message.rustUsed = parseInt(object.rustUsed, 10);
            else if (typeof object.rustUsed === "number")
              message.rustUsed = object.rustUsed;
            else if (typeof object.rustUsed === "object")
              message.rustUsed = new $util.LongBits(object.rustUsed.low >>> 0, object.rustUsed.high >>> 0).toNumber(true);
          }
          if (object.rustPeakUsed != null) {
            if ($util.Long)
              (message.rustPeakUsed = $util.Long.fromValue(object.rustPeakUsed)).unsigned = true;
            else if (typeof object.rustPeakUsed === "string")
              message.rustPeakUsed = parseInt(object.rustPeakUsed, 10);
            else if (typeof object.rustPeakUsed === "number")
              message.rustPeakUsed = object.rustPeakUsed;
            else if (typeof object.rustPeakUsed === "object")
              message.rustPeakUsed = new $util.LongBits(object.rustPeakUsed.low >>> 0, object.rustPeakUsed.high >>> 0).toNumber(true);
          }
          if (object.totalPeakUsed != null) {
            if ($util.Long)
              (message.totalPeakUsed = $util.Long.fromValue(object.totalPeakUsed)).unsigned = true;
            else if (typeof object.totalPeakUsed === "string")
              message.totalPeakUsed = parseInt(object.totalPeakUsed, 10);
            else if (typeof object.totalPeakUsed === "number")
              message.totalPeakUsed = object.totalPeakUsed;
            else if (typeof object.totalPeakUsed === "object")
              message.totalPeakUsed = new $util.LongBits(object.totalPeakUsed.low >>> 0, object.totalPeakUsed.high >>> 0).toNumber(true);
          }
          if (object.free != null) {
            if ($util.Long)
              (message.free = $util.Long.fromValue(object.free)).unsigned = true;
            else if (typeof object.free === "string")
              message.free = parseInt(object.free, 10);
            else if (typeof object.free === "number")
              message.free = object.free;
            else if (typeof object.free === "object")
              message.free = new $util.LongBits(object.free.low >>> 0, object.free.high >>> 0).toNumber(true);
          }
          if (object.rustSpike != null) {
            if ($util.Long)
              (message.rustSpike = $util.Long.fromValue(object.rustSpike)).unsigned = true;
            else if (typeof object.rustSpike === "string")
              message.rustSpike = parseInt(object.rustSpike, 10);
            else if (typeof object.rustSpike === "number")
              message.rustSpike = object.rustSpike;
            else if (typeof object.rustSpike === "object")
              message.rustSpike = new $util.LongBits(object.rustSpike.low >>> 0, object.rustSpike.high >>> 0).toNumber(true);
          }
          return message;
        };
        MemoryUsage.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.rustUsed = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.rustUsed = options2.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.rustPeakUsed = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.rustPeakUsed = options2.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.totalPeakUsed = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.totalPeakUsed = options2.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.free = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.free = options2.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.rustSpike = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.rustSpike = options2.longs === String ? "0" : 0;
          }
          if (message.rustUsed != null && message.hasOwnProperty("rustUsed"))
            if (typeof message.rustUsed === "number")
              object.rustUsed = options2.longs === String ? String(message.rustUsed) : message.rustUsed;
            else
              object.rustUsed = options2.longs === String ? $util.Long.prototype.toString.call(message.rustUsed) : options2.longs === Number ? new $util.LongBits(message.rustUsed.low >>> 0, message.rustUsed.high >>> 0).toNumber(true) : message.rustUsed;
          if (message.rustPeakUsed != null && message.hasOwnProperty("rustPeakUsed"))
            if (typeof message.rustPeakUsed === "number")
              object.rustPeakUsed = options2.longs === String ? String(message.rustPeakUsed) : message.rustPeakUsed;
            else
              object.rustPeakUsed = options2.longs === String ? $util.Long.prototype.toString.call(message.rustPeakUsed) : options2.longs === Number ? new $util.LongBits(message.rustPeakUsed.low >>> 0, message.rustPeakUsed.high >>> 0).toNumber(true) : message.rustPeakUsed;
          if (message.totalPeakUsed != null && message.hasOwnProperty("totalPeakUsed"))
            if (typeof message.totalPeakUsed === "number")
              object.totalPeakUsed = options2.longs === String ? String(message.totalPeakUsed) : message.totalPeakUsed;
            else
              object.totalPeakUsed = options2.longs === String ? $util.Long.prototype.toString.call(message.totalPeakUsed) : options2.longs === Number ? new $util.LongBits(message.totalPeakUsed.low >>> 0, message.totalPeakUsed.high >>> 0).toNumber(true) : message.totalPeakUsed;
          if (message.free != null && message.hasOwnProperty("free"))
            if (typeof message.free === "number")
              object.free = options2.longs === String ? String(message.free) : message.free;
            else
              object.free = options2.longs === String ? $util.Long.prototype.toString.call(message.free) : options2.longs === Number ? new $util.LongBits(message.free.low >>> 0, message.free.high >>> 0).toNumber(true) : message.free;
          if (message.rustSpike != null && message.hasOwnProperty("rustSpike"))
            if (typeof message.rustSpike === "number")
              object.rustSpike = options2.longs === String ? String(message.rustSpike) : message.rustSpike;
            else
              object.rustSpike = options2.longs === String ? $util.Long.prototype.toString.call(message.rustSpike) : options2.longs === Number ? new $util.LongBits(message.rustSpike.low >>> 0, message.rustSpike.high >>> 0).toNumber(true) : message.rustSpike;
          return object;
        };
        MemoryUsage.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        MemoryUsage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.MemoryUsage";
        };
        return MemoryUsage;
      }();
      pruntime_rpc2.GetRuntimeInfoRequest = function() {
        function GetRuntimeInfoRequest(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        GetRuntimeInfoRequest.prototype.forceRefreshRa = false;
        GetRuntimeInfoRequest.prototype.encodedOperator = null;
        var $oneOfFields;
        Object.defineProperty(GetRuntimeInfoRequest.prototype, "_encodedOperator", {
          get: $util.oneOfGetter($oneOfFields = ["encodedOperator"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        GetRuntimeInfoRequest.create = function create(properties) {
          return new GetRuntimeInfoRequest(properties);
        };
        GetRuntimeInfoRequest.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.forceRefreshRa != null && Object.hasOwnProperty.call(message, "forceRefreshRa"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).bool(message.forceRefreshRa);
          if (message.encodedOperator != null && Object.hasOwnProperty.call(message, "encodedOperator"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.encodedOperator);
          return writer;
        };
        GetRuntimeInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        GetRuntimeInfoRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.GetRuntimeInfoRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.forceRefreshRa = reader.bool();
                break;
              }
              case 2: {
                message.encodedOperator = reader.bytes();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        GetRuntimeInfoRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        GetRuntimeInfoRequest.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.forceRefreshRa != null && message.hasOwnProperty("forceRefreshRa")) {
            if (typeof message.forceRefreshRa !== "boolean")
              return "forceRefreshRa: boolean expected";
          }
          if (message.encodedOperator != null && message.hasOwnProperty("encodedOperator")) {
            properties._encodedOperator = 1;
            if (!(message.encodedOperator && typeof message.encodedOperator.length === "number" || $util.isString(message.encodedOperator)))
              return "encodedOperator: buffer expected";
          }
          return null;
        };
        GetRuntimeInfoRequest.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.GetRuntimeInfoRequest)
            return object;
          var message = new $root.pruntime_rpc.GetRuntimeInfoRequest();
          if (object.forceRefreshRa != null)
            message.forceRefreshRa = Boolean(object.forceRefreshRa);
          if (object.encodedOperator != null) {
            if (typeof object.encodedOperator === "string")
              $util.base64.decode(object.encodedOperator, message.encodedOperator = $util.newBuffer($util.base64.length(object.encodedOperator)), 0);
            else if (object.encodedOperator.length >= 0)
              message.encodedOperator = object.encodedOperator;
          }
          return message;
        };
        GetRuntimeInfoRequest.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults)
            object.forceRefreshRa = false;
          if (message.forceRefreshRa != null && message.hasOwnProperty("forceRefreshRa"))
            object.forceRefreshRa = message.forceRefreshRa;
          if (message.encodedOperator != null && message.hasOwnProperty("encodedOperator")) {
            object.encodedOperator = options2.bytes === String ? $util.base64.encode(message.encodedOperator, 0, message.encodedOperator.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedOperator) : message.encodedOperator;
            if (options2.oneofs)
              object._encodedOperator = "encodedOperator";
          }
          return object;
        };
        GetRuntimeInfoRequest.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        GetRuntimeInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.GetRuntimeInfoRequest";
        };
        return GetRuntimeInfoRequest;
      }();
      pruntime_rpc2.InitRuntimeResponse = function() {
        function InitRuntimeResponse(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        InitRuntimeResponse.prototype.encodedRuntimeInfo = $util.newBuffer([]);
        InitRuntimeResponse.prototype.encodedGenesisBlockHash = $util.newBuffer([]);
        InitRuntimeResponse.prototype.encodedPublicKey = $util.newBuffer([]);
        InitRuntimeResponse.prototype.encodedEcdhPublicKey = $util.newBuffer([]);
        InitRuntimeResponse.prototype.attestation = null;
        var $oneOfFields;
        Object.defineProperty(InitRuntimeResponse.prototype, "_attestation", {
          get: $util.oneOfGetter($oneOfFields = ["attestation"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        InitRuntimeResponse.create = function create(properties) {
          return new InitRuntimeResponse(properties);
        };
        InitRuntimeResponse.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.encodedRuntimeInfo != null && Object.hasOwnProperty.call(message, "encodedRuntimeInfo"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.encodedRuntimeInfo);
          if (message.encodedGenesisBlockHash != null && Object.hasOwnProperty.call(message, "encodedGenesisBlockHash"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.encodedGenesisBlockHash);
          if (message.encodedPublicKey != null && Object.hasOwnProperty.call(message, "encodedPublicKey"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).bytes(message.encodedPublicKey);
          if (message.encodedEcdhPublicKey != null && Object.hasOwnProperty.call(message, "encodedEcdhPublicKey"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).bytes(message.encodedEcdhPublicKey);
          if (message.attestation != null && Object.hasOwnProperty.call(message, "attestation"))
            $root.pruntime_rpc.Attestation.encode(message.attestation, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          return writer;
        };
        InitRuntimeResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        InitRuntimeResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.InitRuntimeResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.encodedRuntimeInfo = reader.bytes();
                break;
              }
              case 2: {
                message.encodedGenesisBlockHash = reader.bytes();
                break;
              }
              case 3: {
                message.encodedPublicKey = reader.bytes();
                break;
              }
              case 4: {
                message.encodedEcdhPublicKey = reader.bytes();
                break;
              }
              case 5: {
                message.attestation = $root.pruntime_rpc.Attestation.decode(reader, reader.uint32());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        InitRuntimeResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        InitRuntimeResponse.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.encodedRuntimeInfo != null && message.hasOwnProperty("encodedRuntimeInfo")) {
            if (!(message.encodedRuntimeInfo && typeof message.encodedRuntimeInfo.length === "number" || $util.isString(message.encodedRuntimeInfo)))
              return "encodedRuntimeInfo: buffer expected";
          }
          if (message.encodedGenesisBlockHash != null && message.hasOwnProperty("encodedGenesisBlockHash")) {
            if (!(message.encodedGenesisBlockHash && typeof message.encodedGenesisBlockHash.length === "number" || $util.isString(message.encodedGenesisBlockHash)))
              return "encodedGenesisBlockHash: buffer expected";
          }
          if (message.encodedPublicKey != null && message.hasOwnProperty("encodedPublicKey")) {
            if (!(message.encodedPublicKey && typeof message.encodedPublicKey.length === "number" || $util.isString(message.encodedPublicKey)))
              return "encodedPublicKey: buffer expected";
          }
          if (message.encodedEcdhPublicKey != null && message.hasOwnProperty("encodedEcdhPublicKey")) {
            if (!(message.encodedEcdhPublicKey && typeof message.encodedEcdhPublicKey.length === "number" || $util.isString(message.encodedEcdhPublicKey)))
              return "encodedEcdhPublicKey: buffer expected";
          }
          if (message.attestation != null && message.hasOwnProperty("attestation")) {
            properties._attestation = 1;
            {
              var error = $root.pruntime_rpc.Attestation.verify(message.attestation);
              if (error)
                return "attestation." + error;
            }
          }
          return null;
        };
        InitRuntimeResponse.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.InitRuntimeResponse)
            return object;
          var message = new $root.pruntime_rpc.InitRuntimeResponse();
          if (object.encodedRuntimeInfo != null) {
            if (typeof object.encodedRuntimeInfo === "string")
              $util.base64.decode(object.encodedRuntimeInfo, message.encodedRuntimeInfo = $util.newBuffer($util.base64.length(object.encodedRuntimeInfo)), 0);
            else if (object.encodedRuntimeInfo.length >= 0)
              message.encodedRuntimeInfo = object.encodedRuntimeInfo;
          }
          if (object.encodedGenesisBlockHash != null) {
            if (typeof object.encodedGenesisBlockHash === "string")
              $util.base64.decode(object.encodedGenesisBlockHash, message.encodedGenesisBlockHash = $util.newBuffer($util.base64.length(object.encodedGenesisBlockHash)), 0);
            else if (object.encodedGenesisBlockHash.length >= 0)
              message.encodedGenesisBlockHash = object.encodedGenesisBlockHash;
          }
          if (object.encodedPublicKey != null) {
            if (typeof object.encodedPublicKey === "string")
              $util.base64.decode(object.encodedPublicKey, message.encodedPublicKey = $util.newBuffer($util.base64.length(object.encodedPublicKey)), 0);
            else if (object.encodedPublicKey.length >= 0)
              message.encodedPublicKey = object.encodedPublicKey;
          }
          if (object.encodedEcdhPublicKey != null) {
            if (typeof object.encodedEcdhPublicKey === "string")
              $util.base64.decode(object.encodedEcdhPublicKey, message.encodedEcdhPublicKey = $util.newBuffer($util.base64.length(object.encodedEcdhPublicKey)), 0);
            else if (object.encodedEcdhPublicKey.length >= 0)
              message.encodedEcdhPublicKey = object.encodedEcdhPublicKey;
          }
          if (object.attestation != null) {
            if (typeof object.attestation !== "object")
              throw TypeError(".pruntime_rpc.InitRuntimeResponse.attestation: object expected");
            message.attestation = $root.pruntime_rpc.Attestation.fromObject(object.attestation);
          }
          return message;
        };
        InitRuntimeResponse.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            if (options2.bytes === String)
              object.encodedRuntimeInfo = "";
            else {
              object.encodedRuntimeInfo = [];
              if (options2.bytes !== Array)
                object.encodedRuntimeInfo = $util.newBuffer(object.encodedRuntimeInfo);
            }
            if (options2.bytes === String)
              object.encodedGenesisBlockHash = "";
            else {
              object.encodedGenesisBlockHash = [];
              if (options2.bytes !== Array)
                object.encodedGenesisBlockHash = $util.newBuffer(object.encodedGenesisBlockHash);
            }
            if (options2.bytes === String)
              object.encodedPublicKey = "";
            else {
              object.encodedPublicKey = [];
              if (options2.bytes !== Array)
                object.encodedPublicKey = $util.newBuffer(object.encodedPublicKey);
            }
            if (options2.bytes === String)
              object.encodedEcdhPublicKey = "";
            else {
              object.encodedEcdhPublicKey = [];
              if (options2.bytes !== Array)
                object.encodedEcdhPublicKey = $util.newBuffer(object.encodedEcdhPublicKey);
            }
          }
          if (message.encodedRuntimeInfo != null && message.hasOwnProperty("encodedRuntimeInfo"))
            object.encodedRuntimeInfo = options2.bytes === String ? $util.base64.encode(message.encodedRuntimeInfo, 0, message.encodedRuntimeInfo.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedRuntimeInfo) : message.encodedRuntimeInfo;
          if (message.encodedGenesisBlockHash != null && message.hasOwnProperty("encodedGenesisBlockHash"))
            object.encodedGenesisBlockHash = options2.bytes === String ? $util.base64.encode(message.encodedGenesisBlockHash, 0, message.encodedGenesisBlockHash.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedGenesisBlockHash) : message.encodedGenesisBlockHash;
          if (message.encodedPublicKey != null && message.hasOwnProperty("encodedPublicKey"))
            object.encodedPublicKey = options2.bytes === String ? $util.base64.encode(message.encodedPublicKey, 0, message.encodedPublicKey.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedPublicKey) : message.encodedPublicKey;
          if (message.encodedEcdhPublicKey != null && message.hasOwnProperty("encodedEcdhPublicKey"))
            object.encodedEcdhPublicKey = options2.bytes === String ? $util.base64.encode(message.encodedEcdhPublicKey, 0, message.encodedEcdhPublicKey.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedEcdhPublicKey) : message.encodedEcdhPublicKey;
          if (message.attestation != null && message.hasOwnProperty("attestation")) {
            object.attestation = $root.pruntime_rpc.Attestation.toObject(message.attestation, options2);
            if (options2.oneofs)
              object._attestation = "attestation";
          }
          return object;
        };
        InitRuntimeResponse.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        InitRuntimeResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.InitRuntimeResponse";
        };
        return InitRuntimeResponse;
      }();
      pruntime_rpc2.Attestation = function() {
        function Attestation(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        Attestation.prototype.version = 0;
        Attestation.prototype.provider = "";
        Attestation.prototype.payload = null;
        Attestation.prototype.encodedReport = $util.newBuffer([]);
        Attestation.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        Attestation.create = function create(properties) {
          return new Attestation(properties);
        };
        Attestation.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.version);
          if (message.provider != null && Object.hasOwnProperty.call(message, "provider"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.provider);
          if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
            $root.pruntime_rpc.AttestationReport.encode(message.payload, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).uint64(message.timestamp);
          if (message.encodedReport != null && Object.hasOwnProperty.call(message, "encodedReport"))
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).bytes(message.encodedReport);
          return writer;
        };
        Attestation.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Attestation.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.Attestation();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.version = reader.int32();
                break;
              }
              case 2: {
                message.provider = reader.string();
                break;
              }
              case 3: {
                message.payload = $root.pruntime_rpc.AttestationReport.decode(reader, reader.uint32());
                break;
              }
              case 5: {
                message.encodedReport = reader.bytes();
                break;
              }
              case 4: {
                message.timestamp = reader.uint64();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Attestation.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Attestation.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.version != null && message.hasOwnProperty("version")) {
            if (!$util.isInteger(message.version))
              return "version: integer expected";
          }
          if (message.provider != null && message.hasOwnProperty("provider")) {
            if (!$util.isString(message.provider))
              return "provider: string expected";
          }
          if (message.payload != null && message.hasOwnProperty("payload")) {
            var error = $root.pruntime_rpc.AttestationReport.verify(message.payload);
            if (error)
              return "payload." + error;
          }
          if (message.encodedReport != null && message.hasOwnProperty("encodedReport")) {
            if (!(message.encodedReport && typeof message.encodedReport.length === "number" || $util.isString(message.encodedReport)))
              return "encodedReport: buffer expected";
          }
          if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
              return "timestamp: integer|Long expected";
          }
          return null;
        };
        Attestation.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.Attestation)
            return object;
          var message = new $root.pruntime_rpc.Attestation();
          if (object.version != null)
            message.version = object.version | 0;
          if (object.provider != null)
            message.provider = String(object.provider);
          if (object.payload != null) {
            if (typeof object.payload !== "object")
              throw TypeError(".pruntime_rpc.Attestation.payload: object expected");
            message.payload = $root.pruntime_rpc.AttestationReport.fromObject(object.payload);
          }
          if (object.encodedReport != null) {
            if (typeof object.encodedReport === "string")
              $util.base64.decode(object.encodedReport, message.encodedReport = $util.newBuffer($util.base64.length(object.encodedReport)), 0);
            else if (object.encodedReport.length >= 0)
              message.encodedReport = object.encodedReport;
          }
          if (object.timestamp != null) {
            if ($util.Long)
              (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
            else if (typeof object.timestamp === "string")
              message.timestamp = parseInt(object.timestamp, 10);
            else if (typeof object.timestamp === "number")
              message.timestamp = object.timestamp;
            else if (typeof object.timestamp === "object")
              message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
          }
          return message;
        };
        Attestation.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.version = 0;
            object.provider = "";
            object.payload = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.timestamp = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.timestamp = options2.longs === String ? "0" : 0;
            if (options2.bytes === String)
              object.encodedReport = "";
            else {
              object.encodedReport = [];
              if (options2.bytes !== Array)
                object.encodedReport = $util.newBuffer(object.encodedReport);
            }
          }
          if (message.version != null && message.hasOwnProperty("version"))
            object.version = message.version;
          if (message.provider != null && message.hasOwnProperty("provider"))
            object.provider = message.provider;
          if (message.payload != null && message.hasOwnProperty("payload"))
            object.payload = $root.pruntime_rpc.AttestationReport.toObject(message.payload, options2);
          if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (typeof message.timestamp === "number")
              object.timestamp = options2.longs === String ? String(message.timestamp) : message.timestamp;
            else
              object.timestamp = options2.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options2.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
          if (message.encodedReport != null && message.hasOwnProperty("encodedReport"))
            object.encodedReport = options2.bytes === String ? $util.base64.encode(message.encodedReport, 0, message.encodedReport.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedReport) : message.encodedReport;
          return object;
        };
        Attestation.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        Attestation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.Attestation";
        };
        return Attestation;
      }();
      pruntime_rpc2.AttestationReport = function() {
        function AttestationReport(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        AttestationReport.prototype.report = "";
        AttestationReport.prototype.signature = $util.newBuffer([]);
        AttestationReport.prototype.signingCert = $util.newBuffer([]);
        AttestationReport.create = function create(properties) {
          return new AttestationReport(properties);
        };
        AttestationReport.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.report != null && Object.hasOwnProperty.call(message, "report"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.report);
          if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.signature);
          if (message.signingCert != null && Object.hasOwnProperty.call(message, "signingCert"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).bytes(message.signingCert);
          return writer;
        };
        AttestationReport.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        AttestationReport.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.AttestationReport();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.report = reader.string();
                break;
              }
              case 2: {
                message.signature = reader.bytes();
                break;
              }
              case 3: {
                message.signingCert = reader.bytes();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        AttestationReport.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        AttestationReport.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.report != null && message.hasOwnProperty("report")) {
            if (!$util.isString(message.report))
              return "report: string expected";
          }
          if (message.signature != null && message.hasOwnProperty("signature")) {
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
              return "signature: buffer expected";
          }
          if (message.signingCert != null && message.hasOwnProperty("signingCert")) {
            if (!(message.signingCert && typeof message.signingCert.length === "number" || $util.isString(message.signingCert)))
              return "signingCert: buffer expected";
          }
          return null;
        };
        AttestationReport.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.AttestationReport)
            return object;
          var message = new $root.pruntime_rpc.AttestationReport();
          if (object.report != null)
            message.report = String(object.report);
          if (object.signature != null) {
            if (typeof object.signature === "string")
              $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length >= 0)
              message.signature = object.signature;
          }
          if (object.signingCert != null) {
            if (typeof object.signingCert === "string")
              $util.base64.decode(object.signingCert, message.signingCert = $util.newBuffer($util.base64.length(object.signingCert)), 0);
            else if (object.signingCert.length >= 0)
              message.signingCert = object.signingCert;
          }
          return message;
        };
        AttestationReport.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.report = "";
            if (options2.bytes === String)
              object.signature = "";
            else {
              object.signature = [];
              if (options2.bytes !== Array)
                object.signature = $util.newBuffer(object.signature);
            }
            if (options2.bytes === String)
              object.signingCert = "";
            else {
              object.signingCert = [];
              if (options2.bytes !== Array)
                object.signingCert = $util.newBuffer(object.signingCert);
            }
          }
          if (message.report != null && message.hasOwnProperty("report"))
            object.report = message.report;
          if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = options2.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options2.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
          if (message.signingCert != null && message.hasOwnProperty("signingCert"))
            object.signingCert = options2.bytes === String ? $util.base64.encode(message.signingCert, 0, message.signingCert.length) : options2.bytes === Array ? Array.prototype.slice.call(message.signingCert) : message.signingCert;
          return object;
        };
        AttestationReport.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        AttestationReport.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.AttestationReport";
        };
        return AttestationReport;
      }();
      pruntime_rpc2.ContractQueryRequest = function() {
        function ContractQueryRequest(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        ContractQueryRequest.prototype.encodedEncryptedData = $util.newBuffer([]);
        ContractQueryRequest.prototype.signature = null;
        ContractQueryRequest.create = function create(properties) {
          return new ContractQueryRequest(properties);
        };
        ContractQueryRequest.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.encodedEncryptedData != null && Object.hasOwnProperty.call(message, "encodedEncryptedData"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.encodedEncryptedData);
          if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            $root.pruntime_rpc.Signature.encode(message.signature, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          return writer;
        };
        ContractQueryRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ContractQueryRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.ContractQueryRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.encodedEncryptedData = reader.bytes();
                break;
              }
              case 2: {
                message.signature = $root.pruntime_rpc.Signature.decode(reader, reader.uint32());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ContractQueryRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ContractQueryRequest.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.encodedEncryptedData != null && message.hasOwnProperty("encodedEncryptedData")) {
            if (!(message.encodedEncryptedData && typeof message.encodedEncryptedData.length === "number" || $util.isString(message.encodedEncryptedData)))
              return "encodedEncryptedData: buffer expected";
          }
          if (message.signature != null && message.hasOwnProperty("signature")) {
            var error = $root.pruntime_rpc.Signature.verify(message.signature);
            if (error)
              return "signature." + error;
          }
          return null;
        };
        ContractQueryRequest.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.ContractQueryRequest)
            return object;
          var message = new $root.pruntime_rpc.ContractQueryRequest();
          if (object.encodedEncryptedData != null) {
            if (typeof object.encodedEncryptedData === "string")
              $util.base64.decode(object.encodedEncryptedData, message.encodedEncryptedData = $util.newBuffer($util.base64.length(object.encodedEncryptedData)), 0);
            else if (object.encodedEncryptedData.length >= 0)
              message.encodedEncryptedData = object.encodedEncryptedData;
          }
          if (object.signature != null) {
            if (typeof object.signature !== "object")
              throw TypeError(".pruntime_rpc.ContractQueryRequest.signature: object expected");
            message.signature = $root.pruntime_rpc.Signature.fromObject(object.signature);
          }
          return message;
        };
        ContractQueryRequest.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            if (options2.bytes === String)
              object.encodedEncryptedData = "";
            else {
              object.encodedEncryptedData = [];
              if (options2.bytes !== Array)
                object.encodedEncryptedData = $util.newBuffer(object.encodedEncryptedData);
            }
            object.signature = null;
          }
          if (message.encodedEncryptedData != null && message.hasOwnProperty("encodedEncryptedData"))
            object.encodedEncryptedData = options2.bytes === String ? $util.base64.encode(message.encodedEncryptedData, 0, message.encodedEncryptedData.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedEncryptedData) : message.encodedEncryptedData;
          if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = $root.pruntime_rpc.Signature.toObject(message.signature, options2);
          return object;
        };
        ContractQueryRequest.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ContractQueryRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.ContractQueryRequest";
        };
        return ContractQueryRequest;
      }();
      pruntime_rpc2.Signature = function() {
        function Signature(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        Signature.prototype.signedBy = null;
        Signature.prototype.signatureType = 0;
        Signature.prototype.signature = $util.newBuffer([]);
        Signature.create = function create(properties) {
          return new Signature(properties);
        };
        Signature.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.signedBy != null && Object.hasOwnProperty.call(message, "signedBy"))
            $root.pruntime_rpc.Certificate.encode(message.signedBy, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.signatureType != null && Object.hasOwnProperty.call(message, "signatureType"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int32(message.signatureType);
          if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).bytes(message.signature);
          return writer;
        };
        Signature.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Signature.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.Signature();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.signedBy = $root.pruntime_rpc.Certificate.decode(reader, reader.uint32());
                break;
              }
              case 2: {
                message.signatureType = reader.int32();
                break;
              }
              case 3: {
                message.signature = reader.bytes();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Signature.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Signature.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.signedBy != null && message.hasOwnProperty("signedBy")) {
            var error = $root.pruntime_rpc.Certificate.verify(message.signedBy);
            if (error)
              return "signedBy." + error;
          }
          if (message.signatureType != null && message.hasOwnProperty("signatureType"))
            switch (message.signatureType) {
              default:
                return "signatureType: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.signature != null && message.hasOwnProperty("signature")) {
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
              return "signature: buffer expected";
          }
          return null;
        };
        Signature.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.Signature)
            return object;
          var message = new $root.pruntime_rpc.Signature();
          if (object.signedBy != null) {
            if (typeof object.signedBy !== "object")
              throw TypeError(".pruntime_rpc.Signature.signedBy: object expected");
            message.signedBy = $root.pruntime_rpc.Certificate.fromObject(object.signedBy);
          }
          switch (object.signatureType) {
            default:
              if (typeof object.signatureType === "number") {
                message.signatureType = object.signatureType;
                break;
              }
              break;
            case "Ed25519":
            case 0:
              message.signatureType = 0;
              break;
            case "Sr25519":
            case 1:
              message.signatureType = 1;
              break;
            case "Ecdsa":
            case 2:
              message.signatureType = 2;
              break;
            case "Ed25519WrapBytes":
            case 3:
              message.signatureType = 3;
              break;
            case "Sr25519WrapBytes":
            case 4:
              message.signatureType = 4;
              break;
            case "EcdsaWrapBytes":
            case 5:
              message.signatureType = 5;
              break;
            case "Eip712":
            case 6:
              message.signatureType = 6;
              break;
          }
          if (object.signature != null) {
            if (typeof object.signature === "string")
              $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length >= 0)
              message.signature = object.signature;
          }
          return message;
        };
        Signature.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.signedBy = null;
            object.signatureType = options2.enums === String ? "Ed25519" : 0;
            if (options2.bytes === String)
              object.signature = "";
            else {
              object.signature = [];
              if (options2.bytes !== Array)
                object.signature = $util.newBuffer(object.signature);
            }
          }
          if (message.signedBy != null && message.hasOwnProperty("signedBy"))
            object.signedBy = $root.pruntime_rpc.Certificate.toObject(message.signedBy, options2);
          if (message.signatureType != null && message.hasOwnProperty("signatureType"))
            object.signatureType = options2.enums === String ? $root.pruntime_rpc.SignatureType[message.signatureType] === void 0 ? message.signatureType : $root.pruntime_rpc.SignatureType[message.signatureType] : message.signatureType;
          if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = options2.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options2.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
          return object;
        };
        Signature.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        Signature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.Signature";
        };
        return Signature;
      }();
      pruntime_rpc2.Certificate = function() {
        function Certificate(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        Certificate.prototype.encodedBody = $util.newBuffer([]);
        Certificate.prototype.signature = null;
        Certificate.create = function create(properties) {
          return new Certificate(properties);
        };
        Certificate.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.encodedBody != null && Object.hasOwnProperty.call(message, "encodedBody"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.encodedBody);
          if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            $root.pruntime_rpc.Signature.encode(message.signature, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          return writer;
        };
        Certificate.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Certificate.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.Certificate();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.encodedBody = reader.bytes();
                break;
              }
              case 2: {
                message.signature = $root.pruntime_rpc.Signature.decode(reader, reader.uint32());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Certificate.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Certificate.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.encodedBody != null && message.hasOwnProperty("encodedBody")) {
            if (!(message.encodedBody && typeof message.encodedBody.length === "number" || $util.isString(message.encodedBody)))
              return "encodedBody: buffer expected";
          }
          if (message.signature != null && message.hasOwnProperty("signature")) {
            var error = $root.pruntime_rpc.Signature.verify(message.signature);
            if (error)
              return "signature." + error;
          }
          return null;
        };
        Certificate.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.Certificate)
            return object;
          var message = new $root.pruntime_rpc.Certificate();
          if (object.encodedBody != null) {
            if (typeof object.encodedBody === "string")
              $util.base64.decode(object.encodedBody, message.encodedBody = $util.newBuffer($util.base64.length(object.encodedBody)), 0);
            else if (object.encodedBody.length >= 0)
              message.encodedBody = object.encodedBody;
          }
          if (object.signature != null) {
            if (typeof object.signature !== "object")
              throw TypeError(".pruntime_rpc.Certificate.signature: object expected");
            message.signature = $root.pruntime_rpc.Signature.fromObject(object.signature);
          }
          return message;
        };
        Certificate.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            if (options2.bytes === String)
              object.encodedBody = "";
            else {
              object.encodedBody = [];
              if (options2.bytes !== Array)
                object.encodedBody = $util.newBuffer(object.encodedBody);
            }
            object.signature = null;
          }
          if (message.encodedBody != null && message.hasOwnProperty("encodedBody"))
            object.encodedBody = options2.bytes === String ? $util.base64.encode(message.encodedBody, 0, message.encodedBody.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedBody) : message.encodedBody;
          if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = $root.pruntime_rpc.Signature.toObject(message.signature, options2);
          return object;
        };
        Certificate.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        Certificate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.Certificate";
        };
        return Certificate;
      }();
      pruntime_rpc2.SignatureType = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Ed25519"] = 0;
        values[valuesById[1] = "Sr25519"] = 1;
        values[valuesById[2] = "Ecdsa"] = 2;
        values[valuesById[3] = "Ed25519WrapBytes"] = 3;
        values[valuesById[4] = "Sr25519WrapBytes"] = 4;
        values[valuesById[5] = "EcdsaWrapBytes"] = 5;
        values[valuesById[6] = "Eip712"] = 6;
        return values;
      }();
      pruntime_rpc2.ContractQueryResponse = function() {
        function ContractQueryResponse(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        ContractQueryResponse.prototype.encodedEncryptedData = $util.newBuffer([]);
        ContractQueryResponse.create = function create(properties) {
          return new ContractQueryResponse(properties);
        };
        ContractQueryResponse.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.encodedEncryptedData != null && Object.hasOwnProperty.call(message, "encodedEncryptedData"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.encodedEncryptedData);
          return writer;
        };
        ContractQueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ContractQueryResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.ContractQueryResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.encodedEncryptedData = reader.bytes();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ContractQueryResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ContractQueryResponse.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.encodedEncryptedData != null && message.hasOwnProperty("encodedEncryptedData")) {
            if (!(message.encodedEncryptedData && typeof message.encodedEncryptedData.length === "number" || $util.isString(message.encodedEncryptedData)))
              return "encodedEncryptedData: buffer expected";
          }
          return null;
        };
        ContractQueryResponse.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.ContractQueryResponse)
            return object;
          var message = new $root.pruntime_rpc.ContractQueryResponse();
          if (object.encodedEncryptedData != null) {
            if (typeof object.encodedEncryptedData === "string")
              $util.base64.decode(object.encodedEncryptedData, message.encodedEncryptedData = $util.newBuffer($util.base64.length(object.encodedEncryptedData)), 0);
            else if (object.encodedEncryptedData.length >= 0)
              message.encodedEncryptedData = object.encodedEncryptedData;
          }
          return message;
        };
        ContractQueryResponse.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults)
            if (options2.bytes === String)
              object.encodedEncryptedData = "";
            else {
              object.encodedEncryptedData = [];
              if (options2.bytes !== Array)
                object.encodedEncryptedData = $util.newBuffer(object.encodedEncryptedData);
            }
          if (message.encodedEncryptedData != null && message.hasOwnProperty("encodedEncryptedData"))
            object.encodedEncryptedData = options2.bytes === String ? $util.base64.encode(message.encodedEncryptedData, 0, message.encodedEncryptedData.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedEncryptedData) : message.encodedEncryptedData;
          return object;
        };
        ContractQueryResponse.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ContractQueryResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.ContractQueryResponse";
        };
        return ContractQueryResponse;
      }();
      pruntime_rpc2.AddEndpointRequest = function() {
        function AddEndpointRequest(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        AddEndpointRequest.prototype.encodedEndpointType = $util.newBuffer([]);
        AddEndpointRequest.prototype.endpoint = "";
        AddEndpointRequest.create = function create(properties) {
          return new AddEndpointRequest(properties);
        };
        AddEndpointRequest.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.encodedEndpointType != null && Object.hasOwnProperty.call(message, "encodedEndpointType"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.encodedEndpointType);
          if (message.endpoint != null && Object.hasOwnProperty.call(message, "endpoint"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.endpoint);
          return writer;
        };
        AddEndpointRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        AddEndpointRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.AddEndpointRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.encodedEndpointType = reader.bytes();
                break;
              }
              case 2: {
                message.endpoint = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        AddEndpointRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        AddEndpointRequest.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.encodedEndpointType != null && message.hasOwnProperty("encodedEndpointType")) {
            if (!(message.encodedEndpointType && typeof message.encodedEndpointType.length === "number" || $util.isString(message.encodedEndpointType)))
              return "encodedEndpointType: buffer expected";
          }
          if (message.endpoint != null && message.hasOwnProperty("endpoint")) {
            if (!$util.isString(message.endpoint))
              return "endpoint: string expected";
          }
          return null;
        };
        AddEndpointRequest.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.AddEndpointRequest)
            return object;
          var message = new $root.pruntime_rpc.AddEndpointRequest();
          if (object.encodedEndpointType != null) {
            if (typeof object.encodedEndpointType === "string")
              $util.base64.decode(object.encodedEndpointType, message.encodedEndpointType = $util.newBuffer($util.base64.length(object.encodedEndpointType)), 0);
            else if (object.encodedEndpointType.length >= 0)
              message.encodedEndpointType = object.encodedEndpointType;
          }
          if (object.endpoint != null)
            message.endpoint = String(object.endpoint);
          return message;
        };
        AddEndpointRequest.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            if (options2.bytes === String)
              object.encodedEndpointType = "";
            else {
              object.encodedEndpointType = [];
              if (options2.bytes !== Array)
                object.encodedEndpointType = $util.newBuffer(object.encodedEndpointType);
            }
            object.endpoint = "";
          }
          if (message.encodedEndpointType != null && message.hasOwnProperty("encodedEndpointType"))
            object.encodedEndpointType = options2.bytes === String ? $util.base64.encode(message.encodedEndpointType, 0, message.encodedEndpointType.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedEndpointType) : message.encodedEndpointType;
          if (message.endpoint != null && message.hasOwnProperty("endpoint"))
            object.endpoint = message.endpoint;
          return object;
        };
        AddEndpointRequest.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        AddEndpointRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.AddEndpointRequest";
        };
        return AddEndpointRequest;
      }();
      pruntime_rpc2.GetEndpointResponse = function() {
        function GetEndpointResponse(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        GetEndpointResponse.prototype.encodedEndpointPayload = null;
        GetEndpointResponse.prototype.signature = null;
        var $oneOfFields;
        Object.defineProperty(GetEndpointResponse.prototype, "_encodedEndpointPayload", {
          get: $util.oneOfGetter($oneOfFields = ["encodedEndpointPayload"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        Object.defineProperty(GetEndpointResponse.prototype, "_signature", {
          get: $util.oneOfGetter($oneOfFields = ["signature"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        GetEndpointResponse.create = function create(properties) {
          return new GetEndpointResponse(properties);
        };
        GetEndpointResponse.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.encodedEndpointPayload != null && Object.hasOwnProperty.call(message, "encodedEndpointPayload"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.encodedEndpointPayload);
          if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.signature);
          return writer;
        };
        GetEndpointResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        GetEndpointResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.GetEndpointResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.encodedEndpointPayload = reader.bytes();
                break;
              }
              case 2: {
                message.signature = reader.bytes();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        GetEndpointResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        GetEndpointResponse.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.encodedEndpointPayload != null && message.hasOwnProperty("encodedEndpointPayload")) {
            properties._encodedEndpointPayload = 1;
            if (!(message.encodedEndpointPayload && typeof message.encodedEndpointPayload.length === "number" || $util.isString(message.encodedEndpointPayload)))
              return "encodedEndpointPayload: buffer expected";
          }
          if (message.signature != null && message.hasOwnProperty("signature")) {
            properties._signature = 1;
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
              return "signature: buffer expected";
          }
          return null;
        };
        GetEndpointResponse.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.GetEndpointResponse)
            return object;
          var message = new $root.pruntime_rpc.GetEndpointResponse();
          if (object.encodedEndpointPayload != null) {
            if (typeof object.encodedEndpointPayload === "string")
              $util.base64.decode(object.encodedEndpointPayload, message.encodedEndpointPayload = $util.newBuffer($util.base64.length(object.encodedEndpointPayload)), 0);
            else if (object.encodedEndpointPayload.length >= 0)
              message.encodedEndpointPayload = object.encodedEndpointPayload;
          }
          if (object.signature != null) {
            if (typeof object.signature === "string")
              $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length >= 0)
              message.signature = object.signature;
          }
          return message;
        };
        GetEndpointResponse.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (message.encodedEndpointPayload != null && message.hasOwnProperty("encodedEndpointPayload")) {
            object.encodedEndpointPayload = options2.bytes === String ? $util.base64.encode(message.encodedEndpointPayload, 0, message.encodedEndpointPayload.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedEndpointPayload) : message.encodedEndpointPayload;
            if (options2.oneofs)
              object._encodedEndpointPayload = "encodedEndpointPayload";
          }
          if (message.signature != null && message.hasOwnProperty("signature")) {
            object.signature = options2.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options2.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            if (options2.oneofs)
              object._signature = "signature";
          }
          return object;
        };
        GetEndpointResponse.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        GetEndpointResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.GetEndpointResponse";
        };
        return GetEndpointResponse;
      }();
      pruntime_rpc2.GetContractInfoRequest = function() {
        function GetContractInfoRequest(properties) {
          this.contracts = [];
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        GetContractInfoRequest.prototype.contracts = $util.emptyArray;
        GetContractInfoRequest.create = function create(properties) {
          return new GetContractInfoRequest(properties);
        };
        GetContractInfoRequest.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.contracts != null && message.contracts.length)
            for (var i = 0; i < message.contracts.length; ++i)
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.contracts[i]);
          return writer;
        };
        GetContractInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        GetContractInfoRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.GetContractInfoRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (!(message.contracts && message.contracts.length))
                  message.contracts = [];
                message.contracts.push(reader.string());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        GetContractInfoRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        GetContractInfoRequest.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.contracts != null && message.hasOwnProperty("contracts")) {
            if (!Array.isArray(message.contracts))
              return "contracts: array expected";
            for (var i = 0; i < message.contracts.length; ++i)
              if (!$util.isString(message.contracts[i]))
                return "contracts: string[] expected";
          }
          return null;
        };
        GetContractInfoRequest.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.GetContractInfoRequest)
            return object;
          var message = new $root.pruntime_rpc.GetContractInfoRequest();
          if (object.contracts) {
            if (!Array.isArray(object.contracts))
              throw TypeError(".pruntime_rpc.GetContractInfoRequest.contracts: array expected");
            message.contracts = [];
            for (var i = 0; i < object.contracts.length; ++i)
              message.contracts[i] = String(object.contracts[i]);
          }
          return message;
        };
        GetContractInfoRequest.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.arrays || options2.defaults)
            object.contracts = [];
          if (message.contracts && message.contracts.length) {
            object.contracts = [];
            for (var j = 0; j < message.contracts.length; ++j)
              object.contracts[j] = message.contracts[j];
          }
          return object;
        };
        GetContractInfoRequest.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        GetContractInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.GetContractInfoRequest";
        };
        return GetContractInfoRequest;
      }();
      pruntime_rpc2.GetContractInfoResponse = function() {
        function GetContractInfoResponse(properties) {
          this.contracts = [];
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        GetContractInfoResponse.prototype.contracts = $util.emptyArray;
        GetContractInfoResponse.create = function create(properties) {
          return new GetContractInfoResponse(properties);
        };
        GetContractInfoResponse.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.contracts != null && message.contracts.length)
            for (var i = 0; i < message.contracts.length; ++i)
              $root.pruntime_rpc.ContractInfo.encode(message.contracts[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
          return writer;
        };
        GetContractInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        GetContractInfoResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.GetContractInfoResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (!(message.contracts && message.contracts.length))
                  message.contracts = [];
                message.contracts.push($root.pruntime_rpc.ContractInfo.decode(reader, reader.uint32()));
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        GetContractInfoResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        GetContractInfoResponse.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.contracts != null && message.hasOwnProperty("contracts")) {
            if (!Array.isArray(message.contracts))
              return "contracts: array expected";
            for (var i = 0; i < message.contracts.length; ++i) {
              var error = $root.pruntime_rpc.ContractInfo.verify(message.contracts[i]);
              if (error)
                return "contracts." + error;
            }
          }
          return null;
        };
        GetContractInfoResponse.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.GetContractInfoResponse)
            return object;
          var message = new $root.pruntime_rpc.GetContractInfoResponse();
          if (object.contracts) {
            if (!Array.isArray(object.contracts))
              throw TypeError(".pruntime_rpc.GetContractInfoResponse.contracts: array expected");
            message.contracts = [];
            for (var i = 0; i < object.contracts.length; ++i) {
              if (typeof object.contracts[i] !== "object")
                throw TypeError(".pruntime_rpc.GetContractInfoResponse.contracts: object expected");
              message.contracts[i] = $root.pruntime_rpc.ContractInfo.fromObject(object.contracts[i]);
            }
          }
          return message;
        };
        GetContractInfoResponse.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.arrays || options2.defaults)
            object.contracts = [];
          if (message.contracts && message.contracts.length) {
            object.contracts = [];
            for (var j = 0; j < message.contracts.length; ++j)
              object.contracts[j] = $root.pruntime_rpc.ContractInfo.toObject(message.contracts[j], options2);
          }
          return object;
        };
        GetContractInfoResponse.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        GetContractInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.GetContractInfoResponse";
        };
        return GetContractInfoResponse;
      }();
      pruntime_rpc2.ContractInfo = function() {
        function ContractInfo(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        ContractInfo.prototype.id = "";
        ContractInfo.prototype.codeHash = "";
        ContractInfo.prototype.weight = 0;
        ContractInfo.prototype.sidevm = null;
        ContractInfo.create = function create(properties) {
          return new ContractInfo(properties);
        };
        ContractInfo.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.id);
          if (message.codeHash != null && Object.hasOwnProperty.call(message, "codeHash"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.codeHash);
          if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint32(message.weight);
          if (message.sidevm != null && Object.hasOwnProperty.call(message, "sidevm"))
            $root.pruntime_rpc.SidevmInfo.encode(message.sidevm, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          return writer;
        };
        ContractInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ContractInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.ContractInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.id = reader.string();
                break;
              }
              case 2: {
                message.codeHash = reader.string();
                break;
              }
              case 3: {
                message.weight = reader.uint32();
                break;
              }
              case 4: {
                message.sidevm = $root.pruntime_rpc.SidevmInfo.decode(reader, reader.uint32());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ContractInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ContractInfo.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.id != null && message.hasOwnProperty("id")) {
            if (!$util.isString(message.id))
              return "id: string expected";
          }
          if (message.codeHash != null && message.hasOwnProperty("codeHash")) {
            if (!$util.isString(message.codeHash))
              return "codeHash: string expected";
          }
          if (message.weight != null && message.hasOwnProperty("weight")) {
            if (!$util.isInteger(message.weight))
              return "weight: integer expected";
          }
          if (message.sidevm != null && message.hasOwnProperty("sidevm")) {
            var error = $root.pruntime_rpc.SidevmInfo.verify(message.sidevm);
            if (error)
              return "sidevm." + error;
          }
          return null;
        };
        ContractInfo.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.ContractInfo)
            return object;
          var message = new $root.pruntime_rpc.ContractInfo();
          if (object.id != null)
            message.id = String(object.id);
          if (object.codeHash != null)
            message.codeHash = String(object.codeHash);
          if (object.weight != null)
            message.weight = object.weight >>> 0;
          if (object.sidevm != null) {
            if (typeof object.sidevm !== "object")
              throw TypeError(".pruntime_rpc.ContractInfo.sidevm: object expected");
            message.sidevm = $root.pruntime_rpc.SidevmInfo.fromObject(object.sidevm);
          }
          return message;
        };
        ContractInfo.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.id = "";
            object.codeHash = "";
            object.weight = 0;
            object.sidevm = null;
          }
          if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
          if (message.codeHash != null && message.hasOwnProperty("codeHash"))
            object.codeHash = message.codeHash;
          if (message.weight != null && message.hasOwnProperty("weight"))
            object.weight = message.weight;
          if (message.sidevm != null && message.hasOwnProperty("sidevm"))
            object.sidevm = $root.pruntime_rpc.SidevmInfo.toObject(message.sidevm, options2);
          return object;
        };
        ContractInfo.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ContractInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.ContractInfo";
        };
        return ContractInfo;
      }();
      pruntime_rpc2.SidevmInfo = function() {
        function SidevmInfo(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        SidevmInfo.prototype.state = "";
        SidevmInfo.prototype.codeHash = "";
        SidevmInfo.prototype.startTime = "";
        SidevmInfo.prototype.stopReason = "";
        SidevmInfo.create = function create(properties) {
          return new SidevmInfo(properties);
        };
        SidevmInfo.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.state != null && Object.hasOwnProperty.call(message, "state"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.state);
          if (message.codeHash != null && Object.hasOwnProperty.call(message, "codeHash"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.codeHash);
          if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.startTime);
          if (message.stopReason != null && Object.hasOwnProperty.call(message, "stopReason"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.stopReason);
          return writer;
        };
        SidevmInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        SidevmInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.SidevmInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.state = reader.string();
                break;
              }
              case 2: {
                message.codeHash = reader.string();
                break;
              }
              case 3: {
                message.startTime = reader.string();
                break;
              }
              case 4: {
                message.stopReason = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        SidevmInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        SidevmInfo.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.state != null && message.hasOwnProperty("state")) {
            if (!$util.isString(message.state))
              return "state: string expected";
          }
          if (message.codeHash != null && message.hasOwnProperty("codeHash")) {
            if (!$util.isString(message.codeHash))
              return "codeHash: string expected";
          }
          if (message.startTime != null && message.hasOwnProperty("startTime")) {
            if (!$util.isString(message.startTime))
              return "startTime: string expected";
          }
          if (message.stopReason != null && message.hasOwnProperty("stopReason")) {
            if (!$util.isString(message.stopReason))
              return "stopReason: string expected";
          }
          return null;
        };
        SidevmInfo.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.SidevmInfo)
            return object;
          var message = new $root.pruntime_rpc.SidevmInfo();
          if (object.state != null)
            message.state = String(object.state);
          if (object.codeHash != null)
            message.codeHash = String(object.codeHash);
          if (object.startTime != null)
            message.startTime = String(object.startTime);
          if (object.stopReason != null)
            message.stopReason = String(object.stopReason);
          return message;
        };
        SidevmInfo.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.state = "";
            object.codeHash = "";
            object.startTime = "";
            object.stopReason = "";
          }
          if (message.state != null && message.hasOwnProperty("state"))
            object.state = message.state;
          if (message.codeHash != null && message.hasOwnProperty("codeHash"))
            object.codeHash = message.codeHash;
          if (message.startTime != null && message.hasOwnProperty("startTime"))
            object.startTime = message.startTime;
          if (message.stopReason != null && message.hasOwnProperty("stopReason"))
            object.stopReason = message.stopReason;
          return object;
        };
        SidevmInfo.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        SidevmInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.SidevmInfo";
        };
        return SidevmInfo;
      }();
      pruntime_rpc2.GetClusterInfoResponse = function() {
        function GetClusterInfoResponse(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        GetClusterInfoResponse.prototype.info = null;
        GetClusterInfoResponse.create = function create(properties) {
          return new GetClusterInfoResponse(properties);
        };
        GetClusterInfoResponse.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.info != null && Object.hasOwnProperty.call(message, "info"))
            $root.pruntime_rpc.ClusterInfo.encode(message.info, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          return writer;
        };
        GetClusterInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        GetClusterInfoResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.GetClusterInfoResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.info = $root.pruntime_rpc.ClusterInfo.decode(reader, reader.uint32());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        GetClusterInfoResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        GetClusterInfoResponse.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.info != null && message.hasOwnProperty("info")) {
            var error = $root.pruntime_rpc.ClusterInfo.verify(message.info);
            if (error)
              return "info." + error;
          }
          return null;
        };
        GetClusterInfoResponse.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.GetClusterInfoResponse)
            return object;
          var message = new $root.pruntime_rpc.GetClusterInfoResponse();
          if (object.info != null) {
            if (typeof object.info !== "object")
              throw TypeError(".pruntime_rpc.GetClusterInfoResponse.info: object expected");
            message.info = $root.pruntime_rpc.ClusterInfo.fromObject(object.info);
          }
          return message;
        };
        GetClusterInfoResponse.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults)
            object.info = null;
          if (message.info != null && message.hasOwnProperty("info"))
            object.info = $root.pruntime_rpc.ClusterInfo.toObject(message.info, options2);
          return object;
        };
        GetClusterInfoResponse.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        GetClusterInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.GetClusterInfoResponse";
        };
        return GetClusterInfoResponse;
      }();
      pruntime_rpc2.ClusterInfo = function() {
        function ClusterInfo(properties) {
          this.contracts = [];
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        ClusterInfo.prototype.id = "";
        ClusterInfo.prototype.runtimeVersion = "";
        ClusterInfo.prototype.stateRoot = "";
        ClusterInfo.prototype.contracts = $util.emptyArray;
        ClusterInfo.create = function create(properties) {
          return new ClusterInfo(properties);
        };
        ClusterInfo.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.id);
          if (message.runtimeVersion != null && Object.hasOwnProperty.call(message, "runtimeVersion"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.runtimeVersion);
          if (message.stateRoot != null && Object.hasOwnProperty.call(message, "stateRoot"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.stateRoot);
          if (message.contracts != null && message.contracts.length)
            for (var i = 0; i < message.contracts.length; ++i)
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).string(message.contracts[i]);
          return writer;
        };
        ClusterInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ClusterInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.ClusterInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.id = reader.string();
                break;
              }
              case 2: {
                message.runtimeVersion = reader.string();
                break;
              }
              case 3: {
                message.stateRoot = reader.string();
                break;
              }
              case 4: {
                if (!(message.contracts && message.contracts.length))
                  message.contracts = [];
                message.contracts.push(reader.string());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ClusterInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ClusterInfo.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.id != null && message.hasOwnProperty("id")) {
            if (!$util.isString(message.id))
              return "id: string expected";
          }
          if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion")) {
            if (!$util.isString(message.runtimeVersion))
              return "runtimeVersion: string expected";
          }
          if (message.stateRoot != null && message.hasOwnProperty("stateRoot")) {
            if (!$util.isString(message.stateRoot))
              return "stateRoot: string expected";
          }
          if (message.contracts != null && message.hasOwnProperty("contracts")) {
            if (!Array.isArray(message.contracts))
              return "contracts: array expected";
            for (var i = 0; i < message.contracts.length; ++i)
              if (!$util.isString(message.contracts[i]))
                return "contracts: string[] expected";
          }
          return null;
        };
        ClusterInfo.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.ClusterInfo)
            return object;
          var message = new $root.pruntime_rpc.ClusterInfo();
          if (object.id != null)
            message.id = String(object.id);
          if (object.runtimeVersion != null)
            message.runtimeVersion = String(object.runtimeVersion);
          if (object.stateRoot != null)
            message.stateRoot = String(object.stateRoot);
          if (object.contracts) {
            if (!Array.isArray(object.contracts))
              throw TypeError(".pruntime_rpc.ClusterInfo.contracts: array expected");
            message.contracts = [];
            for (var i = 0; i < object.contracts.length; ++i)
              message.contracts[i] = String(object.contracts[i]);
          }
          return message;
        };
        ClusterInfo.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.arrays || options2.defaults)
            object.contracts = [];
          if (options2.defaults) {
            object.id = "";
            object.runtimeVersion = "";
            object.stateRoot = "";
          }
          if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
          if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion"))
            object.runtimeVersion = message.runtimeVersion;
          if (message.stateRoot != null && message.hasOwnProperty("stateRoot"))
            object.stateRoot = message.stateRoot;
          if (message.contracts && message.contracts.length) {
            object.contracts = [];
            for (var j = 0; j < message.contracts.length; ++j)
              object.contracts[j] = message.contracts[j];
          }
          return object;
        };
        ClusterInfo.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ClusterInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.ClusterInfo";
        };
        return ClusterInfo;
      }();
      pruntime_rpc2.SidevmCode = function() {
        function SidevmCode(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        SidevmCode.prototype.contract = $util.newBuffer([]);
        SidevmCode.prototype.code = $util.newBuffer([]);
        SidevmCode.create = function create(properties) {
          return new SidevmCode(properties);
        };
        SidevmCode.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.contract != null && Object.hasOwnProperty.call(message, "contract"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.contract);
          if (message.code != null && Object.hasOwnProperty.call(message, "code"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.code);
          return writer;
        };
        SidevmCode.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        SidevmCode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.SidevmCode();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.contract = reader.bytes();
                break;
              }
              case 2: {
                message.code = reader.bytes();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        SidevmCode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        SidevmCode.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.contract != null && message.hasOwnProperty("contract")) {
            if (!(message.contract && typeof message.contract.length === "number" || $util.isString(message.contract)))
              return "contract: buffer expected";
          }
          if (message.code != null && message.hasOwnProperty("code")) {
            if (!(message.code && typeof message.code.length === "number" || $util.isString(message.code)))
              return "code: buffer expected";
          }
          return null;
        };
        SidevmCode.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.SidevmCode)
            return object;
          var message = new $root.pruntime_rpc.SidevmCode();
          if (object.contract != null) {
            if (typeof object.contract === "string")
              $util.base64.decode(object.contract, message.contract = $util.newBuffer($util.base64.length(object.contract)), 0);
            else if (object.contract.length >= 0)
              message.contract = object.contract;
          }
          if (object.code != null) {
            if (typeof object.code === "string")
              $util.base64.decode(object.code, message.code = $util.newBuffer($util.base64.length(object.code)), 0);
            else if (object.code.length >= 0)
              message.code = object.code;
          }
          return message;
        };
        SidevmCode.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            if (options2.bytes === String)
              object.contract = "";
            else {
              object.contract = [];
              if (options2.bytes !== Array)
                object.contract = $util.newBuffer(object.contract);
            }
            if (options2.bytes === String)
              object.code = "";
            else {
              object.code = [];
              if (options2.bytes !== Array)
                object.code = $util.newBuffer(object.code);
            }
          }
          if (message.contract != null && message.hasOwnProperty("contract"))
            object.contract = options2.bytes === String ? $util.base64.encode(message.contract, 0, message.contract.length) : options2.bytes === Array ? Array.prototype.slice.call(message.contract) : message.contract;
          if (message.code != null && message.hasOwnProperty("code"))
            object.code = options2.bytes === String ? $util.base64.encode(message.code, 0, message.code.length) : options2.bytes === Array ? Array.prototype.slice.call(message.code) : message.code;
          return object;
        };
        SidevmCode.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        SidevmCode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.SidevmCode";
        };
        return SidevmCode;
      }();
      pruntime_rpc2.ContractParameters = function() {
        function ContractParameters(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        ContractParameters.prototype.deployer = "";
        ContractParameters.prototype.clusterId = "";
        ContractParameters.prototype.codeHash = "";
        ContractParameters.prototype.salt = "";
        ContractParameters.create = function create(properties) {
          return new ContractParameters(properties);
        };
        ContractParameters.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.deployer != null && Object.hasOwnProperty.call(message, "deployer"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.deployer);
          if (message.clusterId != null && Object.hasOwnProperty.call(message, "clusterId"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.clusterId);
          if (message.codeHash != null && Object.hasOwnProperty.call(message, "codeHash"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.codeHash);
          if (message.salt != null && Object.hasOwnProperty.call(message, "salt"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.salt);
          return writer;
        };
        ContractParameters.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ContractParameters.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.ContractParameters();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.deployer = reader.string();
                break;
              }
              case 2: {
                message.clusterId = reader.string();
                break;
              }
              case 3: {
                message.codeHash = reader.string();
                break;
              }
              case 4: {
                message.salt = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ContractParameters.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ContractParameters.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.deployer != null && message.hasOwnProperty("deployer")) {
            if (!$util.isString(message.deployer))
              return "deployer: string expected";
          }
          if (message.clusterId != null && message.hasOwnProperty("clusterId")) {
            if (!$util.isString(message.clusterId))
              return "clusterId: string expected";
          }
          if (message.codeHash != null && message.hasOwnProperty("codeHash")) {
            if (!$util.isString(message.codeHash))
              return "codeHash: string expected";
          }
          if (message.salt != null && message.hasOwnProperty("salt")) {
            if (!$util.isString(message.salt))
              return "salt: string expected";
          }
          return null;
        };
        ContractParameters.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.ContractParameters)
            return object;
          var message = new $root.pruntime_rpc.ContractParameters();
          if (object.deployer != null)
            message.deployer = String(object.deployer);
          if (object.clusterId != null)
            message.clusterId = String(object.clusterId);
          if (object.codeHash != null)
            message.codeHash = String(object.codeHash);
          if (object.salt != null)
            message.salt = String(object.salt);
          return message;
        };
        ContractParameters.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.deployer = "";
            object.clusterId = "";
            object.codeHash = "";
            object.salt = "";
          }
          if (message.deployer != null && message.hasOwnProperty("deployer"))
            object.deployer = message.deployer;
          if (message.clusterId != null && message.hasOwnProperty("clusterId"))
            object.clusterId = message.clusterId;
          if (message.codeHash != null && message.hasOwnProperty("codeHash"))
            object.codeHash = message.codeHash;
          if (message.salt != null && message.hasOwnProperty("salt"))
            object.salt = message.salt;
          return object;
        };
        ContractParameters.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ContractParameters.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.ContractParameters";
        };
        return ContractParameters;
      }();
      pruntime_rpc2.ContractId = function() {
        function ContractId(properties) {
          if (properties) {
            for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
              if (properties[keys2[i]] != null)
                this[keys2[i]] = properties[keys2[i]];
          }
        }
        ContractId.prototype.id = "";
        ContractId.create = function create(properties) {
          return new ContractId(properties);
        };
        ContractId.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.id);
          return writer;
        };
        ContractId.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ContractId.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.ContractId();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.id = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ContractId.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ContractId.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.id != null && message.hasOwnProperty("id")) {
            if (!$util.isString(message.id))
              return "id: string expected";
          }
          return null;
        };
        ContractId.fromObject = function fromObject3(object) {
          if (object instanceof $root.pruntime_rpc.ContractId)
            return object;
          var message = new $root.pruntime_rpc.ContractId();
          if (object.id != null)
            message.id = String(object.id);
          return message;
        };
        ContractId.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults)
            object.id = "";
          if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
          return object;
        };
        ContractId.prototype.toJSON = function toJSON3() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ContractId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.ContractId";
        };
        return ContractId;
      }();
      return pruntime_rpc2;
    }();
    $root.google = function() {
      var google = {};
      google.protobuf = function() {
        var protobuf = {};
        protobuf.Empty = function() {
          function Empty(properties) {
            if (properties) {
              for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
                if (properties[keys2[i]] != null)
                  this[keys2[i]] = properties[keys2[i]];
            }
          }
          Empty.create = function create(properties) {
            return new Empty(properties);
          };
          Empty.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            return writer;
          };
          Empty.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Empty.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Empty.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Empty.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            return null;
          };
          Empty.fromObject = function fromObject3(object) {
            if (object instanceof $root.google.protobuf.Empty)
              return object;
            return new $root.google.protobuf.Empty();
          };
          Empty.toObject = function toObject() {
            return {};
          };
          Empty.prototype.toJSON = function toJSON3() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          Empty.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/google.protobuf.Empty";
          };
          return Empty;
        }();
        return protobuf;
      }();
      return google;
    }();
    module2.exports = $root;
  }
});

// node-modules-polyfills:buffer
var buffer_exports = {};
__export(buffer_exports, {
  Buffer: () => Buffer2,
  INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
  SlowBuffer: () => SlowBuffer,
  isBuffer: () => isBuffer2,
  kMaxLength: () => _kMaxLength
});
function init2() {
  inited2 = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup2[i] = code[i];
    revLookup2[code.charCodeAt(i)] = i;
  }
  revLookup2["-".charCodeAt(0)] = 62;
  revLookup2["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited2) {
    init2();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr2(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup2[b64.charCodeAt(i)] << 18 | revLookup2[b64.charCodeAt(i + 1)] << 12 | revLookup2[b64.charCodeAt(i + 2)] << 6 | revLookup2[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup2[b64.charCodeAt(i)] << 2 | revLookup2[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup2[b64.charCodeAt(i)] << 10 | revLookup2[b64.charCodeAt(i + 1)] << 4 | revLookup2[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase642(num) {
  return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
}
function encodeChunk2(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase642(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited2) {
    init2();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk2(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup2[tmp >> 2];
    output += lookup2[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup2[tmp >> 10];
    output += lookup2[tmp >> 4 & 63];
    output += lookup2[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write2(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s * 128;
}
function kMaxLength2() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer2(that, length) {
  if (kMaxLength2() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe2(this, arg);
  }
  return from2(this, arg, encodingOrOffset, length);
}
function from2(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer2(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString2(that, value, encodingOrOffset);
  }
  return fromObject2(that, value);
}
function assertSize2(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc2(that, size, fill3, encoding) {
  assertSize2(size);
  if (size <= 0) {
    return createBuffer2(that, size);
  }
  if (fill3 !== void 0) {
    return typeof encoding === "string" ? createBuffer2(that, size).fill(fill3, encoding) : createBuffer2(that, size).fill(fill3);
  }
  return createBuffer2(that, size);
}
function allocUnsafe2(that, size) {
  assertSize2(size);
  that = createBuffer2(that, size < 0 ? 0 : checked2(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
function fromString2(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength2(string, encoding) | 0;
  that = createBuffer2(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike2(that, array) {
  var length = array.length < 0 ? 0 : checked2(array.length) | 0;
  that = createBuffer2(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer2(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike2(that, array);
  }
  return that;
}
function fromObject2(that, obj) {
  if (internalIsBuffer2(obj)) {
    var len = checked2(obj.length) | 0;
    that = createBuffer2(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan2(obj.length)) {
        return createBuffer2(that, 0);
      }
      return fromArrayLike2(that, obj);
    }
    if (obj.type === "Buffer" && isArray(obj.data)) {
      return fromArrayLike2(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked2(length) {
  if (length >= kMaxLength2()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength2().toString(16) + " bytes");
  }
  return length | 0;
}
function SlowBuffer(length) {
  if (+length != length) {
    length = 0;
  }
  return Buffer2.alloc(+length);
}
function internalIsBuffer2(b) {
  return !!(b != null && b._isBuffer);
}
function byteLength2(string, encoding) {
  if (internalIsBuffer2(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes2(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes2(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes2(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString2(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice2(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice2(this, start, end);
      case "ascii":
        return asciiSlice2(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice2(this, start, end);
      case "base64":
        return base64Slice2(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice2(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap2(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
function bidirectionalIndexOf2(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer2(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf2(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf2(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf2(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
function hexWrite2(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write2(buf, string, offset, length) {
  return blitBuffer2(utf8ToBytes2(string, buf.length - offset), buf, offset, length);
}
function asciiWrite2(buf, string, offset, length) {
  return blitBuffer2(asciiToBytes2(string), buf, offset, length);
}
function latin1Write2(buf, string, offset, length) {
  return asciiWrite2(buf, string, offset, length);
}
function base64Write2(buf, string, offset, length) {
  return blitBuffer2(base64ToBytes2(string), buf, offset, length);
}
function ucs2Write2(buf, string, offset, length) {
  return blitBuffer2(utf16leToBytes2(string, buf.length - offset), buf, offset, length);
}
function base64Slice2(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice2(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
function decodeCodePointsArray2(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2)
    );
  }
  return res;
}
function asciiSlice2(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice2(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice2(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex2(buf[i]);
  }
  return out;
}
function utf16leSlice2(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
function checkOffset2(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt2(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer2(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt162(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
function objectWriteUInt322(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
function checkIEEE7542(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat2(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value, offset, 4);
  }
  write2(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble2(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value, offset, 8);
  }
  write2(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean2(str) {
  str = stringtrim2(str).replace(INVALID_BASE64_RE2, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim2(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex2(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes2(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes2(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes2(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes2(str) {
  return toByteArray(base64clean2(str));
}
function blitBuffer2(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan2(val) {
  return val !== val;
}
function isBuffer2(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer2(obj) || isSlowBuffer2(obj));
}
function isFastBuffer2(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer2(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer2(obj.slice(0, 0));
}
var lookup2, revLookup2, Arr2, inited2, toString2, isArray, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH2, INVALID_BASE64_RE2;
var init_buffer2 = __esm({
  "node-modules-polyfills:buffer"() {
    "use strict";
    init_process();
    init_buffer();
    lookup2 = [];
    revLookup2 = [];
    Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited2 = false;
    toString2 = {}.toString;
    isArray = Array.isArray || function(arr) {
      return toString2.call(arr) == "[object Array]";
    };
    INSPECT_MAX_BYTES = 50;
    Buffer2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
    _kMaxLength = kMaxLength2();
    Buffer2.poolSize = 8192;
    Buffer2._augment = function(arr) {
      arr.__proto__ = Buffer2.prototype;
      return arr;
    };
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from2(null, value, encodingOrOffset, length);
    };
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      Buffer2.prototype.__proto__ = Uint8Array.prototype;
      Buffer2.__proto__ = Uint8Array;
    }
    Buffer2.alloc = function(size, fill3, encoding) {
      return alloc2(null, size, fill3, encoding);
    };
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe2(null, size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe2(null, size);
    };
    Buffer2.isBuffer = isBuffer2;
    Buffer2.compare = function compare3(a, b) {
      if (!internalIsBuffer2(a) || !internalIsBuffer2(b)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding2(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat2(list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer2(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer2.byteLength = byteLength2;
    Buffer2.prototype._isBuffer = true;
    Buffer2.prototype.swap16 = function swap162() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap2(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap322() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap2(this, i, i + 3);
        swap2(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap642() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap2(this, i, i + 7);
        swap2(this, i + 1, i + 6);
        swap2(this, i + 2, i + 5);
        swap2(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString3() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice2(this, 0, length);
      return slowToString2.apply(this, arguments);
    };
    Buffer2.prototype.equals = function equals2(b) {
      if (!internalIsBuffer2(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
        if (this.length > max)
          str += " ... ";
      }
      return "<Buffer " + str + ">";
    };
    Buffer2.prototype.compare = function compare4(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer2(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.prototype.includes = function includes2(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
      return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
      return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
    };
    Buffer2.prototype.write = function write3(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite2(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write2(this, string, offset, length);
          case "ascii":
            return asciiWrite2(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write2(this, string, offset, length);
          case "base64":
            return base64Write2(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write2(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON2() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH2 = 4096;
    Buffer2.prototype.slice = function slice2(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer2.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }
      return newBuf;
    };
    Buffer2.prototype.readUIntLE = function readUIntLE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUIntBE = function readUIntBE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        checkOffset2(offset, byteLength3, this.length);
      }
      var val = this[offset + --byteLength3];
      var mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUInt8 = function readUInt82(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUInt16LE = function readUInt16LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUInt16BE = function readUInt16BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUInt32LE = function readUInt32LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUInt32BE = function readUInt32BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length);
      var i = byteLength3;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt82(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 8, this.length);
      return read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 8, this.length);
      return read(this, offset, false, 52, 8);
    };
    Buffer2.prototype.writeUIntLE = function writeUIntLE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt2(this, value, offset, byteLength3, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUIntBE = function writeUIntBE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt2(this, value, offset, byteLength3, maxBytes, 0);
      }
      var i = byteLength3 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUInt8 = function writeUInt82(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 1, 255, 0);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUInt16LE = function writeUInt16LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt162(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt16BE = function writeUInt16BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt162(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt32LE = function writeUInt32LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt322(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeUInt32BE = function writeUInt32BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt322(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt2(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt2(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i = byteLength3 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeInt8 = function writeInt82(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 1, 127, -128);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt162(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt162(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt322(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt322(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeFloatLE = function writeFloatLE2(value, offset, noAssert) {
      return writeFloat2(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE2(value, offset, noAssert) {
      return writeFloat2(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE2(value, offset, noAssert) {
      return writeDouble2(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE2(value, offset, noAssert) {
      return writeDouble2(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i;
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill2(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer2(val) ? val : utf8ToBytes2(new Buffer2(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE2 = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node-modules-polyfills-commonjs:buffer
var require_buffer = __commonJS({
  "node-modules-polyfills-commonjs:buffer"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var polyfill = (init_buffer2(), __toCommonJS(buffer_exports));
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default;
      for (let k in polyfill) {
        module2.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module2.exports = polyfill;
    }
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var buffer = require_buffer();
    var Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill3, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill3 !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill3, encoding);
        } else {
          buf.fill(fill3);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/randombytes/browser.js
var require_browser = __commonJS({
  "node_modules/randombytes/browser.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer3 = require_safe_buffer().Buffer;
    var crypto = globalThis.crypto || globalThis.msCrypto;
    if (crypto && crypto.getRandomValues) {
      module2.exports = randomBytes2;
    } else {
      module2.exports = oldBrowser;
    }
    function randomBytes2(size, cb) {
      if (size > MAX_UINT32)
        throw new RangeError("requested too many random bytes");
      var bytes = Buffer3.allocUnsafe(size);
      if (size > 0) {
        if (size > MAX_BYTES) {
          for (var generated = 0; generated < size; generated += MAX_BYTES) {
            crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto.getRandomValues(bytes);
        }
      }
      if (typeof cb === "function") {
        return process.nextTick(function() {
          cb(null, bytes);
        });
      }
      return bytes;
    }
  }
});

// node-modules-polyfills:events
var events_exports = {};
__export(events_exports, {
  EventEmitter: () => EventEmitter,
  default: () => events_default
});
function EventHandlers() {
}
function EventEmitter() {
  EventEmitter.init.call(this);
}
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].apply(self2, args);
  }
}
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events.newListener) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events = target._events;
    }
    existing = events[type];
  }
  if (!existing) {
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e) {
  typeof console.warn === "function" ? console.warn(e) : console.log(e);
}
function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
function listenerCount(type) {
  var events = this._events;
  if (events) {
    var evlistener = events[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}
function arrayClone(arr, i) {
  var copy3 = new Array(i);
  while (i--)
    copy3[i] = arr[i];
  return copy3;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
var domain, events_default;
var init_events = __esm({
  "node-modules-polyfills:events"() {
    "use strict";
    init_process();
    init_buffer();
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
    events_default = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active && !(this instanceof domain.Domain)) {
          this.domain = domain.active;
        }
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit2(type) {
      var er, handler, len, args, i, events, domain2;
      var needDomainExit = false;
      var doError = type === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain2 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain2) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain2;
          er.domainThrown = false;
          domain2.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      if (needDomainExit)
        domain2.exit();
      return true;
    };
    EventEmitter.prototype.addListener = function addListener2(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    EventEmitter.prototype.once = function once2(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener2(type, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners2(type) {
      var listeners2, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        for (var i = 0, key; i < keys2.length; ++i) {
          key = keys2[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type];
      if (typeof listeners2 === "function") {
        this.removeListener(type, listeners2);
      } else if (listeners2) {
        do {
          this.removeListener(type, listeners2[listeners2.length - 1]);
        } while (listeners2[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
  }
});

// node-modules-polyfills:process
function defaultSetTimout2() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout2() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout2(fun) {
  if (cachedSetTimeout2 === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout2 === defaultSetTimout2 || !cachedSetTimeout2) && setTimeout) {
    cachedSetTimeout2 = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout2(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout2.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout2.call(this, fun, 0);
    }
  }
}
function runClearTimeout2(marker) {
  if (cachedClearTimeout2 === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout2 === defaultClearTimeout2 || !cachedClearTimeout2) && clearTimeout) {
    cachedClearTimeout2 = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout2(marker);
  } catch (e) {
    try {
      return cachedClearTimeout2.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout2.call(this, marker);
    }
  }
}
function cleanUpNextTick2() {
  if (!draining2 || !currentQueue2) {
    return;
  }
  draining2 = false;
  if (currentQueue2.length) {
    queue2 = currentQueue2.concat(queue2);
  } else {
    queueIndex2 = -1;
  }
  if (queue2.length) {
    drainQueue2();
  }
}
function drainQueue2() {
  if (draining2) {
    return;
  }
  var timeout = runTimeout2(cleanUpNextTick2);
  draining2 = true;
  var len = queue2.length;
  while (len) {
    currentQueue2 = queue2;
    queue2 = [];
    while (++queueIndex2 < len) {
      if (currentQueue2) {
        currentQueue2[queueIndex2].run();
      }
    }
    queueIndex2 = -1;
    len = queue2.length;
  }
  currentQueue2 = null;
  draining2 = false;
  runClearTimeout2(timeout);
}
function nextTick2(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue2.push(new Item2(fun, args));
  if (queue2.length === 1 && !draining2) {
    runTimeout2(drainQueue2);
  }
}
function Item2(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop2() {
}
function binding2(name) {
  throw new Error("process.binding is not supported");
}
function cwd2() {
  return "/";
}
function chdir2(dir) {
  throw new Error("process.chdir is not supported");
}
function umask2() {
  return 0;
}
function hrtime2(previousTimestamp) {
  var clocktime = performanceNow2.call(performance2) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime2() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime2;
  return dif / 1e3;
}
var cachedSetTimeout2, cachedClearTimeout2, queue2, draining2, currentQueue2, queueIndex2, title2, platform2, browser2, env2, argv2, version2, versions2, release2, config2, on2, addListener3, once3, off2, removeListener3, removeAllListeners3, emit3, performance2, performanceNow2, startTime2, browser$1, process_default;
var init_process2 = __esm({
  "node-modules-polyfills:process"() {
    "use strict";
    init_process();
    init_buffer();
    cachedSetTimeout2 = defaultSetTimout2;
    cachedClearTimeout2 = defaultClearTimeout2;
    if (typeof globalThis.setTimeout === "function") {
      cachedSetTimeout2 = setTimeout;
    }
    if (typeof globalThis.clearTimeout === "function") {
      cachedClearTimeout2 = clearTimeout;
    }
    queue2 = [];
    draining2 = false;
    queueIndex2 = -1;
    Item2.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title2 = "browser";
    platform2 = "browser";
    browser2 = true;
    env2 = {};
    argv2 = [];
    version2 = "";
    versions2 = {};
    release2 = {};
    config2 = {};
    on2 = noop2;
    addListener3 = noop2;
    once3 = noop2;
    off2 = noop2;
    removeListener3 = noop2;
    removeAllListeners3 = noop2;
    emit3 = noop2;
    performance2 = globalThis.performance || {};
    performanceNow2 = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
    startTime2 = /* @__PURE__ */ new Date();
    browser$1 = {
      nextTick: nextTick2,
      title: title2,
      browser: browser2,
      env: env2,
      argv: argv2,
      version: version2,
      versions: versions2,
      on: on2,
      addListener: addListener3,
      once: once3,
      off: off2,
      removeListener: removeListener3,
      removeAllListeners: removeAllListeners3,
      emit: emit3,
      binding: binding2,
      cwd: cwd2,
      chdir: chdir2,
      umask: umask2,
      hrtime: hrtime2,
      platform: platform2,
      release: release2,
      config: config2,
      uptime: uptime2
    };
    process_default = browser$1;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
var inherits, inherits_default;
var init_inherits = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
    "use strict";
    init_process();
    init_buffer();
    if (typeof Object.create === "function") {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    inherits_default = inherits;
  }
});

// node-modules-polyfills:util
var util_exports = {};
__export(util_exports, {
  _extend: () => _extend,
  debuglog: () => debuglog,
  default: () => util_default,
  deprecate: () => deprecate,
  format: () => format,
  inherits: () => inherits_default,
  inspect: () => inspect2,
  isArray: () => isArray2,
  isBoolean: () => isBoolean,
  isBuffer: () => isBuffer3,
  isDate: () => isDate,
  isError: () => isError,
  isFunction: () => isFunction,
  isNull: () => isNull,
  isNullOrUndefined: () => isNullOrUndefined,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isPrimitive: () => isPrimitive,
  isRegExp: () => isRegExp,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isUndefined: () => isUndefined,
  log: () => log
});
function format(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect2(arguments[i]));
    }
    return objects.join(" ");
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x2) {
    if (x2 === "%%")
      return "%";
    if (i >= len)
      return x2;
    switch (x2) {
      case "%s":
        return String(args[i++]);
      case "%d":
        return Number(args[i++]);
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += " " + x;
    } else {
      str += " " + inspect2(x);
    }
  }
  return str;
}
function deprecate(fn, msg) {
  if (isUndefined(globalThis.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (process_default.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process_default.throwDeprecation) {
        throw new Error(msg);
      } else if (process_default.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process_default.env.NODE_DEBUG || "";
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format.apply(null, arguments);
        console.error("%s %d: %s", set, pid, msg);
      };
    } else {
      debugs[set] = function() {
      };
    }
  }
  return debugs[set];
}
function inspect2(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined(ctx.depth))
    ctx.depth = 2;
  if (isUndefined(ctx.colors))
    ctx.colors = false;
  if (isUndefined(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
function stylizeWithColor(str, styleType) {
  var style = inspect2.styles[styleType];
  if (style) {
    return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== inspect2 && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys2.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray2(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value)) {
    var n = value.name ? ": " + value.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp(value)) {
    base = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base = " " + formatError(value);
  }
  if (keys2.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        String(i),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf("\n") >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray2(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isSymbol(arg) {
  return typeof arg === "symbol";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d) {
  return isObject(d) && objectToString(d) === "[object Date]";
}
function isError(e) {
  return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
  typeof arg === "undefined";
}
function isBuffer3(maybeBuf) {
  return Buffer.isBuffer(maybeBuf);
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function pad(n) {
  return n < 10 ? "0" + n.toString(10) : n.toString(10);
}
function timestamp() {
  var d = /* @__PURE__ */ new Date();
  var time = [
    pad(d.getHours()),
    pad(d.getMinutes()),
    pad(d.getSeconds())
  ].join(":");
  return [d.getDate(), months[d.getMonth()], time].join(" ");
}
function log() {
  console.log("%s - %s", timestamp(), format.apply(null, arguments));
}
function _extend(origin, add) {
  if (!add || !isObject(add))
    return origin;
  var keys2 = Object.keys(add);
  var i = keys2.length;
  while (i--) {
    origin[keys2[i]] = add[keys2[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var formatRegExp, debugs, debugEnviron, months, util_default;
var init_util = __esm({
  "node-modules-polyfills:util"() {
    "use strict";
    init_process();
    init_buffer();
    init_process2();
    init_inherits();
    formatRegExp = /%[sdj%]/g;
    debugs = {};
    inspect2.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect2.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    util_default = {
      inherits: inherits_default,
      _extend,
      log,
      isBuffer: isBuffer3,
      isPrimitive,
      isFunction,
      isError,
      isDate,
      isObject,
      isRegExp,
      isUndefined,
      isSymbol,
      isString,
      isNumber,
      isNullOrUndefined,
      isNull,
      isBoolean,
      isArray: isArray2,
      inspect: inspect2,
      deprecate,
      format,
      debuglog
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
var buffer_list_default;
var init_buffer_list = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
    "use strict";
    init_process();
    init_buffer();
    init_buffer2();
    buffer_list_default = BufferList;
    BufferList.prototype.push = function(v) {
      var entry = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function(v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
  }
});

// node-modules-polyfills:string_decoder
var string_decoder_exports = {};
__export(string_decoder_exports, {
  StringDecoder: () => StringDecoder
});
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var isBufferEncoding;
var init_string_decoder = __esm({
  "node-modules-polyfills:string_decoder"() {
    "use strict";
    init_process();
    init_buffer();
    init_buffer2();
    isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount2(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options2, stream) {
  options2 = options2 || {};
  this.objectMode = !!options2.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options2.readableObjectMode;
  var hwm = options2.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new buffer_list_default();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options2.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options2.encoding) {
    this.decoder = new StringDecoder(options2.encoding);
    this.encoding = options2.encoding;
  }
}
function Readable(options2) {
  if (!(this instanceof Readable))
    return new Readable(options2);
  this._readableState = new ReadableState(options2, this);
  this.readable = true;
  if (options2 && typeof options2.read === "function")
    this._read = options2.read;
  events_default.call(this);
}
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit("error", er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error("stream.push() after EOF");
      stream.emit("error", e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream.emit("error", _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront)
        state.reading = false;
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
      }
      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended)
    return 0;
  if (state.objectMode)
    return 1;
  if (n !== n) {
    if (state.flowing && state.length)
      return state.buffer.head.data.length;
    else
      return state.length;
  }
  if (n > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length)
    return n;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}
function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream, state) {
  if (state.ended)
    return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  emitReadable(stream);
}
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      nextTick2(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}
function emitReadable_(stream) {
  debug("emit readable");
  stream.emit("readable");
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick2(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length)
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners("data").length) {
      state.flowing = true;
      flow(src);
    }
  };
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick2(resume_, stream, state);
  }
}
function resume_(stream, state) {
  if (!state.reading) {
    debug("resume read 0");
    stream.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}
function flow(stream) {
  var state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null) {
  }
}
function fromList(n, state) {
  if (state.length === 0)
    return null;
  var ret;
  if (state.objectMode)
    ret = state.buffer.shift();
  else if (!n || n >= state.length) {
    if (state.decoder)
      ret = state.buffer.join("");
    else if (state.buffer.length === 1)
      ret = state.buffer.head.data;
    else
      ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
}
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length)
      ret += str;
    else
      ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick2(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit("end");
  }
}
function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
function indexOf3(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x)
      return i;
  }
  return -1;
}
var debug, MAX_HWM;
var init_readable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
    "use strict";
    init_process();
    init_buffer();
    init_events();
    init_util();
    init_buffer_list();
    init_string_decoder();
    init_duplex();
    init_process2();
    Readable.ReadableState = ReadableState;
    debug = debuglog("stream");
    inherits_default(Readable, events_default);
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (!state.objectMode && typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    MAX_HWM = 8388608;
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== false;
      var endFn = doEnd ? onend2 : cleanup;
      if (state.endEmitted)
        nextTick2(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend2() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (listenerCount2(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit("unpipe", this);
        }
        return this;
      }
      var i = indexOf3(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = events_default.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick2(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options2, stream) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options2 = options2 || {};
  this.objectMode = !!options2.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options2.writableObjectMode;
  var hwm = options2.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options2.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options2.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
function Writable(options2) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options2);
  this._writableState = new WritableState(options2, this);
  this.writable = true;
  if (options2) {
    if (typeof options2.write === "function")
      this._write = options2.write;
    if (typeof options2.writev === "function")
      this._writev = options2.writev;
  }
  EventEmitter.call(this);
}
function writeAfterEnd(stream, cb) {
  var er = new Error("write after end");
  stream.emit("error", er);
  nextTick2(cb, er);
}
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream.emit("error", er);
    nextTick2(cb, er);
    valid = false;
  }
  return valid;
}
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer2.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer2.isBuffer(chunk))
    encoding = "buffer";
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (!ret)
    state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    nextTick2(cb, er);
  else
    cb(er);
  stream._writableState.errorEmitted = true;
  stream.emit("error", er);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      nextTick2(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
}
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }
    doWrite(stream, state, true, state.length, buffer, "", holder.finish);
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      if (state.writing) {
        break;
      }
    }
    if (entry === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit("prefinish");
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit("finish");
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      nextTick2(cb);
    else
      stream.once("finish", cb);
  }
  state.ended = true;
  stream.writable = false;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
var init_writable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
    "use strict";
    init_process();
    init_buffer();
    init_util();
    init_buffer2();
    init_events();
    init_duplex();
    init_process2();
    Writable.WritableState = WritableState;
    inherits_default(Writable, EventEmitter);
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
function Duplex(options2) {
  if (!(this instanceof Duplex))
    return new Duplex(options2);
  Readable.call(this, options2);
  Writable.call(this, options2);
  if (options2 && options2.readable === false)
    this.readable = false;
  if (options2 && options2.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options2 && options2.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  nextTick2(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
var keys, method, v;
var init_duplex = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
    "use strict";
    init_process();
    init_buffer();
    init_util();
    init_process2();
    init_readable();
    init_writable();
    inherits_default(Duplex, Readable);
    keys = Object.keys(Writable.prototype);
    for (v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb)
    return stream.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data !== null && data !== void 0)
    stream.push(data);
  cb(er);
  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}
function Transform(options2) {
  if (!(this instanceof Transform))
    return new Transform(options2);
  Duplex.call(this, options2);
  this._transformState = new TransformState(this);
  var stream = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options2) {
    if (typeof options2.transform === "function")
      this._transform = options2.transform;
    if (typeof options2.flush === "function")
      this._flush = options2.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function")
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}
function done(stream, er) {
  if (er)
    return stream.emit("error", er);
  var ws = stream._writableState;
  var ts = stream._transformState;
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream.push(null);
}
var init_transform = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
    "use strict";
    init_process();
    init_buffer();
    init_duplex();
    init_util();
    inherits_default(Transform, Duplex);
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("Not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
function PassThrough(options2) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options2);
  Transform.call(this, options2);
}
var init_passthrough = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
    "use strict";
    init_process();
    init_buffer();
    init_transform();
    init_util();
    inherits_default(PassThrough, Transform);
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node-modules-polyfills:stream
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform,
  Writable: () => Writable,
  default: () => stream_default
});
function Stream() {
  events_default.call(this);
}
var stream_default;
var init_stream = __esm({
  "node-modules-polyfills:stream"() {
    "use strict";
    init_process();
    init_buffer();
    init_events();
    init_util();
    init_duplex();
    init_readable();
    init_writable();
    init_transform();
    init_passthrough();
    inherits_default(Stream, events_default);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    stream_default = Stream;
    Stream.prototype.pipe = function(dest, options2) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options2 || options2.end !== false)) {
        source.on("end", onend2);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend2() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (events_default.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend2);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node-modules-polyfills-commonjs:stream
var require_stream = __commonJS({
  "node-modules-polyfills-commonjs:stream"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var polyfill = (init_stream(), __toCommonJS(stream_exports));
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default;
      for (let k in polyfill) {
        module2.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module2.exports = polyfill;
    }
  }
});

// node-modules-polyfills-commonjs:string_decoder
var require_string_decoder = __commonJS({
  "node-modules-polyfills-commonjs:string_decoder"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var polyfill = (init_string_decoder(), __toCommonJS(string_decoder_exports));
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default;
      for (let k in polyfill) {
        module2.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module2.exports = polyfill;
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    if (typeof Object.create === "function") {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/cipher-base/index.js
var require_cipher_base = __commonJS({
  "node_modules/cipher-base/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer3 = require_safe_buffer().Buffer;
    var Transform2 = require_stream().Transform;
    var StringDecoder2 = require_string_decoder().StringDecoder;
    var inherits2 = require_inherits_browser();
    function CipherBase(hashMode) {
      Transform2.call(this);
      this.hashMode = typeof hashMode === "string";
      if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
      } else {
        this.final = this._finalOrDigest;
      }
      if (this._final) {
        this.__final = this._final;
        this._final = null;
      }
      this._decoder = null;
      this._encoding = null;
    }
    inherits2(CipherBase, Transform2);
    CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
      if (typeof data === "string") {
        data = Buffer3.from(data, inputEnc);
      }
      var outData = this._update(data);
      if (this.hashMode)
        return this;
      if (outputEnc) {
        outData = this._toString(outData, outputEnc);
      }
      return outData;
    };
    CipherBase.prototype.setAutoPadding = function() {
    };
    CipherBase.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    CipherBase.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    CipherBase.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    CipherBase.prototype._transform = function(data, _, next) {
      var err;
      try {
        if (this.hashMode) {
          this._update(data);
        } else {
          this.push(this._update(data));
        }
      } catch (e) {
        err = e;
      } finally {
        next(err);
      }
    };
    CipherBase.prototype._flush = function(done2) {
      var err;
      try {
        this.push(this.__final());
      } catch (e) {
        err = e;
      }
      done2(err);
    };
    CipherBase.prototype._finalOrDigest = function(outputEnc) {
      var outData = this.__final() || Buffer3.alloc(0);
      if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
      }
      return outData;
    };
    CipherBase.prototype._toString = function(value, enc, fin) {
      if (!this._decoder) {
        this._decoder = new StringDecoder2(enc);
        this._encoding = enc;
      }
      if (this._encoding !== enc)
        throw new Error("can't switch encodings");
      var out = this._decoder.write(value);
      if (fin) {
        out += this._decoder.end();
      }
      return out;
    };
    module2.exports = CipherBase;
  }
});

// node_modules/des.js/lib/des/utils.js
var require_utils = __commonJS({
  "node_modules/des.js/lib/des/utils.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    exports2.readUInt32BE = function readUInt32BE3(bytes, off3) {
      var res = bytes[0 + off3] << 24 | bytes[1 + off3] << 16 | bytes[2 + off3] << 8 | bytes[3 + off3];
      return res >>> 0;
    };
    exports2.writeUInt32BE = function writeUInt32BE3(bytes, value, off3) {
      bytes[0 + off3] = value >>> 24;
      bytes[1 + off3] = value >>> 16 & 255;
      bytes[2 + off3] = value >>> 8 & 255;
      bytes[3 + off3] = value & 255;
    };
    exports2.ip = function ip(inL, inR, out, off3) {
      var outL = 0;
      var outR = 0;
      for (var i = 6; i >= 0; i -= 2) {
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inR >>> j + i & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inL >>> j + i & 1;
        }
      }
      for (var i = 6; i >= 0; i -= 2) {
        for (var j = 1; j <= 25; j += 8) {
          outR <<= 1;
          outR |= inR >>> j + i & 1;
        }
        for (var j = 1; j <= 25; j += 8) {
          outR <<= 1;
          outR |= inL >>> j + i & 1;
        }
      }
      out[off3 + 0] = outL >>> 0;
      out[off3 + 1] = outR >>> 0;
    };
    exports2.rip = function rip(inL, inR, out, off3) {
      var outL = 0;
      var outR = 0;
      for (var i = 0; i < 4; i++) {
        for (var j = 24; j >= 0; j -= 8) {
          outL <<= 1;
          outL |= inR >>> j + i & 1;
          outL <<= 1;
          outL |= inL >>> j + i & 1;
        }
      }
      for (var i = 4; i < 8; i++) {
        for (var j = 24; j >= 0; j -= 8) {
          outR <<= 1;
          outR |= inR >>> j + i & 1;
          outR <<= 1;
          outR |= inL >>> j + i & 1;
        }
      }
      out[off3 + 0] = outL >>> 0;
      out[off3 + 1] = outR >>> 0;
    };
    exports2.pc1 = function pc1(inL, inR, out, off3) {
      var outL = 0;
      var outR = 0;
      for (var i = 7; i >= 5; i--) {
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inR >> j + i & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inL >> j + i & 1;
        }
      }
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inR >> j + i & 1;
      }
      for (var i = 1; i <= 3; i++) {
        for (var j = 0; j <= 24; j += 8) {
          outR <<= 1;
          outR |= inR >> j + i & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outR <<= 1;
          outR |= inL >> j + i & 1;
        }
      }
      for (var j = 0; j <= 24; j += 8) {
        outR <<= 1;
        outR |= inL >> j + i & 1;
      }
      out[off3 + 0] = outL >>> 0;
      out[off3 + 1] = outR >>> 0;
    };
    exports2.r28shl = function r28shl(num, shift) {
      return num << shift & 268435455 | num >>> 28 - shift;
    };
    var pc2table = [
      // inL => outL
      14,
      11,
      17,
      4,
      27,
      23,
      25,
      0,
      13,
      22,
      7,
      18,
      5,
      9,
      16,
      24,
      2,
      20,
      12,
      21,
      1,
      8,
      15,
      26,
      // inR => outR
      15,
      4,
      25,
      19,
      9,
      1,
      26,
      16,
      5,
      11,
      23,
      8,
      12,
      7,
      17,
      0,
      22,
      3,
      10,
      14,
      6,
      20,
      27,
      24
    ];
    exports2.pc2 = function pc2(inL, inR, out, off3) {
      var outL = 0;
      var outR = 0;
      var len = pc2table.length >>> 1;
      for (var i = 0; i < len; i++) {
        outL <<= 1;
        outL |= inL >>> pc2table[i] & 1;
      }
      for (var i = len; i < pc2table.length; i++) {
        outR <<= 1;
        outR |= inR >>> pc2table[i] & 1;
      }
      out[off3 + 0] = outL >>> 0;
      out[off3 + 1] = outR >>> 0;
    };
    exports2.expand = function expand(r, out, off3) {
      var outL = 0;
      var outR = 0;
      outL = (r & 1) << 5 | r >>> 27;
      for (var i = 23; i >= 15; i -= 4) {
        outL <<= 6;
        outL |= r >>> i & 63;
      }
      for (var i = 11; i >= 3; i -= 4) {
        outR |= r >>> i & 63;
        outR <<= 6;
      }
      outR |= (r & 31) << 1 | r >>> 31;
      out[off3 + 0] = outL >>> 0;
      out[off3 + 1] = outR >>> 0;
    };
    var sTable = [
      14,
      0,
      4,
      15,
      13,
      7,
      1,
      4,
      2,
      14,
      15,
      2,
      11,
      13,
      8,
      1,
      3,
      10,
      10,
      6,
      6,
      12,
      12,
      11,
      5,
      9,
      9,
      5,
      0,
      3,
      7,
      8,
      4,
      15,
      1,
      12,
      14,
      8,
      8,
      2,
      13,
      4,
      6,
      9,
      2,
      1,
      11,
      7,
      15,
      5,
      12,
      11,
      9,
      3,
      7,
      14,
      3,
      10,
      10,
      0,
      5,
      6,
      0,
      13,
      15,
      3,
      1,
      13,
      8,
      4,
      14,
      7,
      6,
      15,
      11,
      2,
      3,
      8,
      4,
      14,
      9,
      12,
      7,
      0,
      2,
      1,
      13,
      10,
      12,
      6,
      0,
      9,
      5,
      11,
      10,
      5,
      0,
      13,
      14,
      8,
      7,
      10,
      11,
      1,
      10,
      3,
      4,
      15,
      13,
      4,
      1,
      2,
      5,
      11,
      8,
      6,
      12,
      7,
      6,
      12,
      9,
      0,
      3,
      5,
      2,
      14,
      15,
      9,
      10,
      13,
      0,
      7,
      9,
      0,
      14,
      9,
      6,
      3,
      3,
      4,
      15,
      6,
      5,
      10,
      1,
      2,
      13,
      8,
      12,
      5,
      7,
      14,
      11,
      12,
      4,
      11,
      2,
      15,
      8,
      1,
      13,
      1,
      6,
      10,
      4,
      13,
      9,
      0,
      8,
      6,
      15,
      9,
      3,
      8,
      0,
      7,
      11,
      4,
      1,
      15,
      2,
      14,
      12,
      3,
      5,
      11,
      10,
      5,
      14,
      2,
      7,
      12,
      7,
      13,
      13,
      8,
      14,
      11,
      3,
      5,
      0,
      6,
      6,
      15,
      9,
      0,
      10,
      3,
      1,
      4,
      2,
      7,
      8,
      2,
      5,
      12,
      11,
      1,
      12,
      10,
      4,
      14,
      15,
      9,
      10,
      3,
      6,
      15,
      9,
      0,
      0,
      6,
      12,
      10,
      11,
      1,
      7,
      13,
      13,
      8,
      15,
      9,
      1,
      4,
      3,
      5,
      14,
      11,
      5,
      12,
      2,
      7,
      8,
      2,
      4,
      14,
      2,
      14,
      12,
      11,
      4,
      2,
      1,
      12,
      7,
      4,
      10,
      7,
      11,
      13,
      6,
      1,
      8,
      5,
      5,
      0,
      3,
      15,
      15,
      10,
      13,
      3,
      0,
      9,
      14,
      8,
      9,
      6,
      4,
      11,
      2,
      8,
      1,
      12,
      11,
      7,
      10,
      1,
      13,
      14,
      7,
      2,
      8,
      13,
      15,
      6,
      9,
      15,
      12,
      0,
      5,
      9,
      6,
      10,
      3,
      4,
      0,
      5,
      14,
      3,
      12,
      10,
      1,
      15,
      10,
      4,
      15,
      2,
      9,
      7,
      2,
      12,
      6,
      9,
      8,
      5,
      0,
      6,
      13,
      1,
      3,
      13,
      4,
      14,
      14,
      0,
      7,
      11,
      5,
      3,
      11,
      8,
      9,
      4,
      14,
      3,
      15,
      2,
      5,
      12,
      2,
      9,
      8,
      5,
      12,
      15,
      3,
      10,
      7,
      11,
      0,
      14,
      4,
      1,
      10,
      7,
      1,
      6,
      13,
      0,
      11,
      8,
      6,
      13,
      4,
      13,
      11,
      0,
      2,
      11,
      14,
      7,
      15,
      4,
      0,
      9,
      8,
      1,
      13,
      10,
      3,
      14,
      12,
      3,
      9,
      5,
      7,
      12,
      5,
      2,
      10,
      15,
      6,
      8,
      1,
      6,
      1,
      6,
      4,
      11,
      11,
      13,
      13,
      8,
      12,
      1,
      3,
      4,
      7,
      10,
      14,
      7,
      10,
      9,
      15,
      5,
      6,
      0,
      8,
      15,
      0,
      14,
      5,
      2,
      9,
      3,
      2,
      12,
      13,
      1,
      2,
      15,
      8,
      13,
      4,
      8,
      6,
      10,
      15,
      3,
      11,
      7,
      1,
      4,
      10,
      12,
      9,
      5,
      3,
      6,
      14,
      11,
      5,
      0,
      0,
      14,
      12,
      9,
      7,
      2,
      7,
      2,
      11,
      1,
      4,
      14,
      1,
      7,
      9,
      4,
      12,
      10,
      14,
      8,
      2,
      13,
      0,
      15,
      6,
      12,
      10,
      9,
      13,
      0,
      15,
      3,
      3,
      5,
      5,
      6,
      8,
      11
    ];
    exports2.substitute = function substitute(inL, inR) {
      var out = 0;
      for (var i = 0; i < 4; i++) {
        var b = inL >>> 18 - i * 6 & 63;
        var sb = sTable[i * 64 + b];
        out <<= 4;
        out |= sb;
      }
      for (var i = 0; i < 4; i++) {
        var b = inR >>> 18 - i * 6 & 63;
        var sb = sTable[4 * 64 + i * 64 + b];
        out <<= 4;
        out |= sb;
      }
      return out >>> 0;
    };
    var permuteTable = [
      16,
      25,
      12,
      11,
      3,
      20,
      4,
      15,
      31,
      17,
      9,
      6,
      27,
      14,
      1,
      22,
      30,
      24,
      8,
      18,
      0,
      5,
      29,
      23,
      13,
      19,
      2,
      26,
      10,
      21,
      28,
      7
    ];
    exports2.permute = function permute(num) {
      var out = 0;
      for (var i = 0; i < permuteTable.length; i++) {
        out <<= 1;
        out |= num >>> permuteTable[i] & 1;
      }
      return out >>> 0;
    };
    exports2.padSplit = function padSplit(num, size, group) {
      var str = num.toString(2);
      while (str.length < size)
        str = "0" + str;
      var out = [];
      for (var i = 0; i < size; i += group)
        out.push(str.slice(i, i + group));
      return out.join(" ");
    };
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = assert2;
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert2.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  }
});

// node_modules/des.js/lib/des/cipher.js
var require_cipher = __commonJS({
  "node_modules/des.js/lib/des/cipher.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var assert2 = require_minimalistic_assert();
    function Cipher(options2) {
      this.options = options2;
      this.type = this.options.type;
      this.blockSize = 8;
      this._init();
      this.buffer = new Array(this.blockSize);
      this.bufferOff = 0;
    }
    module2.exports = Cipher;
    Cipher.prototype._init = function _init() {
    };
    Cipher.prototype.update = function update(data) {
      if (data.length === 0)
        return [];
      if (this.type === "decrypt")
        return this._updateDecrypt(data);
      else
        return this._updateEncrypt(data);
    };
    Cipher.prototype._buffer = function _buffer(data, off3) {
      var min = Math.min(this.buffer.length - this.bufferOff, data.length - off3);
      for (var i = 0; i < min; i++)
        this.buffer[this.bufferOff + i] = data[off3 + i];
      this.bufferOff += min;
      return min;
    };
    Cipher.prototype._flushBuffer = function _flushBuffer(out, off3) {
      this._update(this.buffer, 0, out, off3);
      this.bufferOff = 0;
      return this.blockSize;
    };
    Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count = (this.bufferOff + data.length) / this.blockSize | 0;
      var out = new Array(count * this.blockSize);
      if (this.bufferOff !== 0) {
        inputOff += this._buffer(data, inputOff);
        if (this.bufferOff === this.buffer.length)
          outputOff += this._flushBuffer(out, outputOff);
      }
      var max = data.length - (data.length - inputOff) % this.blockSize;
      for (; inputOff < max; inputOff += this.blockSize) {
        this._update(data, inputOff, out, outputOff);
        outputOff += this.blockSize;
      }
      for (; inputOff < data.length; inputOff++, this.bufferOff++)
        this.buffer[this.bufferOff] = data[inputOff];
      return out;
    };
    Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
      var out = new Array(count * this.blockSize);
      for (; count > 0; count--) {
        inputOff += this._buffer(data, inputOff);
        outputOff += this._flushBuffer(out, outputOff);
      }
      inputOff += this._buffer(data, inputOff);
      return out;
    };
    Cipher.prototype.final = function final(buffer) {
      var first;
      if (buffer)
        first = this.update(buffer);
      var last;
      if (this.type === "encrypt")
        last = this._finalEncrypt();
      else
        last = this._finalDecrypt();
      if (first)
        return first.concat(last);
      else
        return last;
    };
    Cipher.prototype._pad = function _pad(buffer, off3) {
      if (off3 === 0)
        return false;
      while (off3 < buffer.length)
        buffer[off3++] = 0;
      return true;
    };
    Cipher.prototype._finalEncrypt = function _finalEncrypt() {
      if (!this._pad(this.buffer, this.bufferOff))
        return [];
      var out = new Array(this.blockSize);
      this._update(this.buffer, 0, out, 0);
      return out;
    };
    Cipher.prototype._unpad = function _unpad(buffer) {
      return buffer;
    };
    Cipher.prototype._finalDecrypt = function _finalDecrypt() {
      assert2.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
      var out = new Array(this.blockSize);
      this._flushBuffer(out, 0);
      return this._unpad(out);
    };
  }
});

// node_modules/des.js/lib/des/des.js
var require_des = __commonJS({
  "node_modules/des.js/lib/des/des.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var assert2 = require_minimalistic_assert();
    var inherits2 = require_inherits_browser();
    var utils = require_utils();
    var Cipher = require_cipher();
    function DESState() {
      this.tmp = new Array(2);
      this.keys = null;
    }
    function DES(options2) {
      Cipher.call(this, options2);
      var state = new DESState();
      this._desState = state;
      this.deriveKeys(state, options2.key);
    }
    inherits2(DES, Cipher);
    module2.exports = DES;
    DES.create = function create(options2) {
      return new DES(options2);
    };
    var shiftTable = [
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      1
    ];
    DES.prototype.deriveKeys = function deriveKeys(state, key) {
      state.keys = new Array(16 * 2);
      assert2.equal(key.length, this.blockSize, "Invalid key length");
      var kL = utils.readUInt32BE(key, 0);
      var kR = utils.readUInt32BE(key, 4);
      utils.pc1(kL, kR, state.tmp, 0);
      kL = state.tmp[0];
      kR = state.tmp[1];
      for (var i = 0; i < state.keys.length; i += 2) {
        var shift = shiftTable[i >>> 1];
        kL = utils.r28shl(kL, shift);
        kR = utils.r28shl(kR, shift);
        utils.pc2(kL, kR, state.keys, i);
      }
    };
    DES.prototype._update = function _update(inp, inOff, out, outOff) {
      var state = this._desState;
      var l = utils.readUInt32BE(inp, inOff);
      var r = utils.readUInt32BE(inp, inOff + 4);
      utils.ip(l, r, state.tmp, 0);
      l = state.tmp[0];
      r = state.tmp[1];
      if (this.type === "encrypt")
        this._encrypt(state, l, r, state.tmp, 0);
      else
        this._decrypt(state, l, r, state.tmp, 0);
      l = state.tmp[0];
      r = state.tmp[1];
      utils.writeUInt32BE(out, l, outOff);
      utils.writeUInt32BE(out, r, outOff + 4);
    };
    DES.prototype._pad = function _pad(buffer, off3) {
      var value = buffer.length - off3;
      for (var i = off3; i < buffer.length; i++)
        buffer[i] = value;
      return true;
    };
    DES.prototype._unpad = function _unpad(buffer) {
      var pad2 = buffer[buffer.length - 1];
      for (var i = buffer.length - pad2; i < buffer.length; i++)
        assert2.equal(buffer[i], pad2);
      return buffer.slice(0, buffer.length - pad2);
    };
    DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off3) {
      var l = lStart;
      var r = rStart;
      for (var i = 0; i < state.keys.length; i += 2) {
        var keyL = state.keys[i];
        var keyR = state.keys[i + 1];
        utils.expand(r, state.tmp, 0);
        keyL ^= state.tmp[0];
        keyR ^= state.tmp[1];
        var s = utils.substitute(keyL, keyR);
        var f = utils.permute(s);
        var t = r;
        r = (l ^ f) >>> 0;
        l = t;
      }
      utils.rip(r, l, out, off3);
    };
    DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off3) {
      var l = rStart;
      var r = lStart;
      for (var i = state.keys.length - 2; i >= 0; i -= 2) {
        var keyL = state.keys[i];
        var keyR = state.keys[i + 1];
        utils.expand(l, state.tmp, 0);
        keyL ^= state.tmp[0];
        keyR ^= state.tmp[1];
        var s = utils.substitute(keyL, keyR);
        var f = utils.permute(s);
        var t = l;
        l = (r ^ f) >>> 0;
        r = t;
      }
      utils.rip(l, r, out, off3);
    };
  }
});

// node_modules/des.js/lib/des/cbc.js
var require_cbc = __commonJS({
  "node_modules/des.js/lib/des/cbc.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var assert2 = require_minimalistic_assert();
    var inherits2 = require_inherits_browser();
    var proto = {};
    function CBCState(iv) {
      assert2.equal(iv.length, 8, "Invalid IV length");
      this.iv = new Array(8);
      for (var i = 0; i < this.iv.length; i++)
        this.iv[i] = iv[i];
    }
    function instantiate(Base) {
      function CBC(options2) {
        Base.call(this, options2);
        this._cbcInit();
      }
      inherits2(CBC, Base);
      var keys2 = Object.keys(proto);
      for (var i = 0; i < keys2.length; i++) {
        var key = keys2[i];
        CBC.prototype[key] = proto[key];
      }
      CBC.create = function create(options2) {
        return new CBC(options2);
      };
      return CBC;
    }
    exports2.instantiate = instantiate;
    proto._cbcInit = function _cbcInit() {
      var state = new CBCState(this.options.iv);
      this._cbcState = state;
    };
    proto._update = function _update(inp, inOff, out, outOff) {
      var state = this._cbcState;
      var superProto = this.constructor.super_.prototype;
      var iv = state.iv;
      if (this.type === "encrypt") {
        for (var i = 0; i < this.blockSize; i++)
          iv[i] ^= inp[inOff + i];
        superProto._update.call(this, iv, 0, out, outOff);
        for (var i = 0; i < this.blockSize; i++)
          iv[i] = out[outOff + i];
      } else {
        superProto._update.call(this, inp, inOff, out, outOff);
        for (var i = 0; i < this.blockSize; i++)
          out[outOff + i] ^= iv[i];
        for (var i = 0; i < this.blockSize; i++)
          iv[i] = inp[inOff + i];
      }
    };
  }
});

// node_modules/des.js/lib/des/ede.js
var require_ede = __commonJS({
  "node_modules/des.js/lib/des/ede.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var assert2 = require_minimalistic_assert();
    var inherits2 = require_inherits_browser();
    var Cipher = require_cipher();
    var DES = require_des();
    function EDEState(type, key) {
      assert2.equal(key.length, 24, "Invalid key length");
      var k1 = key.slice(0, 8);
      var k2 = key.slice(8, 16);
      var k3 = key.slice(16, 24);
      if (type === "encrypt") {
        this.ciphers = [
          DES.create({ type: "encrypt", key: k1 }),
          DES.create({ type: "decrypt", key: k2 }),
          DES.create({ type: "encrypt", key: k3 })
        ];
      } else {
        this.ciphers = [
          DES.create({ type: "decrypt", key: k3 }),
          DES.create({ type: "encrypt", key: k2 }),
          DES.create({ type: "decrypt", key: k1 })
        ];
      }
    }
    function EDE(options2) {
      Cipher.call(this, options2);
      var state = new EDEState(this.type, this.options.key);
      this._edeState = state;
    }
    inherits2(EDE, Cipher);
    module2.exports = EDE;
    EDE.create = function create(options2) {
      return new EDE(options2);
    };
    EDE.prototype._update = function _update(inp, inOff, out, outOff) {
      var state = this._edeState;
      state.ciphers[0]._update(inp, inOff, out, outOff);
      state.ciphers[1]._update(out, outOff, out, outOff);
      state.ciphers[2]._update(out, outOff, out, outOff);
    };
    EDE.prototype._pad = DES.prototype._pad;
    EDE.prototype._unpad = DES.prototype._unpad;
  }
});

// node_modules/des.js/lib/des.js
var require_des2 = __commonJS({
  "node_modules/des.js/lib/des.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    exports2.utils = require_utils();
    exports2.Cipher = require_cipher();
    exports2.DES = require_des();
    exports2.CBC = require_cbc();
    exports2.EDE = require_ede();
  }
});

// node_modules/browserify-des/index.js
var require_browserify_des = __commonJS({
  "node_modules/browserify-des/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var CipherBase = require_cipher_base();
    var des = require_des2();
    var inherits2 = require_inherits_browser();
    var Buffer3 = require_safe_buffer().Buffer;
    var modes = {
      "des-ede3-cbc": des.CBC.instantiate(des.EDE),
      "des-ede3": des.EDE,
      "des-ede-cbc": des.CBC.instantiate(des.EDE),
      "des-ede": des.EDE,
      "des-cbc": des.CBC.instantiate(des.DES),
      "des-ecb": des.DES
    };
    modes.des = modes["des-cbc"];
    modes.des3 = modes["des-ede3-cbc"];
    module2.exports = DES;
    inherits2(DES, CipherBase);
    function DES(opts) {
      CipherBase.call(this);
      var modeName = opts.mode.toLowerCase();
      var mode = modes[modeName];
      var type;
      if (opts.decrypt) {
        type = "decrypt";
      } else {
        type = "encrypt";
      }
      var key = opts.key;
      if (!Buffer3.isBuffer(key)) {
        key = Buffer3.from(key);
      }
      if (modeName === "des-ede" || modeName === "des-ede-cbc") {
        key = Buffer3.concat([key, key.slice(0, 8)]);
      }
      var iv = opts.iv;
      if (!Buffer3.isBuffer(iv)) {
        iv = Buffer3.from(iv);
      }
      this._des = mode.create({
        key,
        iv,
        type
      });
    }
    DES.prototype._update = function(data) {
      return Buffer3.from(this._des.update(data));
    };
    DES.prototype._final = function() {
      return Buffer3.from(this._des.final());
    };
  }
});

// node_modules/browserify-aes/modes/ecb.js
var require_ecb = __commonJS({
  "node_modules/browserify-aes/modes/ecb.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    exports2.encrypt = function(self2, block) {
      return self2._cipher.encryptBlock(block);
    };
    exports2.decrypt = function(self2, block) {
      return self2._cipher.decryptBlock(block);
    };
  }
});

// node_modules/buffer-xor/index.js
var require_buffer_xor = __commonJS({
  "node_modules/buffer-xor/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = function xor(a, b) {
      var length = Math.min(a.length, b.length);
      var buffer = new Buffer(length);
      for (var i = 0; i < length; ++i) {
        buffer[i] = a[i] ^ b[i];
      }
      return buffer;
    };
  }
});

// node_modules/browserify-aes/modes/cbc.js
var require_cbc2 = __commonJS({
  "node_modules/browserify-aes/modes/cbc.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var xor = require_buffer_xor();
    exports2.encrypt = function(self2, block) {
      var data = xor(block, self2._prev);
      self2._prev = self2._cipher.encryptBlock(data);
      return self2._prev;
    };
    exports2.decrypt = function(self2, block) {
      var pad2 = self2._prev;
      self2._prev = block;
      var out = self2._cipher.decryptBlock(block);
      return xor(out, pad2);
    };
  }
});

// node_modules/browserify-aes/modes/cfb.js
var require_cfb = __commonJS({
  "node_modules/browserify-aes/modes/cfb.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer3 = require_safe_buffer().Buffer;
    var xor = require_buffer_xor();
    function encryptStart(self2, data, decrypt2) {
      var len = data.length;
      var out = xor(data, self2._cache);
      self2._cache = self2._cache.slice(len);
      self2._prev = Buffer3.concat([self2._prev, decrypt2 ? data : out]);
      return out;
    }
    exports2.encrypt = function(self2, data, decrypt2) {
      var out = Buffer3.allocUnsafe(0);
      var len;
      while (data.length) {
        if (self2._cache.length === 0) {
          self2._cache = self2._cipher.encryptBlock(self2._prev);
          self2._prev = Buffer3.allocUnsafe(0);
        }
        if (self2._cache.length <= data.length) {
          len = self2._cache.length;
          out = Buffer3.concat([out, encryptStart(self2, data.slice(0, len), decrypt2)]);
          data = data.slice(len);
        } else {
          out = Buffer3.concat([out, encryptStart(self2, data, decrypt2)]);
          break;
        }
      }
      return out;
    };
  }
});

// node_modules/browserify-aes/modes/cfb8.js
var require_cfb8 = __commonJS({
  "node_modules/browserify-aes/modes/cfb8.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer3 = require_safe_buffer().Buffer;
    function encryptByte(self2, byteParam, decrypt2) {
      var pad2 = self2._cipher.encryptBlock(self2._prev);
      var out = pad2[0] ^ byteParam;
      self2._prev = Buffer3.concat([
        self2._prev.slice(1),
        Buffer3.from([decrypt2 ? byteParam : out])
      ]);
      return out;
    }
    exports2.encrypt = function(self2, chunk, decrypt2) {
      var len = chunk.length;
      var out = Buffer3.allocUnsafe(len);
      var i = -1;
      while (++i < len) {
        out[i] = encryptByte(self2, chunk[i], decrypt2);
      }
      return out;
    };
  }
});

// node_modules/browserify-aes/modes/cfb1.js
var require_cfb1 = __commonJS({
  "node_modules/browserify-aes/modes/cfb1.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer3 = require_safe_buffer().Buffer;
    function encryptByte(self2, byteParam, decrypt2) {
      var pad2;
      var i = -1;
      var len = 8;
      var out = 0;
      var bit, value;
      while (++i < len) {
        pad2 = self2._cipher.encryptBlock(self2._prev);
        bit = byteParam & 1 << 7 - i ? 128 : 0;
        value = pad2[0] ^ bit;
        out += (value & 128) >> i % 8;
        self2._prev = shiftIn(self2._prev, decrypt2 ? bit : value);
      }
      return out;
    }
    function shiftIn(buffer, value) {
      var len = buffer.length;
      var i = -1;
      var out = Buffer3.allocUnsafe(buffer.length);
      buffer = Buffer3.concat([buffer, Buffer3.from([value])]);
      while (++i < len) {
        out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
      }
      return out;
    }
    exports2.encrypt = function(self2, chunk, decrypt2) {
      var len = chunk.length;
      var out = Buffer3.allocUnsafe(len);
      var i = -1;
      while (++i < len) {
        out[i] = encryptByte(self2, chunk[i], decrypt2);
      }
      return out;
    };
  }
});

// node_modules/browserify-aes/modes/ofb.js
var require_ofb = __commonJS({
  "node_modules/browserify-aes/modes/ofb.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var xor = require_buffer_xor();
    function getBlock(self2) {
      self2._prev = self2._cipher.encryptBlock(self2._prev);
      return self2._prev;
    }
    exports2.encrypt = function(self2, chunk) {
      while (self2._cache.length < chunk.length) {
        self2._cache = Buffer.concat([self2._cache, getBlock(self2)]);
      }
      var pad2 = self2._cache.slice(0, chunk.length);
      self2._cache = self2._cache.slice(chunk.length);
      return xor(chunk, pad2);
    };
  }
});

// node_modules/browserify-aes/incr32.js
var require_incr32 = __commonJS({
  "node_modules/browserify-aes/incr32.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    function incr32(iv) {
      var len = iv.length;
      var item;
      while (len--) {
        item = iv.readUInt8(len);
        if (item === 255) {
          iv.writeUInt8(0, len);
        } else {
          item++;
          iv.writeUInt8(item, len);
          break;
        }
      }
    }
    module2.exports = incr32;
  }
});

// node_modules/browserify-aes/modes/ctr.js
var require_ctr = __commonJS({
  "node_modules/browserify-aes/modes/ctr.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var xor = require_buffer_xor();
    var Buffer3 = require_safe_buffer().Buffer;
    var incr32 = require_incr32();
    function getBlock(self2) {
      var out = self2._cipher.encryptBlockRaw(self2._prev);
      incr32(self2._prev);
      return out;
    }
    var blockSize = 16;
    exports2.encrypt = function(self2, chunk) {
      var chunkNum = Math.ceil(chunk.length / blockSize);
      var start = self2._cache.length;
      self2._cache = Buffer3.concat([
        self2._cache,
        Buffer3.allocUnsafe(chunkNum * blockSize)
      ]);
      for (var i = 0; i < chunkNum; i++) {
        var out = getBlock(self2);
        var offset = start + i * blockSize;
        self2._cache.writeUInt32BE(out[0], offset + 0);
        self2._cache.writeUInt32BE(out[1], offset + 4);
        self2._cache.writeUInt32BE(out[2], offset + 8);
        self2._cache.writeUInt32BE(out[3], offset + 12);
      }
      var pad2 = self2._cache.slice(0, chunk.length);
      self2._cache = self2._cache.slice(chunk.length);
      return xor(chunk, pad2);
    };
  }
});

// node_modules/browserify-aes/modes/list.json
var require_list = __commonJS({
  "node_modules/browserify-aes/modes/list.json"(exports2, module2) {
    module2.exports = {
      "aes-128-ecb": {
        cipher: "AES",
        key: 128,
        iv: 0,
        mode: "ECB",
        type: "block"
      },
      "aes-192-ecb": {
        cipher: "AES",
        key: 192,
        iv: 0,
        mode: "ECB",
        type: "block"
      },
      "aes-256-ecb": {
        cipher: "AES",
        key: 256,
        iv: 0,
        mode: "ECB",
        type: "block"
      },
      "aes-128-cbc": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      "aes-192-cbc": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      "aes-256-cbc": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      aes128: {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      aes192: {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      aes256: {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      "aes-128-cfb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB",
        type: "stream"
      },
      "aes-192-cfb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB",
        type: "stream"
      },
      "aes-256-cfb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB",
        type: "stream"
      },
      "aes-128-cfb8": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB8",
        type: "stream"
      },
      "aes-192-cfb8": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB8",
        type: "stream"
      },
      "aes-256-cfb8": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB8",
        type: "stream"
      },
      "aes-128-cfb1": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB1",
        type: "stream"
      },
      "aes-192-cfb1": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB1",
        type: "stream"
      },
      "aes-256-cfb1": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB1",
        type: "stream"
      },
      "aes-128-ofb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "OFB",
        type: "stream"
      },
      "aes-192-ofb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "OFB",
        type: "stream"
      },
      "aes-256-ofb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "OFB",
        type: "stream"
      },
      "aes-128-ctr": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CTR",
        type: "stream"
      },
      "aes-192-ctr": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CTR",
        type: "stream"
      },
      "aes-256-ctr": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CTR",
        type: "stream"
      },
      "aes-128-gcm": {
        cipher: "AES",
        key: 128,
        iv: 12,
        mode: "GCM",
        type: "auth"
      },
      "aes-192-gcm": {
        cipher: "AES",
        key: 192,
        iv: 12,
        mode: "GCM",
        type: "auth"
      },
      "aes-256-gcm": {
        cipher: "AES",
        key: 256,
        iv: 12,
        mode: "GCM",
        type: "auth"
      }
    };
  }
});

// node_modules/browserify-aes/modes/index.js
var require_modes = __commonJS({
  "node_modules/browserify-aes/modes/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var modeModules = {
      ECB: require_ecb(),
      CBC: require_cbc2(),
      CFB: require_cfb(),
      CFB8: require_cfb8(),
      CFB1: require_cfb1(),
      OFB: require_ofb(),
      CTR: require_ctr(),
      GCM: require_ctr()
    };
    var modes = require_list();
    for (key in modes) {
      modes[key].module = modeModules[modes[key].mode];
    }
    var key;
    module2.exports = modes;
  }
});

// node_modules/browserify-aes/aes.js
var require_aes = __commonJS({
  "node_modules/browserify-aes/aes.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer3 = require_safe_buffer().Buffer;
    function asUInt32Array(buf) {
      if (!Buffer3.isBuffer(buf))
        buf = Buffer3.from(buf);
      var len = buf.length / 4 | 0;
      var out = new Array(len);
      for (var i = 0; i < len; i++) {
        out[i] = buf.readUInt32BE(i * 4);
      }
      return out;
    }
    function scrubVec(v) {
      for (var i = 0; i < v.length; v++) {
        v[i] = 0;
      }
    }
    function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
      var SUB_MIX0 = SUB_MIX[0];
      var SUB_MIX1 = SUB_MIX[1];
      var SUB_MIX2 = SUB_MIX[2];
      var SUB_MIX3 = SUB_MIX[3];
      var s0 = M[0] ^ keySchedule[0];
      var s1 = M[1] ^ keySchedule[1];
      var s2 = M[2] ^ keySchedule[2];
      var s3 = M[3] ^ keySchedule[3];
      var t0, t1, t2, t3;
      var ksRow = 4;
      for (var round = 1; round < nRounds; round++) {
        t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++];
        t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++];
        t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++];
        t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
      }
      t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
      t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
      t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
      t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
      t0 = t0 >>> 0;
      t1 = t1 >>> 0;
      t2 = t2 >>> 0;
      t3 = t3 >>> 0;
      return [t0, t1, t2, t3];
    }
    var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
    var G = function() {
      var d = new Array(256);
      for (var j = 0; j < 256; j++) {
        if (j < 128) {
          d[j] = j << 1;
        } else {
          d[j] = j << 1 ^ 283;
        }
      }
      var SBOX = [];
      var INV_SBOX = [];
      var SUB_MIX = [[], [], [], []];
      var INV_SUB_MIX = [[], [], [], []];
      var x = 0;
      var xi = 0;
      for (var i = 0; i < 256; ++i) {
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 255 ^ 99;
        SBOX[x] = sx;
        INV_SBOX[sx] = x;
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];
        var t = d[sx] * 257 ^ sx * 16843008;
        SUB_MIX[0][x] = t << 24 | t >>> 8;
        SUB_MIX[1][x] = t << 16 | t >>> 16;
        SUB_MIX[2][x] = t << 8 | t >>> 24;
        SUB_MIX[3][x] = t;
        t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
        INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
        INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
        INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
        INV_SUB_MIX[3][sx] = t;
        if (x === 0) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
      return {
        SBOX,
        INV_SBOX,
        SUB_MIX,
        INV_SUB_MIX
      };
    }();
    function AES(key) {
      this._key = asUInt32Array(key);
      this._reset();
    }
    AES.blockSize = 4 * 4;
    AES.keySize = 256 / 8;
    AES.prototype.blockSize = AES.blockSize;
    AES.prototype.keySize = AES.keySize;
    AES.prototype._reset = function() {
      var keyWords = this._key;
      var keySize = keyWords.length;
      var nRounds = keySize + 6;
      var ksRows = (nRounds + 1) * 4;
      var keySchedule = [];
      for (var k = 0; k < keySize; k++) {
        keySchedule[k] = keyWords[k];
      }
      for (k = keySize; k < ksRows; k++) {
        var t = keySchedule[k - 1];
        if (k % keySize === 0) {
          t = t << 8 | t >>> 24;
          t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
          t ^= RCON[k / keySize | 0] << 24;
        } else if (keySize > 6 && k % keySize === 4) {
          t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
        }
        keySchedule[k] = keySchedule[k - keySize] ^ t;
      }
      var invKeySchedule = [];
      for (var ik = 0; ik < ksRows; ik++) {
        var ksR = ksRows - ik;
        var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
        if (ik < 4 || ksR <= 4) {
          invKeySchedule[ik] = tt;
        } else {
          invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 255]];
        }
      }
      this._nRounds = nRounds;
      this._keySchedule = keySchedule;
      this._invKeySchedule = invKeySchedule;
    };
    AES.prototype.encryptBlockRaw = function(M) {
      M = asUInt32Array(M);
      return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
    };
    AES.prototype.encryptBlock = function(M) {
      var out = this.encryptBlockRaw(M);
      var buf = Buffer3.allocUnsafe(16);
      buf.writeUInt32BE(out[0], 0);
      buf.writeUInt32BE(out[1], 4);
      buf.writeUInt32BE(out[2], 8);
      buf.writeUInt32BE(out[3], 12);
      return buf;
    };
    AES.prototype.decryptBlock = function(M) {
      M = asUInt32Array(M);
      var m1 = M[1];
      M[1] = M[3];
      M[3] = m1;
      var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
      var buf = Buffer3.allocUnsafe(16);
      buf.writeUInt32BE(out[0], 0);
      buf.writeUInt32BE(out[3], 4);
      buf.writeUInt32BE(out[2], 8);
      buf.writeUInt32BE(out[1], 12);
      return buf;
    };
    AES.prototype.scrub = function() {
      scrubVec(this._keySchedule);
      scrubVec(this._invKeySchedule);
      scrubVec(this._key);
    };
    module2.exports.AES = AES;
  }
});

// node_modules/browserify-aes/ghash.js
var require_ghash = __commonJS({
  "node_modules/browserify-aes/ghash.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer3 = require_safe_buffer().Buffer;
    var ZEROES = Buffer3.alloc(16, 0);
    function toArray(buf) {
      return [
        buf.readUInt32BE(0),
        buf.readUInt32BE(4),
        buf.readUInt32BE(8),
        buf.readUInt32BE(12)
      ];
    }
    function fromArray(out) {
      var buf = Buffer3.allocUnsafe(16);
      buf.writeUInt32BE(out[0] >>> 0, 0);
      buf.writeUInt32BE(out[1] >>> 0, 4);
      buf.writeUInt32BE(out[2] >>> 0, 8);
      buf.writeUInt32BE(out[3] >>> 0, 12);
      return buf;
    }
    function GHASH(key) {
      this.h = key;
      this.state = Buffer3.alloc(16, 0);
      this.cache = Buffer3.allocUnsafe(0);
    }
    GHASH.prototype.ghash = function(block) {
      var i = -1;
      while (++i < block.length) {
        this.state[i] ^= block[i];
      }
      this._multiply();
    };
    GHASH.prototype._multiply = function() {
      var Vi = toArray(this.h);
      var Zi = [0, 0, 0, 0];
      var j, xi, lsbVi;
      var i = -1;
      while (++i < 128) {
        xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
        if (xi) {
          Zi[0] ^= Vi[0];
          Zi[1] ^= Vi[1];
          Zi[2] ^= Vi[2];
          Zi[3] ^= Vi[3];
        }
        lsbVi = (Vi[3] & 1) !== 0;
        for (j = 3; j > 0; j--) {
          Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
        }
        Vi[0] = Vi[0] >>> 1;
        if (lsbVi) {
          Vi[0] = Vi[0] ^ 225 << 24;
        }
      }
      this.state = fromArray(Zi);
    };
    GHASH.prototype.update = function(buf) {
      this.cache = Buffer3.concat([this.cache, buf]);
      var chunk;
      while (this.cache.length >= 16) {
        chunk = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        this.ghash(chunk);
      }
    };
    GHASH.prototype.final = function(abl, bl) {
      if (this.cache.length) {
        this.ghash(Buffer3.concat([this.cache, ZEROES], 16));
      }
      this.ghash(fromArray([0, abl, 0, bl]));
      return this.state;
    };
    module2.exports = GHASH;
  }
});

// node_modules/browserify-aes/authCipher.js
var require_authCipher = __commonJS({
  "node_modules/browserify-aes/authCipher.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var aes = require_aes();
    var Buffer3 = require_safe_buffer().Buffer;
    var Transform2 = require_cipher_base();
    var inherits2 = require_inherits_browser();
    var GHASH = require_ghash();
    var xor = require_buffer_xor();
    var incr32 = require_incr32();
    function xorTest(a, b) {
      var out = 0;
      if (a.length !== b.length)
        out++;
      var len = Math.min(a.length, b.length);
      for (var i = 0; i < len; ++i) {
        out += a[i] ^ b[i];
      }
      return out;
    }
    function calcIv(self2, iv, ck) {
      if (iv.length === 12) {
        self2._finID = Buffer3.concat([iv, Buffer3.from([0, 0, 0, 1])]);
        return Buffer3.concat([iv, Buffer3.from([0, 0, 0, 2])]);
      }
      var ghash = new GHASH(ck);
      var len = iv.length;
      var toPad = len % 16;
      ghash.update(iv);
      if (toPad) {
        toPad = 16 - toPad;
        ghash.update(Buffer3.alloc(toPad, 0));
      }
      ghash.update(Buffer3.alloc(8, 0));
      var ivBits = len * 8;
      var tail = Buffer3.alloc(8);
      tail.writeUIntBE(ivBits, 0, 8);
      ghash.update(tail);
      self2._finID = ghash.state;
      var out = Buffer3.from(self2._finID);
      incr32(out);
      return out;
    }
    function StreamCipher(mode, key, iv, decrypt2) {
      Transform2.call(this);
      var h = Buffer3.alloc(4, 0);
      this._cipher = new aes.AES(key);
      var ck = this._cipher.encryptBlock(h);
      this._ghash = new GHASH(ck);
      iv = calcIv(this, iv, ck);
      this._prev = Buffer3.from(iv);
      this._cache = Buffer3.allocUnsafe(0);
      this._secCache = Buffer3.allocUnsafe(0);
      this._decrypt = decrypt2;
      this._alen = 0;
      this._len = 0;
      this._mode = mode;
      this._authTag = null;
      this._called = false;
    }
    inherits2(StreamCipher, Transform2);
    StreamCipher.prototype._update = function(chunk) {
      if (!this._called && this._alen) {
        var rump = 16 - this._alen % 16;
        if (rump < 16) {
          rump = Buffer3.alloc(rump, 0);
          this._ghash.update(rump);
        }
      }
      this._called = true;
      var out = this._mode.encrypt(this, chunk);
      if (this._decrypt) {
        this._ghash.update(chunk);
      } else {
        this._ghash.update(out);
      }
      this._len += chunk.length;
      return out;
    };
    StreamCipher.prototype._final = function() {
      if (this._decrypt && !this._authTag)
        throw new Error("Unsupported state or unable to authenticate data");
      var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
      if (this._decrypt && xorTest(tag, this._authTag))
        throw new Error("Unsupported state or unable to authenticate data");
      this._authTag = tag;
      this._cipher.scrub();
    };
    StreamCipher.prototype.getAuthTag = function getAuthTag() {
      if (this._decrypt || !Buffer3.isBuffer(this._authTag))
        throw new Error("Attempting to get auth tag in unsupported state");
      return this._authTag;
    };
    StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
      if (!this._decrypt)
        throw new Error("Attempting to set auth tag in unsupported state");
      this._authTag = tag;
    };
    StreamCipher.prototype.setAAD = function setAAD(buf) {
      if (this._called)
        throw new Error("Attempting to set AAD in unsupported state");
      this._ghash.update(buf);
      this._alen += buf.length;
    };
    module2.exports = StreamCipher;
  }
});

// node_modules/browserify-aes/streamCipher.js
var require_streamCipher = __commonJS({
  "node_modules/browserify-aes/streamCipher.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var aes = require_aes();
    var Buffer3 = require_safe_buffer().Buffer;
    var Transform2 = require_cipher_base();
    var inherits2 = require_inherits_browser();
    function StreamCipher(mode, key, iv, decrypt2) {
      Transform2.call(this);
      this._cipher = new aes.AES(key);
      this._prev = Buffer3.from(iv);
      this._cache = Buffer3.allocUnsafe(0);
      this._secCache = Buffer3.allocUnsafe(0);
      this._decrypt = decrypt2;
      this._mode = mode;
    }
    inherits2(StreamCipher, Transform2);
    StreamCipher.prototype._update = function(chunk) {
      return this._mode.encrypt(this, chunk, this._decrypt);
    };
    StreamCipher.prototype._final = function() {
      this._cipher.scrub();
    };
    module2.exports = StreamCipher;
  }
});

// node-modules-polyfills-commonjs:events
var require_events = __commonJS({
  "node-modules-polyfills-commonjs:events"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var polyfill = (init_events(), __toCommonJS(events_exports));
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default;
      for (let k in polyfill) {
        module2.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module2.exports = polyfill;
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = require_events().EventEmitter;
  }
});

// node-modules-polyfills-commonjs:util
var require_util = __commonJS({
  "node-modules-polyfills-commonjs:util"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var polyfill = (init_util(), __toCommonJS(util_exports));
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default;
      for (let k in polyfill) {
        module2.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module2.exports = polyfill;
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var _require = require_buffer();
    var Buffer3 = _require.Buffer;
    var _require2 = require_util();
    var inspect3 = _require2.inspect;
    var custom = inspect3 && inspect3.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer3.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList2, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) {
            ret += s + p.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat3(n) {
          if (this.length === 0)
            return Buffer3.alloc(0);
          var ret = Buffer3.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer3.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options2) {
          return inspect3(this, _objectSpread({}, options2, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList2;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/readable-stream/errors-browser.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes3(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes3(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options2, isDuplex, duplexKey) {
      return options2.highWaterMark != null ? options2.highWaterMark : isDuplex ? options2[duplexKey] : null;
    }
    function getHighWaterMark(state, options2, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options2, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/util-deprecate/browser.js
var require_browser2 = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = deprecate2;
    function deprecate2(fn, msg) {
      if (config3("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config3("throwDeprecation")) {
            throw new Error(msg);
          } else if (config3("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config3(name) {
      try {
        if (!globalThis.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val = globalThis.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = Writable2;
    function CorkedRequest2(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex2;
    Writable2.WritableState = WritableState2;
    var internalUtil = {
      deprecate: require_browser2()
    };
    var Stream2 = require_stream_browser();
    var Buffer3 = require_buffer().Buffer;
    var OurUint8Array = globalThis.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable2, Stream2);
    function nop2() {
    }
    function WritableState2(options2, stream, isDuplex) {
      Duplex2 = Duplex2 || require_stream_duplex();
      options2 = options2 || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options2, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options2.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite2(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options2.emitClose !== false;
      this.autoDestroy = !!options2.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest2(this);
    }
    WritableState2.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState2.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable2, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable2)
            return false;
          return object && object._writableState instanceof WritableState2;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable2(options2) {
      Duplex2 = Duplex2 || require_stream_duplex();
      var isDuplex = this instanceof Duplex2;
      if (!isDuplex && !realHasInstance.call(Writable2, this))
        return new Writable2(options2);
      this._writableState = new WritableState2(options2, this, isDuplex);
      this.writable = true;
      if (options2) {
        if (typeof options2.write === "function")
          this._write = options2.write;
        if (typeof options2.writev === "function")
          this._writev = options2.writev;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
        if (typeof options2.final === "function")
          this._final = options2.final;
      }
      Stream2.call(this);
    }
    Writable2.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd2(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk2(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable2.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer3.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop2;
      if (state.ending)
        writeAfterEnd2(this, cb);
      else if (isBuf || validChunk2(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer2(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable2.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable2.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer2(this, state);
      }
    };
    Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk2(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer3.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer2(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk2(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite2(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite2(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError2(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe2, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe2(stream, state);
      }
    }
    function onwriteStateUpdate2(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite2(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate2(state);
      if (er)
        onwriteError2(stream, state, sync, er, cb);
      else {
        var finished = needFinish2(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer2(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite2, stream, state, finished, cb);
        } else {
          afterWrite2(stream, state, finished, cb);
        }
      }
    }
    function afterWrite2(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain2(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe2(stream, state);
    }
    function onwriteDrain2(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer2(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite2(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest2(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite2(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable2.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable2.prototype._writev = null;
    Writable2.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable2(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish2(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe2(stream, state);
      });
    }
    function prefinish2(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe2(stream, state) {
      var need = needFinish2(state);
      if (need) {
        prefinish2(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable2(stream, state, cb) {
      state.ending = true;
      finishMaybe2(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable2.prototype.destroy = destroyImpl.destroy;
    Writable2.prototype._undestroy = destroyImpl.undestroy;
    Writable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var objectKeys = Object.keys || function(obj) {
      var keys3 = [];
      for (var key in obj) {
        keys3.push(key);
      }
      return keys3;
    };
    module2.exports = Duplex2;
    var Readable2 = require_stream_readable();
    var Writable2 = require_stream_writable();
    require_inherits_browser()(Duplex2, Readable2);
    {
      keys2 = objectKeys(Writable2.prototype);
      for (v = 0; v < keys2.length; v++) {
        method = keys2[v];
        if (!Duplex2.prototype[method])
          Duplex2.prototype[method] = Writable2.prototype[method];
      }
    }
    var keys2;
    var method;
    var v;
    function Duplex2(options2) {
      if (!(this instanceof Duplex2))
        return new Duplex2(options2);
      Readable2.call(this, options2);
      Writable2.call(this, options2);
      this.allowHalfOpen = true;
      if (options2) {
        if (options2.readable === false)
          this.readable = false;
        if (options2.writable === false)
          this.writable = false;
        if (options2.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend2);
        }
      }
    }
    Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend2() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT2, this);
    }
    function onEndNT2(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder2 = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer3 = require_safe_buffer().Buffer;
    var isEncoding3 = Buffer3.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding3 || !isEncoding3(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder2;
    function StringDecoder2(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer3.allocUnsafe(nb);
    }
    StringDecoder2.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder2.prototype.end = utf8End;
    StringDecoder2.prototype.text = utf8Text;
    StringDecoder2.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once4(callback2) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback2.apply(this, args);
      };
    }
    function noop3() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback2) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback2 = once4(callback2 || noop3);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback2.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend2 = function onend3() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback2.call(stream);
      };
      var onerror = function onerror2(err) {
        callback2.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback2.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback2.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend2);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend2);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done2) {
      return {
        value,
        done: done2
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = Readable2;
    var Duplex2;
    Readable2.ReadableState = ReadableState2;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream2 = require_stream_browser();
    var Buffer3 = require_buffer().Buffer;
    var OurUint8Array = globalThis.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug2;
    if (debugUtil && debugUtil.debuglog) {
      debug2 = debugUtil.debuglog("stream");
    } else {
      debug2 = function debug3() {
      };
    }
    var BufferList2 = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder2;
    var createReadableStreamAsyncIterator;
    var from5;
    require_inherits_browser()(Readable2, Stream2);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener3(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState2(options2, stream, isDuplex) {
      Duplex2 = Duplex2 || require_stream_duplex();
      options2 = options2 || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options2, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList2();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options2.emitClose !== false;
      this.autoDestroy = !!options2.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options2.encoding) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder2().StringDecoder;
        this.decoder = new StringDecoder2(options2.encoding);
        this.encoding = options2.encoding;
      }
    }
    function Readable2(options2) {
      Duplex2 = Duplex2 || require_stream_duplex();
      if (!(this instanceof Readable2))
        return new Readable2(options2);
      var isDuplex = this instanceof Duplex2;
      this._readableState = new ReadableState2(options2, this, isDuplex);
      this.readable = true;
      if (options2) {
        if (typeof options2.read === "function")
          this._read = options2.read;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer3.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk2(this, chunk, null, true, false);
    };
    function readableAddChunk2(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug2("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk2(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid2(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore2(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore2(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable2(stream);
      }
      maybeReadMore2(stream, state);
    }
    function chunkInvalid2(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder2)
        StringDecoder2 = require_string_decoder2().StringDecoder;
      var decoder = new StringDecoder2(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM2 = 1073741824;
    function computeNewHighWaterMark2(n) {
      if (n >= MAX_HWM2) {
        n = MAX_HWM2;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead2(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark2(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n) {
      debug2("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug2("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable2(this);
        else
          emitReadable2(this);
        return null;
      }
      n = howMuchToRead2(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable2(this);
        return null;
      }
      var doRead = state.needReadable;
      debug2("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug2("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug2("reading or ended", doRead);
      } else if (doRead) {
        debug2("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead2(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList2(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable2(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk2(stream, state) {
      debug2("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable2(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_2(stream);
        }
      }
    }
    function emitReadable2(stream) {
      var state = stream._readableState;
      debug2("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug2("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_2, stream);
      }
    }
    function emitReadable_2(stream) {
      var state = stream._readableState;
      debug2("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow2(stream);
    }
    function maybeReadMore2(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_2, stream, state);
      }
    }
    function maybeReadMore_2(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug2("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend2 : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug2("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend2() {
        debug2("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain2(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug2("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug2("ondata");
        var ret = dest.write(chunk);
        debug2("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf4(state.pipes, dest) !== -1) && !cleanedUp) {
            debug2("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug2("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener3(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug2("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug2("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug2("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain2(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug2("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow2(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf4(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug2("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable2(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick2, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      var res = Stream2.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick2(self2) {
      debug2("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug2("resume");
        state.flowing = !state.readableListening;
        resume2(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume2(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_2, stream, state);
      }
    }
    function resume_2(stream, state) {
      debug2("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow2(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug2("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug2("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow2(stream) {
      var state = stream._readableState;
      debug2("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
        ;
      }
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug2("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug2("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug2("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList2;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList2(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable2(stream) {
      var state = stream._readableState;
      debug2("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT2, state, stream);
      }
    }
    function endReadableNT2(state, stream) {
      debug2("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from5 === void 0) {
          from5 = require_from_browser();
        }
        return from5(Readable2, iterable, opts);
      };
    }
    function indexOf4(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = Transform2;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex2 = require_stream_duplex();
    require_inherits_browser()(Transform2, Duplex2);
    function afterTransform2(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options2) {
      if (!(this instanceof Transform2))
        return new Transform2(options2);
      Duplex2.call(this, options2);
      this._transformState = {
        afterTransform: afterTransform2.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options2) {
        if (typeof options2.transform === "function")
          this._transform = options2.transform;
        if (typeof options2.flush === "function")
          this._flush = options2.flush;
      }
      this.on("prefinish", prefinish2);
    }
    function prefinish2() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done2(_this, er, data);
        });
      } else {
        done2(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex2.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      Duplex2.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done2(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    module2.exports = PassThrough2;
    var Transform2 = require_stream_transform();
    require_inherits_browser()(PassThrough2, Transform2);
    function PassThrough2(options2) {
      if (!(this instanceof PassThrough2))
        return new PassThrough2(options2);
      Transform2.call(this, options2);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var eos;
    function once4(callback2) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback2.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop3(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback2) {
      callback2 = once4(callback2);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback2(err);
        closed = true;
        callback2();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback2(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from5, to) {
      return from5.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop3;
      if (typeof streams[streams.length - 1] !== "function")
        return noop3;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback2 = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback2(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
    exports2.finished = require_end_of_stream();
    exports2.pipeline = require_pipeline();
  }
});

// node_modules/hash-base/index.js
var require_hash_base = __commonJS({
  "node_modules/hash-base/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer3 = require_safe_buffer().Buffer;
    var Transform2 = require_readable_browser().Transform;
    var inherits2 = require_inherits_browser();
    function throwIfNotStringOrBuffer(val, prefix) {
      if (!Buffer3.isBuffer(val) && typeof val !== "string") {
        throw new TypeError(prefix + " must be a string or a buffer");
      }
    }
    function HashBase(blockSize) {
      Transform2.call(this);
      this._block = Buffer3.allocUnsafe(blockSize);
      this._blockSize = blockSize;
      this._blockOffset = 0;
      this._length = [0, 0, 0, 0];
      this._finalized = false;
    }
    inherits2(HashBase, Transform2);
    HashBase.prototype._transform = function(chunk, encoding, callback2) {
      var error = null;
      try {
        this.update(chunk, encoding);
      } catch (err) {
        error = err;
      }
      callback2(error);
    };
    HashBase.prototype._flush = function(callback2) {
      var error = null;
      try {
        this.push(this.digest());
      } catch (err) {
        error = err;
      }
      callback2(error);
    };
    HashBase.prototype.update = function(data, encoding) {
      throwIfNotStringOrBuffer(data, "Data");
      if (this._finalized)
        throw new Error("Digest already called");
      if (!Buffer3.isBuffer(data))
        data = Buffer3.from(data, encoding);
      var block = this._block;
      var offset = 0;
      while (this._blockOffset + data.length - offset >= this._blockSize) {
        for (var i = this._blockOffset; i < this._blockSize; )
          block[i++] = data[offset++];
        this._update();
        this._blockOffset = 0;
      }
      while (offset < data.length)
        block[this._blockOffset++] = data[offset++];
      for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
        this._length[j] += carry;
        carry = this._length[j] / 4294967296 | 0;
        if (carry > 0)
          this._length[j] -= 4294967296 * carry;
      }
      return this;
    };
    HashBase.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    HashBase.prototype.digest = function(encoding) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var digest = this._digest();
      if (encoding !== void 0)
        digest = digest.toString(encoding);
      this._block.fill(0);
      this._blockOffset = 0;
      for (var i = 0; i < 4; ++i)
        this._length[i] = 0;
      return digest;
    };
    HashBase.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    module2.exports = HashBase;
  }
});

// node_modules/md5.js/index.js
var require_md5 = __commonJS({
  "node_modules/md5.js/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var HashBase = require_hash_base();
    var Buffer3 = require_safe_buffer().Buffer;
    var ARRAY16 = new Array(16);
    function MD5() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
    }
    inherits2(MD5, HashBase);
    MD5.prototype._update = function() {
      var M = ARRAY16;
      for (var i = 0; i < 16; ++i)
        M[i] = this._block.readInt32LE(i * 4);
      var a = this._a;
      var b = this._b;
      var c = this._c;
      var d = this._d;
      a = fnF(a, b, c, d, M[0], 3614090360, 7);
      d = fnF(d, a, b, c, M[1], 3905402710, 12);
      c = fnF(c, d, a, b, M[2], 606105819, 17);
      b = fnF(b, c, d, a, M[3], 3250441966, 22);
      a = fnF(a, b, c, d, M[4], 4118548399, 7);
      d = fnF(d, a, b, c, M[5], 1200080426, 12);
      c = fnF(c, d, a, b, M[6], 2821735955, 17);
      b = fnF(b, c, d, a, M[7], 4249261313, 22);
      a = fnF(a, b, c, d, M[8], 1770035416, 7);
      d = fnF(d, a, b, c, M[9], 2336552879, 12);
      c = fnF(c, d, a, b, M[10], 4294925233, 17);
      b = fnF(b, c, d, a, M[11], 2304563134, 22);
      a = fnF(a, b, c, d, M[12], 1804603682, 7);
      d = fnF(d, a, b, c, M[13], 4254626195, 12);
      c = fnF(c, d, a, b, M[14], 2792965006, 17);
      b = fnF(b, c, d, a, M[15], 1236535329, 22);
      a = fnG(a, b, c, d, M[1], 4129170786, 5);
      d = fnG(d, a, b, c, M[6], 3225465664, 9);
      c = fnG(c, d, a, b, M[11], 643717713, 14);
      b = fnG(b, c, d, a, M[0], 3921069994, 20);
      a = fnG(a, b, c, d, M[5], 3593408605, 5);
      d = fnG(d, a, b, c, M[10], 38016083, 9);
      c = fnG(c, d, a, b, M[15], 3634488961, 14);
      b = fnG(b, c, d, a, M[4], 3889429448, 20);
      a = fnG(a, b, c, d, M[9], 568446438, 5);
      d = fnG(d, a, b, c, M[14], 3275163606, 9);
      c = fnG(c, d, a, b, M[3], 4107603335, 14);
      b = fnG(b, c, d, a, M[8], 1163531501, 20);
      a = fnG(a, b, c, d, M[13], 2850285829, 5);
      d = fnG(d, a, b, c, M[2], 4243563512, 9);
      c = fnG(c, d, a, b, M[7], 1735328473, 14);
      b = fnG(b, c, d, a, M[12], 2368359562, 20);
      a = fnH(a, b, c, d, M[5], 4294588738, 4);
      d = fnH(d, a, b, c, M[8], 2272392833, 11);
      c = fnH(c, d, a, b, M[11], 1839030562, 16);
      b = fnH(b, c, d, a, M[14], 4259657740, 23);
      a = fnH(a, b, c, d, M[1], 2763975236, 4);
      d = fnH(d, a, b, c, M[4], 1272893353, 11);
      c = fnH(c, d, a, b, M[7], 4139469664, 16);
      b = fnH(b, c, d, a, M[10], 3200236656, 23);
      a = fnH(a, b, c, d, M[13], 681279174, 4);
      d = fnH(d, a, b, c, M[0], 3936430074, 11);
      c = fnH(c, d, a, b, M[3], 3572445317, 16);
      b = fnH(b, c, d, a, M[6], 76029189, 23);
      a = fnH(a, b, c, d, M[9], 3654602809, 4);
      d = fnH(d, a, b, c, M[12], 3873151461, 11);
      c = fnH(c, d, a, b, M[15], 530742520, 16);
      b = fnH(b, c, d, a, M[2], 3299628645, 23);
      a = fnI(a, b, c, d, M[0], 4096336452, 6);
      d = fnI(d, a, b, c, M[7], 1126891415, 10);
      c = fnI(c, d, a, b, M[14], 2878612391, 15);
      b = fnI(b, c, d, a, M[5], 4237533241, 21);
      a = fnI(a, b, c, d, M[12], 1700485571, 6);
      d = fnI(d, a, b, c, M[3], 2399980690, 10);
      c = fnI(c, d, a, b, M[10], 4293915773, 15);
      b = fnI(b, c, d, a, M[1], 2240044497, 21);
      a = fnI(a, b, c, d, M[8], 1873313359, 6);
      d = fnI(d, a, b, c, M[15], 4264355552, 10);
      c = fnI(c, d, a, b, M[6], 2734768916, 15);
      b = fnI(b, c, d, a, M[13], 1309151649, 21);
      a = fnI(a, b, c, d, M[4], 4149444226, 6);
      d = fnI(d, a, b, c, M[11], 3174756917, 10);
      c = fnI(c, d, a, b, M[2], 718787259, 15);
      b = fnI(b, c, d, a, M[9], 3951481745, 21);
      this._a = this._a + a | 0;
      this._b = this._b + b | 0;
      this._c = this._c + c | 0;
      this._d = this._d + d | 0;
    };
    MD5.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer = Buffer3.allocUnsafe(16);
      buffer.writeInt32LE(this._a, 0);
      buffer.writeInt32LE(this._b, 4);
      buffer.writeInt32LE(this._c, 8);
      buffer.writeInt32LE(this._d, 12);
      return buffer;
    };
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    function fnF(a, b, c, d, m, k, s) {
      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
    }
    function fnG(a, b, c, d, m, k, s) {
      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
    }
    function fnH(a, b, c, d, m, k, s) {
      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
    }
    function fnI(a, b, c, d, m, k, s) {
      return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
    }
    module2.exports = MD5;
  }
});

// node_modules/evp_bytestokey/index.js
var require_evp_bytestokey = __commonJS({
  "node_modules/evp_bytestokey/index.js"(exports2, module2) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer3 = require_safe_buffer().Buffer;
    var MD5 = require_md5();
    function EVP_BytesToKey(password, salt, keyBits, ivLen) {
      if (!Buffer3.isBuffer(password))
        password = Buffer3.from(password, "binary");
      if (salt) {
        if (!Buffer3.isBuffer(salt))
          salt = Buffer3.from(salt, "binary");
        if (salt.length !== 8)
          throw new RangeError("salt should be Buffer with 8 byte length");
      }
      var keyLen = keyBits / 8;
      var key = Buffer3.alloc(keyLen);
      var iv = Buffer3.alloc(ivLen || 0);
      var tmp = Buffer3.alloc(0);
      while (keyLen > 0 || ivLen > 0) {
        var hash = new MD5();
        hash.update(tmp);
        hash.update(password);
        if (salt)
          hash.update(salt);
        tmp = hash.digest();
        var used = 0;
        if (keyLen > 0) {
          var keyStart = key.length - keyLen;
          used = Math.min(keyLen, tmp.length);
          tmp.copy(key, keyStart, 0, used);
          keyLen -= used;
        }
        if (used < tmp.length && ivLen > 0) {
          var ivStart = iv.length - ivLen;
          var length = Math.min(ivLen, tmp.length - used);
          tmp.copy(iv, ivStart, used, used + length);
          ivLen -= length;
        }
      }
      tmp.fill(0);
      return { key, iv };
    }
    module2.exports = EVP_BytesToKey;
  }
});

// node_modules/browserify-aes/encrypter.js
var require_encrypter = __commonJS({
  "node_modules/browserify-aes/encrypter.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var MODES = require_modes();
    var AuthCipher = require_authCipher();
    var Buffer3 = require_safe_buffer().Buffer;
    var StreamCipher = require_streamCipher();
    var Transform2 = require_cipher_base();
    var aes = require_aes();
    var ebtk = require_evp_bytestokey();
    var inherits2 = require_inherits_browser();
    function Cipher(mode, key, iv) {
      Transform2.call(this);
      this._cache = new Splitter();
      this._cipher = new aes.AES(key);
      this._prev = Buffer3.from(iv);
      this._mode = mode;
      this._autopadding = true;
    }
    inherits2(Cipher, Transform2);
    Cipher.prototype._update = function(data) {
      this._cache.add(data);
      var chunk;
      var thing;
      var out = [];
      while (chunk = this._cache.get()) {
        thing = this._mode.encrypt(this, chunk);
        out.push(thing);
      }
      return Buffer3.concat(out);
    };
    var PADDING = Buffer3.alloc(16, 16);
    Cipher.prototype._final = function() {
      var chunk = this._cache.flush();
      if (this._autopadding) {
        chunk = this._mode.encrypt(this, chunk);
        this._cipher.scrub();
        return chunk;
      }
      if (!chunk.equals(PADDING)) {
        this._cipher.scrub();
        throw new Error("data not multiple of block length");
      }
    };
    Cipher.prototype.setAutoPadding = function(setTo) {
      this._autopadding = !!setTo;
      return this;
    };
    function Splitter() {
      this.cache = Buffer3.allocUnsafe(0);
    }
    Splitter.prototype.add = function(data) {
      this.cache = Buffer3.concat([this.cache, data]);
    };
    Splitter.prototype.get = function() {
      if (this.cache.length > 15) {
        var out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
      }
      return null;
    };
    Splitter.prototype.flush = function() {
      var len = 16 - this.cache.length;
      var padBuff = Buffer3.allocUnsafe(len);
      var i = -1;
      while (++i < len) {
        padBuff.writeUInt8(len, i);
      }
      return Buffer3.concat([this.cache, padBuff]);
    };
    function createCipheriv2(suite, password, iv) {
      var config3 = MODES[suite.toLowerCase()];
      if (!config3)
        throw new TypeError("invalid suite type");
      if (typeof password === "string")
        password = Buffer3.from(password);
      if (password.length !== config3.key / 8)
        throw new TypeError("invalid key length " + password.length);
      if (typeof iv === "string")
        iv = Buffer3.from(iv);
      if (config3.mode !== "GCM" && iv.length !== config3.iv)
        throw new TypeError("invalid iv length " + iv.length);
      if (config3.type === "stream") {
        return new StreamCipher(config3.module, password, iv);
      } else if (config3.type === "auth") {
        return new AuthCipher(config3.module, password, iv);
      }
      return new Cipher(config3.module, password, iv);
    }
    function createCipher(suite, password) {
      var config3 = MODES[suite.toLowerCase()];
      if (!config3)
        throw new TypeError("invalid suite type");
      var keys2 = ebtk(password, false, config3.key, config3.iv);
      return createCipheriv2(suite, keys2.key, keys2.iv);
    }
    exports2.createCipheriv = createCipheriv2;
    exports2.createCipher = createCipher;
  }
});

// node_modules/browserify-aes/decrypter.js
var require_decrypter = __commonJS({
  "node_modules/browserify-aes/decrypter.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var AuthCipher = require_authCipher();
    var Buffer3 = require_safe_buffer().Buffer;
    var MODES = require_modes();
    var StreamCipher = require_streamCipher();
    var Transform2 = require_cipher_base();
    var aes = require_aes();
    var ebtk = require_evp_bytestokey();
    var inherits2 = require_inherits_browser();
    function Decipher(mode, key, iv) {
      Transform2.call(this);
      this._cache = new Splitter();
      this._last = void 0;
      this._cipher = new aes.AES(key);
      this._prev = Buffer3.from(iv);
      this._mode = mode;
      this._autopadding = true;
    }
    inherits2(Decipher, Transform2);
    Decipher.prototype._update = function(data) {
      this._cache.add(data);
      var chunk;
      var thing;
      var out = [];
      while (chunk = this._cache.get(this._autopadding)) {
        thing = this._mode.decrypt(this, chunk);
        out.push(thing);
      }
      return Buffer3.concat(out);
    };
    Decipher.prototype._final = function() {
      var chunk = this._cache.flush();
      if (this._autopadding) {
        return unpad(this._mode.decrypt(this, chunk));
      } else if (chunk) {
        throw new Error("data not multiple of block length");
      }
    };
    Decipher.prototype.setAutoPadding = function(setTo) {
      this._autopadding = !!setTo;
      return this;
    };
    function Splitter() {
      this.cache = Buffer3.allocUnsafe(0);
    }
    Splitter.prototype.add = function(data) {
      this.cache = Buffer3.concat([this.cache, data]);
    };
    Splitter.prototype.get = function(autoPadding) {
      var out;
      if (autoPadding) {
        if (this.cache.length > 16) {
          out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
      } else {
        if (this.cache.length >= 16) {
          out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
      }
      return null;
    };
    Splitter.prototype.flush = function() {
      if (this.cache.length)
        return this.cache;
    };
    function unpad(last) {
      var padded = last[15];
      if (padded < 1 || padded > 16) {
        throw new Error("unable to decrypt data");
      }
      var i = -1;
      while (++i < padded) {
        if (last[i + (16 - padded)] !== padded) {
          throw new Error("unable to decrypt data");
        }
      }
      if (padded === 16)
        return;
      return last.slice(0, 16 - padded);
    }
    function createDecipheriv2(suite, password, iv) {
      var config3 = MODES[suite.toLowerCase()];
      if (!config3)
        throw new TypeError("invalid suite type");
      if (typeof iv === "string")
        iv = Buffer3.from(iv);
      if (config3.mode !== "GCM" && iv.length !== config3.iv)
        throw new TypeError("invalid iv length " + iv.length);
      if (typeof password === "string")
        password = Buffer3.from(password);
      if (password.length !== config3.key / 8)
        throw new TypeError("invalid key length " + password.length);
      if (config3.type === "stream") {
        return new StreamCipher(config3.module, password, iv, true);
      } else if (config3.type === "auth") {
        return new AuthCipher(config3.module, password, iv, true);
      }
      return new Decipher(config3.module, password, iv);
    }
    function createDecipher(suite, password) {
      var config3 = MODES[suite.toLowerCase()];
      if (!config3)
        throw new TypeError("invalid suite type");
      var keys2 = ebtk(password, false, config3.key, config3.iv);
      return createDecipheriv2(suite, keys2.key, keys2.iv);
    }
    exports2.createDecipher = createDecipher;
    exports2.createDecipheriv = createDecipheriv2;
  }
});

// node_modules/browserify-aes/browser.js
var require_browser3 = __commonJS({
  "node_modules/browserify-aes/browser.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var ciphers = require_encrypter();
    var deciphers = require_decrypter();
    var modes = require_list();
    function getCiphers() {
      return Object.keys(modes);
    }
    exports2.createCipher = exports2.Cipher = ciphers.createCipher;
    exports2.createCipheriv = exports2.Cipheriv = ciphers.createCipheriv;
    exports2.createDecipher = exports2.Decipher = deciphers.createDecipher;
    exports2.createDecipheriv = exports2.Decipheriv = deciphers.createDecipheriv;
    exports2.listCiphers = exports2.getCiphers = getCiphers;
  }
});

// node_modules/browserify-des/modes.js
var require_modes2 = __commonJS({
  "node_modules/browserify-des/modes.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    exports2["des-ecb"] = {
      key: 8,
      iv: 0
    };
    exports2["des-cbc"] = exports2.des = {
      key: 8,
      iv: 8
    };
    exports2["des-ede3-cbc"] = exports2.des3 = {
      key: 24,
      iv: 8
    };
    exports2["des-ede3"] = {
      key: 24,
      iv: 0
    };
    exports2["des-ede-cbc"] = {
      key: 16,
      iv: 8
    };
    exports2["des-ede"] = {
      key: 16,
      iv: 0
    };
  }
});

// node_modules/browserify-cipher/browser.js
var require_browser4 = __commonJS({
  "node_modules/browserify-cipher/browser.js"(exports2) {
    "use strict";
    init_process();
    init_buffer();
    var DES = require_browserify_des();
    var aes = require_browser3();
    var aesModes = require_modes();
    var desModes = require_modes2();
    var ebtk = require_evp_bytestokey();
    function createCipher(suite, password) {
      suite = suite.toLowerCase();
      var keyLen, ivLen;
      if (aesModes[suite]) {
        keyLen = aesModes[suite].key;
        ivLen = aesModes[suite].iv;
      } else if (desModes[suite]) {
        keyLen = desModes[suite].key * 8;
        ivLen = desModes[suite].iv;
      } else {
        throw new TypeError("invalid suite type");
      }
      var keys2 = ebtk(password, false, keyLen, ivLen);
      return createCipheriv2(suite, keys2.key, keys2.iv);
    }
    function createDecipher(suite, password) {
      suite = suite.toLowerCase();
      var keyLen, ivLen;
      if (aesModes[suite]) {
        keyLen = aesModes[suite].key;
        ivLen = aesModes[suite].iv;
      } else if (desModes[suite]) {
        keyLen = desModes[suite].key * 8;
        ivLen = desModes[suite].iv;
      } else {
        throw new TypeError("invalid suite type");
      }
      var keys2 = ebtk(password, false, keyLen, ivLen);
      return createDecipheriv2(suite, keys2.key, keys2.iv);
    }
    function createCipheriv2(suite, key, iv) {
      suite = suite.toLowerCase();
      if (aesModes[suite])
        return aes.createCipheriv(suite, key, iv);
      if (desModes[suite])
        return new DES({ key, iv, mode: suite });
      throw new TypeError("invalid suite type");
    }
    function createDecipheriv2(suite, key, iv) {
      suite = suite.toLowerCase();
      if (aesModes[suite])
        return aes.createDecipheriv(suite, key, iv);
      if (desModes[suite])
        return new DES({ key, iv, mode: suite, decrypt: true });
      throw new TypeError("invalid suite type");
    }
    function getCiphers() {
      return Object.keys(desModes).concat(aes.getCiphers());
    }
    exports2.createCipher = exports2.Cipher = createCipher;
    exports2.createCipheriv = exports2.Cipheriv = createCipheriv2;
    exports2.createDecipher = exports2.Decipher = createDecipher;
    exports2.createDecipheriv = exports2.Decipheriv = createDecipheriv2;
    exports2.listCiphers = exports2.getCiphers = getCiphers;
  }
});

// src/index.ts
init_process();
init_buffer();

// src/abis/system.json
var system_default = {
  source: {
    hash: "0x4704b2819307adbe67d6b5116174cf6543a959ad8654b34d609b31abd67ac59e",
    language: "ink! 4.2.0",
    compiler: "rustc 1.69.0",
    build_info: {
      build_mode: "Debug",
      cargo_contract_version: "2.2.0",
      rust_toolchain: "stable-x86_64-unknown-linux-gnu",
      wasm_opt_settings: {
        keep_debug_symbols: false,
        optimization_passes: "Z"
      }
    }
  },
  contract: {
    name: "system",
    version: "1.0.0",
    authors: [
      "[your_name] <[your_email]>"
    ]
  },
  spec: {
    constructors: [
      {
        args: [],
        default: false,
        docs: [],
        label: "default",
        payable: false,
        returnType: {
          displayName: [
            "ink_primitives",
            "ConstructorResult"
          ],
          type: 7
        },
        selector: "0xed4b9d1b"
      }
    ],
    docs: [],
    environment: {
      accountId: {
        displayName: [
          "AccountId"
        ],
        type: 0
      },
      balance: {
        displayName: [
          "Balance"
        ],
        type: 24
      },
      blockNumber: {
        displayName: [
          "BlockNumber"
        ],
        type: 4
      },
      chainExtension: {
        displayName: [
          "ChainExtension"
        ],
        type: 39
      },
      hash: {
        displayName: [
          "Hash"
        ],
        type: 31
      },
      maxEventTopics: 4,
      timestamp: {
        displayName: [
          "Timestamp"
        ],
        type: 22
      }
    },
    events: [
      {
        args: [
          {
            docs: [],
            indexed: true,
            label: "name",
            type: {
              displayName: [
                "String"
              ],
              type: 16
            }
          },
          {
            docs: [],
            indexed: false,
            label: "previous",
            type: {
              displayName: [
                "Option"
              ],
              type: 18
            }
          },
          {
            docs: [],
            indexed: false,
            label: "current",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        docs: [
          "A new driver is set."
        ],
        label: "DriverChanged"
      },
      {
        args: [
          {
            docs: [],
            indexed: false,
            label: "user",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        docs: [
          "A new administrator is added."
        ],
        label: "AdministratorAdded"
      }
    ],
    lang_error: {
      displayName: [
        "ink",
        "LangError"
      ],
      type: 8
    },
    messages: [
      {
        args: [],
        default: false,
        docs: [],
        label: "owner",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 9
        },
        selector: "0xfeaea4fa"
      },
      {
        args: [],
        default: false,
        docs: [],
        label: "System::version",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 10
        },
        selector: "0x87c98a8d"
      },
      {
        args: [
          {
            label: "contract_id",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::grant_admin",
        mutates: true,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0x67612061"
      },
      {
        args: [
          {
            label: "name",
            type: {
              displayName: [
                "String"
              ],
              type: 16
            }
          },
          {
            label: "contract_id",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::set_driver",
        mutates: true,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0xaa1e2030"
      },
      {
        args: [
          {
            label: "name",
            type: {
              displayName: [
                "String"
              ],
              type: 16
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::get_driver",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 17
        },
        selector: "0x2740cf0a"
      },
      {
        args: [
          {
            label: "name",
            type: {
              displayName: [
                "String"
              ],
              type: 16
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::get_driver2",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 19
        },
        selector: "0xc0f28223"
      },
      {
        args: [
          {
            label: "contract_id",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          },
          {
            label: "code_hash",
            type: {
              displayName: [
                "pink",
                "Hash"
              ],
              type: 1
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::deploy_sidevm_to",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0x662f4aa4"
      },
      {
        args: [
          {
            label: "contract_id",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::stop_sidevm_at",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0x52a0fd6a"
      },
      {
        args: [
          {
            label: "hook",
            type: {
              displayName: [
                "HookPoint"
              ],
              type: 21
            }
          },
          {
            label: "contract",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          },
          {
            label: "selector",
            type: {
              displayName: [
                "u32"
              ],
              type: 4
            }
          },
          {
            label: "gas_limit",
            type: {
              displayName: [
                "u64"
              ],
              type: 22
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::set_hook",
        mutates: true,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0x352c6b5c"
      },
      {
        args: [
          {
            label: "contract_id",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          },
          {
            label: "weight",
            type: {
              displayName: [
                "u32"
              ],
              type: 4
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::set_contract_weight",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0x45ec9b18"
      },
      {
        args: [
          {
            label: "account",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::total_balance_of",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 23
        },
        selector: "0x5a98f226"
      },
      {
        args: [
          {
            label: "account",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::free_balance_of",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 23
        },
        selector: "0x8a0d40d7"
      },
      {
        args: [
          {
            label: "contract_id",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::is_admin",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 25
        },
        selector: "0xf06f050a"
      },
      {
        args: [],
        default: false,
        docs: [],
        label: "System::upgrade_system_contract",
        mutates: true,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0xaf69ca03"
      },
      {
        args: [
          {
            label: "from_version",
            type: {
              displayName: [
                "VersionTuple"
              ],
              type: 11
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::do_upgrade",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0x667e0041"
      },
      {
        args: [
          {
            label: "version",
            type: {
              displayName: [],
              type: 27
            }
          }
        ],
        default: false,
        docs: [
          " Upgrade the contract runtime",
          "",
          " Be careful when using this function, it would panic the worker if the",
          " runtime version is not supported."
        ],
        label: "System::upgrade_runtime",
        mutates: true,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0x317f6bf3"
      },
      {
        args: [
          {
            label: "code_hash",
            type: {
              displayName: [],
              type: 1
            }
          },
          {
            label: "code_type",
            type: {
              displayName: [
                "CodeType"
              ],
              type: 28
            }
          }
        ],
        default: false,
        docs: [
          " Check if the code is already uploaded to the cluster with given code hash."
        ],
        label: "System::code_exists",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 25
        },
        selector: "0x6fc58436"
      },
      {
        args: [
          {
            label: "account",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::code_hash",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 29
        },
        selector: "0x916fdb44"
      },
      {
        args: [
          {
            label: "name",
            type: {
              displayName: [
                "String"
              ],
              type: 16
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::driver_history",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 32
        },
        selector: "0xd519dbec"
      },
      {
        args: [],
        default: false,
        docs: [],
        label: "System::current_event_chain_head",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 34
        },
        selector: "0xe14655d3"
      },
      {
        args: [
          {
            label: "contract_id",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          },
          {
            label: "deposit",
            type: {
              displayName: [
                "Balance"
              ],
              type: 24
            }
          }
        ],
        default: false,
        docs: [],
        label: "ContractDeposit::change_deposit",
        mutates: true,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 36
        },
        selector: "0xa24bcb44"
      }
    ]
  },
  storage: {
    root: {
      layout: {
        struct: {
          fields: [
            {
              layout: {
                leaf: {
                  key: "0x00000000",
                  ty: 0
                }
              },
              name: "owner"
            },
            {
              layout: {
                root: {
                  layout: {
                    leaf: {
                      key: "0x11ab091d",
                      ty: 3
                    }
                  },
                  root_key: "0x11ab091d"
                }
              },
              name: "administrators"
            },
            {
              layout: {
                root: {
                  layout: {
                    leaf: {
                      key: "0xe69daeed",
                      ty: 0
                    }
                  },
                  root_key: "0xe69daeed"
                }
              },
              name: "drivers"
            },
            {
              layout: {
                root: {
                  layout: {
                    struct: {
                      fields: [
                        {
                          layout: {
                            leaf: {
                              key: "0xae67f833",
                              ty: 4
                            }
                          },
                          name: "0"
                        },
                        {
                          layout: {
                            leaf: {
                              key: "0xae67f833",
                              ty: 0
                            }
                          },
                          name: "1"
                        }
                      ],
                      name: "(A, B)"
                    }
                  },
                  root_key: "0xae67f833"
                }
              },
              name: "drivers2"
            },
            {
              layout: {
                root: {
                  layout: {
                    leaf: {
                      key: "0xd2232fce",
                      ty: 5
                    }
                  },
                  root_key: "0xd2232fce"
                }
              },
              name: "drivers_history"
            }
          ],
          name: "System"
        }
      },
      root_key: "0x00000000"
    }
  },
  types: [
    {
      id: 0,
      type: {
        def: {
          composite: {
            fields: [
              {
                type: 1,
                typeName: "[u8; 32]"
              }
            ]
          }
        },
        path: [
          "ink_primitives",
          "types",
          "AccountId"
        ]
      }
    },
    {
      id: 1,
      type: {
        def: {
          array: {
            len: 32,
            type: 2
          }
        }
      }
    },
    {
      id: 2,
      type: {
        def: {
          primitive: "u8"
        }
      }
    },
    {
      id: 3,
      type: {
        def: {
          tuple: []
        }
      }
    },
    {
      id: 4,
      type: {
        def: {
          primitive: "u32"
        }
      }
    },
    {
      id: 5,
      type: {
        def: {
          sequence: {
            type: 6
          }
        }
      }
    },
    {
      id: 6,
      type: {
        def: {
          tuple: [
            4,
            0
          ]
        }
      }
    },
    {
      id: 7,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 3
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 3
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 8,
      type: {
        def: {
          variant: {
            variants: [
              {
                index: 1,
                name: "CouldNotReadInput"
              }
            ]
          }
        },
        path: [
          "ink_primitives",
          "LangError"
        ]
      }
    },
    {
      id: 9,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 0
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 0
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 10,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 11
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 11
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 11,
      type: {
        def: {
          tuple: [
            12,
            12,
            12
          ]
        }
      }
    },
    {
      id: 12,
      type: {
        def: {
          primitive: "u16"
        }
      }
    },
    {
      id: 13,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 14
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 14
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 14,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 3
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 15
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 3
          },
          {
            name: "E",
            type: 15
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 15,
      type: {
        def: {
          variant: {
            variants: [
              {
                index: 0,
                name: "PermisionDenied"
              },
              {
                index: 1,
                name: "DriverNotFound"
              },
              {
                index: 2,
                name: "CodeNotFound"
              },
              {
                index: 3,
                name: "ConditionNotMet"
              }
            ]
          }
        },
        path: [
          "pink_extension",
          "system",
          "Error"
        ]
      }
    },
    {
      id: 16,
      type: {
        def: {
          primitive: "str"
        }
      }
    },
    {
      id: 17,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 18
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 18
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 18,
      type: {
        def: {
          variant: {
            variants: [
              {
                index: 0,
                name: "None"
              },
              {
                fields: [
                  {
                    type: 0
                  }
                ],
                index: 1,
                name: "Some"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 0
          }
        ],
        path: [
          "Option"
        ]
      }
    },
    {
      id: 19,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 20
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 20
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 20,
      type: {
        def: {
          variant: {
            variants: [
              {
                index: 0,
                name: "None"
              },
              {
                fields: [
                  {
                    type: 6
                  }
                ],
                index: 1,
                name: "Some"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 6
          }
        ],
        path: [
          "Option"
        ]
      }
    },
    {
      id: 21,
      type: {
        def: {
          variant: {
            variants: [
              {
                index: 0,
                name: "OnBlockEnd"
              }
            ]
          }
        },
        path: [
          "pink_extension",
          "HookPoint"
        ]
      }
    },
    {
      id: 22,
      type: {
        def: {
          primitive: "u64"
        }
      }
    },
    {
      id: 23,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 24
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 24
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 24,
      type: {
        def: {
          primitive: "u128"
        }
      }
    },
    {
      id: 25,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 26
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 26
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 26,
      type: {
        def: {
          primitive: "bool"
        }
      }
    },
    {
      id: 27,
      type: {
        def: {
          tuple: [
            4,
            4
          ]
        }
      }
    },
    {
      id: 28,
      type: {
        def: {
          variant: {
            variants: [
              {
                index: 0,
                name: "Ink"
              },
              {
                index: 1,
                name: "Sidevm"
              }
            ]
          }
        },
        path: [
          "pink_extension",
          "system",
          "CodeType"
        ]
      }
    },
    {
      id: 29,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 30
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 30
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 30,
      type: {
        def: {
          variant: {
            variants: [
              {
                index: 0,
                name: "None"
              },
              {
                fields: [
                  {
                    type: 31
                  }
                ],
                index: 1,
                name: "Some"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 31
          }
        ],
        path: [
          "Option"
        ]
      }
    },
    {
      id: 31,
      type: {
        def: {
          composite: {
            fields: [
              {
                type: 1,
                typeName: "[u8; 32]"
              }
            ]
          }
        },
        path: [
          "ink_primitives",
          "types",
          "Hash"
        ]
      }
    },
    {
      id: 32,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 33
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 33
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 33,
      type: {
        def: {
          variant: {
            variants: [
              {
                index: 0,
                name: "None"
              },
              {
                fields: [
                  {
                    type: 5
                  }
                ],
                index: 1,
                name: "Some"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 5
          }
        ],
        path: [
          "Option"
        ]
      }
    },
    {
      id: 34,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 35
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 35
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 35,
      type: {
        def: {
          tuple: [
            22,
            1
          ]
        }
      }
    },
    {
      id: 36,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 37
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 37
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 37,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 3
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 38
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 3
          },
          {
            name: "E",
            type: 38
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 38,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 16,
                    typeName: "String"
                  }
                ],
                index: 0,
                name: "Other"
              },
              {
                fields: [
                  {
                    type: 15,
                    typeName: "Error"
                  }
                ],
                index: 1,
                name: "SystemError"
              },
              {
                index: 2,
                name: "BadOrigin"
              }
            ]
          }
        },
        path: [
          "pink_extension",
          "system",
          "DriverError"
        ]
      }
    },
    {
      id: 39,
      type: {
        def: {
          variant: {}
        },
        path: [
          "pink_extension",
          "chain_extension",
          "PinkExt"
        ]
      }
    }
  ],
  version: "4"
};

// src/index.ts
var import_proto4 = __toESM(require_proto());

// src/utils/hex.ts
init_process();
init_buffer();
var import_randombytes = __toESM(require_browser());
var randomHex = (size = 12) => (0, import_randombytes.default)(size).toString("hex");

// src/pruntime/certificate.ts
init_process();
init_buffer();
import { hexAddPrefix, hexToU8a as hexToU8a2, u8aToHex as u8aToHex2 } from "@polkadot/util";
import { cryptoWaitReady, decodeAddress, sr25519PairFromSeed } from "@polkadot/util-crypto";
import { signTypedData } from "viem/wallet";

// src/options.ts
init_process();
init_buffer();
import { TypeRegistry, typeDefinitions } from "@polkadot/types";
import SubstrateLookupTypes from "@polkadot/types-augment/lookup/substrate";
var types = {
  ContractId: "H256",
  EcdhPublicKey: "SpCoreSr25519Public",
  ContractQueryHead: {
    id: "ContractId",
    nonce: "[u8; 32]"
  },
  CertificateBody: {
    pubkey: "Vec<u8>",
    ttl: "u32",
    config_bits: "u32"
  },
  EncryptedData: {
    iv: "[u8; 12]",
    pubkey: "EcdhPublicKey",
    data: "Vec<u8>"
  },
  CommandPayload: {
    _enum: {
      Plain: "InkCommand",
      Encrypted: "EncryptedData"
    }
  },
  InkQueryData: {
    _enum: {
      InkMessage: {
        payload: "Vec<u8>",
        deposit: "u128",
        transfer: "u128",
        estimating: "bool"
      },
      SidevmMessage: "Vec<u8>",
      InkInstantiate: {
        codeHash: "H256",
        salt: "Vec<u8>",
        instantiateData: "Vec<u8>",
        deposit: "u128",
        transfer: "u128"
      }
    }
  },
  InkQuery: {
    head: "ContractQueryHead",
    data: "InkQueryData"
  },
  InkQueryError: {
    _enum: {
      BadOrigin: null,
      RuntimeError: "String",
      SidevmNotFound: null,
      NoResponse: null,
      ServiceUnavailable: null,
      Timeout: null
    }
  },
  InkQueryOk: {
    _enum: {
      InkMessageReturn: "Vec<u8>"
    }
  },
  InkResponse: {
    nonce: "[u8; 32]",
    result: "Result<InkQueryOk, InkQueryError>"
  },
  InkMessage: {
    nonce: "Vec<u8>",
    message: "Vec<u8>",
    transfer: "u128",
    gasLimit: "u64",
    storageDepositLimit: "Option<u128>"
  },
  InkCommand: { _enum: { InkMessage: "InkMessage" } },
  ContractError: {
    _enum: {
      InvalidScheduleVersion: null,
      InvalidCallFlags: null,
      OutOfGas: null,
      OutputBufferTooSmall: null,
      TransferFailed: null,
      MaxCallDepthReached: null,
      ContractNotFound: null,
      CodeTooLarge: null,
      CodeNotFound: null,
      OutOfBounds: null,
      DecodingFailed: null,
      ContractTrapped: null,
      ValueTooLarge: null,
      TerminatedWhileReentrant: null,
      InputForwarded: null,
      RandomSubjectTooLong: null,
      TooManyTopics: null,
      NoChainExtension: null,
      DuplicateContract: null,
      TerminatedInConstructor: null,
      ReentranceDenied: null,
      StorageDepositNotEnoughFunds: null,
      StorageDepositLimitExhausted: null,
      CodeInUse: null,
      ContractReverted: null,
      CodeRejected: null,
      Indeterministic: null
    }
  }
};
var phalaRegistryTypes = { ...types, ...typeDefinitions, ...SubstrateLookupTypes };
var phalaTypes = new TypeRegistry();
phalaTypes.register(phalaRegistryTypes);
function options(options2 = {}) {
  return {
    ...options2,
    types: {
      ...phalaRegistryTypes,
      ...options2.types || {}
    }
  };
}

// src/pruntime/certificate.ts
var import_proto = __toESM(require_proto());

// src/pruntime/eip712.ts
init_process();
init_buffer();
import { hexToU8a, u8aToHex } from "@polkadot/util";
import { blake2AsU8a, encodeAddress, secp256k1Compress } from "@polkadot/util-crypto";
import { hashMessage, recoverPublicKey } from "viem";
import { signMessage } from "viem/wallet";
var SALT = "0x0ea813d1592526d672ea2576d7a07914cef2ca301b35c5eed941f7c897512a00";
async function etherAddressToCompactPubkey(client, account) {
  const msg = "0x48656c6c6f";
  const sign = await signMessage(client, { account, message: msg });
  const hash = hashMessage(msg);
  const recovered = await recoverPublicKey({ hash, signature: sign });
  const compactPubkey = u8aToHex(secp256k1Compress(hexToU8a(recovered)));
  return compactPubkey;
}
async function etherAddressToSubstrateAddress(client, account) {
  const compactPubkey = await etherAddressToCompactPubkey(client, account);
  const substratePubkey = encodeAddress(blake2AsU8a(hexToU8a(compactPubkey)), 42);
  return substratePubkey;
}
function createEip712StructedDataSignCertificate(account, encodedCert, ttl) {
  return {
    domain: {
      name: "Phat Query Certificate",
      version: "1",
      salt: SALT
    },
    message: {
      description: "You are signing a Certificate that can be used to query Phat Contracts using your identity without further prompts.",
      timeToLive: `The Certificate will be valid till block ${ttl}.`,
      encodedCert
    },
    primaryType: "IssueQueryCertificate",
    types: {
      EIP712Domain: [
        { name: "name", type: "string" },
        { name: "version", type: "string" },
        { name: "salt", type: "bytes32" }
      ],
      IssueQueryCertificate: [
        { name: "description", type: "string" },
        { name: "timeToLive", type: "string" },
        { name: "encodedCert", type: "bytes" }
      ]
    },
    account
  };
}
function createEip712StructedDataSignQuery(account, encodedQuery) {
  return {
    domain: {
      name: "Phat Contract Query",
      version: "1",
      salt: SALT
    },
    message: {
      description: "You are signing a query request that would be sent to a Phat Contract.",
      encodedQuery
    },
    primaryType: "PhatContractQuery",
    types: {
      EIP712Domain: [
        { name: "name", type: "string" },
        { name: "version", type: "string" },
        { name: "salt", type: "bytes32" }
      ],
      PhatContractQuery: [
        { name: "description", type: "string" },
        { name: "encodedQuery", type: "bytes" }
      ]
    },
    account
  };
}

// src/pruntime/certificate.ts
var isUsingSigner = (params) => params.signer !== void 0;
function generatePair() {
  const generatedSeed = hexToU8a2(hexAddPrefix(randomHex(32)));
  const generatedPair = sr25519PairFromSeed(generatedSeed);
  return [generatedPair.secretKey, generatedPair.publicKey];
}
function getSignatureTypeFromAccount(account) {
  const keypairType = account.type || "sr25519";
  switch (keypairType) {
    case "sr25519":
      return import_proto.pruntime_rpc.SignatureType.Sr25519WrapBytes;
    case "ed25519":
      return import_proto.pruntime_rpc.SignatureType.Ed25519WrapBytes;
    case "ecdsa":
      return import_proto.pruntime_rpc.SignatureType.EcdsaWrapBytes;
  }
}
function getSignatureTypeFromPair(pair) {
  switch (pair.type) {
    case "sr25519":
      return import_proto.pruntime_rpc.SignatureType.Sr25519;
    case "ed25519":
      return import_proto.pruntime_rpc.SignatureType.Ed25519;
    case "ecdsa":
      return import_proto.pruntime_rpc.SignatureType.Ecdsa;
    default:
      throw new Error("Unsupported keypair type");
  }
}
function CertificateBody(pubkey, ttl, config_bits = 0) {
  const created = phalaTypes.createType("CertificateBody", { pubkey, ttl, config_bits });
  return created.toU8a();
}
async function signCertificate(params) {
  var _a;
  await cryptoWaitReady();
  if (params.api) {
    console.warn(
      "signCertificate not longer need pass the ApiPromise as parameter, it will remove from type hint in the next."
    );
  }
  if (!(params.signer && params.account || params.pair)) {
    throw new Error(
      "signCertificate: invalid parameters. Please check document for more information: https://www.npmjs.com/package/@phala/sdk"
    );
  }
  let { signatureType } = params;
  const ttl = params.ttl || 2147483647;
  const [secret, pubkey] = generatePair();
  const encodedCertificateBody = CertificateBody(u8aToHex2(pubkey), ttl);
  let signerPubkey;
  let signature;
  let address;
  if (isUsingSigner(params)) {
    const { account, signer } = params;
    address = account.address;
    signerPubkey = u8aToHex2(decodeAddress(address));
    if (!signatureType) {
      signatureType = getSignatureTypeFromAccount(account);
    }
    const signerResult = await ((_a = signer.signRaw) == null ? void 0 : _a.call(signer, {
      address,
      data: u8aToHex2(encodedCertificateBody),
      type: "bytes"
    }));
    if (signerResult) {
      signature = hexToU8a2(signerResult.signature);
    } else {
      throw new Error("Failed to sign certificate");
    }
  } else {
    const { pair } = params;
    address = pair.address;
    signerPubkey = u8aToHex2(pair.publicKey);
    if (!signatureType) {
      signatureType = getSignatureTypeFromPair(pair);
    }
    signature = pair.sign(encodedCertificateBody);
  }
  const certificate = {
    encodedBody: encodedCertificateBody,
    signature: {
      signedBy: {
        encodedBody: CertificateBody(signerPubkey, ttl),
        signature: null
      },
      signatureType,
      signature
    }
  };
  return { address, certificate, pubkey, secret };
}
async function unstable_signEip712Certificate({
  client,
  account,
  compactPubkey,
  ttl = 2147483647
}) {
  await cryptoWaitReady();
  const [secret, pubkey] = generatePair();
  const address = account.address || account;
  const eip712Cert = CertificateBody(u8aToHex2(pubkey), ttl);
  const signature = await signTypedData(
    client,
    createEip712StructedDataSignCertificate(account, u8aToHex2(eip712Cert), ttl)
  );
  const rootCert = CertificateBody(compactPubkey, ttl);
  const certificate = {
    encodedBody: eip712Cert,
    signature: {
      signedBy: {
        encodedBody: rootCert,
        signature: null
      },
      signatureType: import_proto.pruntime_rpc.SignatureType.Eip712,
      signature: hexToU8a2(signature)
    }
  };
  return { address, certificate, pubkey, secret };
}

// src/contracts/PinkCode.ts
init_process();
init_buffer();
import { SubmittableResult as SubmittableResult2, toPromiseMethod as toPromiseMethod3 } from "@polkadot/api";
import { Abi as Abi3 } from "@polkadot/api-contract/Abi";
import { hexToU8a as hexToU8a8, isU8a, isWasm, u8aToHex as u8aToHex5 } from "@polkadot/util";

// src/contracts/PinkBlueprint.ts
init_process();
init_buffer();
import { SubmittableResult, toPromiseMethod as toPromiseMethod2 } from "@polkadot/api";
import { Abi as Abi2 } from "@polkadot/api-contract/Abi";
import { createBluePrintTx, withMeta as withMeta2 } from "@polkadot/api-contract/base/util";
import { BN_ZERO as BN_ZERO3, hexAddPrefix as hexAddPrefix6, hexToU8a as hexToU8a7, isUndefined as isUndefined2 } from "@polkadot/util";
import { sr25519Agreement as sr25519Agreement3, sr25519PairFromSeed as sr25519PairFromSeed3 } from "@polkadot/util-crypto";
import { from as from4 } from "rxjs";

// src/pruntime/coders.ts
init_process();
init_buffer();
import { BN, BN_ZERO, hexAddPrefix as hexAddPrefix3, hexToU8a as hexToU8a4, stringToHex, u8aToHex as u8aToHex3 } from "@polkadot/util";
import { sr25519Agreement } from "@polkadot/util-crypto";

// src/utils/aes-256-gcm.ts
init_process();
init_buffer();
init_buffer2();
var import_browserify_cipher = __toESM(require_browser4());
import { hexAddPrefix as hexAddPrefix2, hexStripPrefix, hexToU8a as hexToU8a3 } from "@polkadot/util";
var ALGO = "aes-256-gcm";
var AUTH_TAG_LENGTH = 32;
var toU8a = (param) => {
  if (typeof param === "string") {
    param = hexAddPrefix2(param);
    return hexToU8a3(param);
  }
  return param;
};
var encrypt = (data, key, iv) => {
  data = hexStripPrefix(data);
  const cipher = (0, import_browserify_cipher.createCipheriv)(ALGO, toU8a(key), Buffer2.from(toU8a(iv)));
  const enc = cipher.update(data, "hex", "hex");
  cipher.final();
  return `${enc}${cipher.getAuthTag().toString("hex")}`;
};
var decrypt = (enc, key, iv) => {
  enc = hexStripPrefix(enc);
  const decipher = (0, import_browserify_cipher.createDecipheriv)(ALGO, toU8a(key), Buffer2.from(toU8a(iv)));
  const authTag = hexToU8a3(hexAddPrefix2(enc.slice(-AUTH_TAG_LENGTH)));
  decipher.setAuthTag(authTag);
  const data = decipher.update(enc.slice(0, -AUTH_TAG_LENGTH), "hex", "hex");
  decipher.final();
  return data;
};

// src/pruntime/coders.ts
function encodeNumber(n, defaults = BN_ZERO) {
  if (!n) {
    return defaults;
  }
  if (typeof n === "bigint") {
    return n;
  }
  return new BN(n);
}
function InkQueryMessage(address, payload, deposit, transfer, estimating) {
  return phalaTypes.createType("InkQuery", {
    head: {
      nonce: hexAddPrefix3(randomHex(32)),
      id: address
    },
    data: {
      InkMessage: {
        payload,
        deposit: encodeNumber(deposit),
        transfer: encodeNumber(transfer),
        estimating: !!estimating
      }
    }
  });
}
function InkQuerySidevmMessage(address, sidevmMessage) {
  return phalaTypes.createType("InkQuery", {
    head: {
      nonce: hexAddPrefix3(randomHex(32)),
      id: address
    },
    data: {
      SidevmMessage: stringToHex(JSON.stringify(sidevmMessage))
    }
  });
}
function InkQueryInstantiate(address, codeHash, instantiateData, salt, deposit, transfer) {
  return phalaTypes.createType("InkQuery", {
    head: {
      nonce: hexAddPrefix3(randomHex(32)),
      id: address
    },
    data: {
      InkInstantiate: {
        codeHash,
        salt,
        instantiateData,
        deposit: encodeNumber(deposit),
        transfer: encodeNumber(transfer)
      }
    }
  });
}
function PlainInkCommand(address, encParams, nonce, value, gas, storageDepositLimit) {
  return phalaTypes.createType("CommandPayload", {
    Plain: phalaTypes.createType("InkCommand", {
      InkMessage: {
        nonce,
        message: phalaTypes.createType("Vec<u8>", encParams).toHex(),
        transfer: value,
        gasLimit: gas.refTime,
        storageDepositLimit
      }
    })
  });
}
function EncryptedInkCommand(address, encParams, nonce, value, gas, storageDepositLimit) {
  const [sk, pk] = generatePair();
  const commandAgreementKey = sr25519Agreement(sk, hexToU8a4(address));
  const payload = phalaTypes.createType("InkCommand", {
    InkMessage: {
      nonce,
      message: phalaTypes.createType("Vec<u8>", encParams).toHex(),
      transfer: value,
      gasLimit: gas.refTime,
      storageDepositLimit
    }
  });
  const iv = hexAddPrefix3(randomHex(12));
  return phalaTypes.createType("CommandPayload", {
    Encrypted: {
      iv,
      pubkey: u8aToHex3(pk),
      data: hexAddPrefix3(encrypt(payload.toHex(), commandAgreementKey, hexToU8a4(iv)))
    }
  });
}

// src/pruntime/pinkQuery.ts
init_process();
init_buffer();
import { hexAddPrefix as hexAddPrefix4, hexToU8a as hexToU8a5, u8aToHex as u8aToHex4 } from "@polkadot/util";
import { sr25519Sign } from "@polkadot/util-crypto";
var import_proto2 = __toESM(require_proto());
function createEncryptedData(pk, data, agreementKey) {
  const iv = hexAddPrefix4(randomHex(12));
  return {
    iv,
    pubkey: u8aToHex4(pk),
    data: hexAddPrefix4(encrypt(data, agreementKey, hexToU8a5(iv)))
  };
}
async function pinkQuery(pruntimeApi, pk, queryAgreementKey, encodedQuery, { certificate, pubkey, secret }) {
  const encryptedData = createEncryptedData(pk, encodedQuery, queryAgreementKey);
  const encodedEncryptedData = phalaTypes.createType("EncryptedData", encryptedData).toU8a();
  const signature = {
    signedBy: certificate,
    signatureType: import_proto2.pruntime_rpc.SignatureType.Sr25519,
    // signature: sr25519Sign(pubkey, secret, encodedEncryptedData),
    signature: sr25519Sign(encodedEncryptedData, { publicKey: pubkey, secretKey: secret })
  };
  const requestData = {
    encodedEncryptedData,
    signature
  };
  const res = await pruntimeApi.contractQuery(requestData);
  const { data: encryptedResult, iv } = phalaTypes.createType("EncryptedData", res.encodedEncryptedData);
  const data = decrypt(encryptedResult.toString(), queryAgreementKey, iv);
  return hexAddPrefix4(data);
}

// src/utils/assert.ts
init_process();
init_buffer();
function assert(expected, message) {
  if (!expected) {
    throw new Error(message);
  }
}

// src/utils/constants.ts
init_process();
init_buffer();
import { BN as BN2 } from "@polkadot/util";
var BN_MAX_SUPPLY = new BN2(1e12).mul(new BN2(1e9));

// src/utils/signAndSend.ts
init_process();
init_buffer();
var SignAndSendError = class extends Error {
  constructor() {
    super(...arguments);
    this.isCancelled = false;
  }
};
function callback(resolve, reject, result, unsub) {
  if (result.status.isInBlock) {
    let error;
    for (const e of result.events) {
      const {
        event: { data, method, section }
      } = e;
      if (section === "system" && method === "ExtrinsicFailed") {
        error = data[0];
      }
    }
    ;
    unsub();
    if (error) {
      reject(error);
    } else {
      resolve(result);
    }
  } else if (result.status.isInvalid) {
    ;
    unsub();
    reject("Invalid transaction");
  }
}
function signAndSend(target, address, signer) {
  return new Promise(async (resolve, reject) => {
    try {
      if (signer) {
        const unsub = await target.signAndSend(address, { signer }, (result) => {
          callback(resolve, reject, result, unsub);
        });
      } else {
        const unsub = await target.signAndSend(address, (result) => {
          callback(resolve, reject, result, unsub);
        });
      }
    } catch (error) {
      const isCancelled = error.message.indexOf("Cancelled") !== -1;
      Object.defineProperty(error, "isCancelled", {
        enumerable: false,
        value: isCancelled
      });
      reject(error);
    }
  });
}
var signAndSend_default = signAndSend;

// src/contracts/PinkContract.ts
init_process();
init_buffer();
import { toPromiseMethod } from "@polkadot/api";
import { Abi } from "@polkadot/api-contract/Abi";
import { ContractSubmittableResult } from "@polkadot/api-contract/base/Contract";
import { convertWeight, withMeta } from "@polkadot/api-contract/base/util";
import { applyOnEvent } from "@polkadot/api-contract/util";
import { BN_ZERO as BN_ZERO2, hexAddPrefix as hexAddPrefix5, hexToU8a as hexToU8a6, isHex } from "@polkadot/util";
import { sr25519Agreement as sr25519Agreement2, sr25519PairFromSeed as sr25519PairFromSeed2 } from "@polkadot/util-crypto";
import { from as from3 } from "rxjs";
var PinkContractSubmittableResult = class extends ContractSubmittableResult {
  #registry;
  #isFinalized = false;
  #contract;
  #message;
  #nonce;
  constructor(registry, contract, nonce, message, result, contractEvents) {
    super(result, contractEvents);
    this.#registry = registry;
    this.#contract = contract;
    this.#message = message;
    this.#nonce = nonce;
  }
  get nonce() {
    return this.#nonce;
  }
  async throwsOnErrorLog(chainHeight) {
    const logger = this.#registry.loggerContract;
    if (!logger) {
      return;
    }
    const { records } = await logger.tail(10, { contract: this.#contract.address.toHex() });
    const sinceSubmitted = records.filter(
      (i) => (i.type === "Log" || i.type === "MessageOutput") && i.blockNumber >= chainHeight
    );
    sinceSubmitted.reverse();
    sinceSubmitted.forEach((msg) => {
      if (msg.type === "MessageOutput" && "ok" in msg.output.result) {
        const { ok } = msg.output.result;
        if (ok.flags.length && ok.flags[0] === "Revert" && this.#message.returnType) {
          const returns = this.#contract.abi.registry.createType(this.#message.returnType.type, hexToU8a6(ok.data));
          throw new Error(JSON.stringify(returns.toHuman()));
        }
      } else if (msg.type === "Log" && msg.execMode === "transaction") {
        throw new Error(msg.message);
      }
    });
  }
  async waitFinalized(predicate, options2) {
    if (this.#isFinalized) {
      return;
    }
    if (!this.isInBlock && !this.isFinalized) {
      throw new Error("Contract transaction submit failed.");
    }
    const codeHash = this.status.asInBlock.toString();
    const block = await this.#registry.api.rpc.chain.getBlock(codeHash);
    const chainHeight = block.block.header.number.toNumber();
    const t0 = (/* @__PURE__ */ new Date()).getTime();
    const timeout = (options2 == null ? void 0 : options2.timeout) ?? 12e4;
    const blocks = (options2 == null ? void 0 : options2.blocks) ?? 10;
    if (!predicate) {
      while (true) {
        await this.throwsOnErrorLog(chainHeight);
        const { blocknum: currentHeight } = await this.#registry.phactory.getInfo({});
        if (currentHeight > chainHeight) {
          this.#isFinalized = true;
          return;
        }
        if (currentHeight - blocks > chainHeight) {
          throw new Error("Timeout");
        }
        if ((/* @__PURE__ */ new Date()).getTime() - t0 > timeout) {
          throw new Error("Timeout");
        }
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
    } else {
      while (true) {
        await this.throwsOnErrorLog(chainHeight);
        const { blocknum: currentHeight } = await this.#registry.phactory.getInfo({});
        const isOk = await predicate();
        if (isOk) {
          this.#isFinalized = true;
          return;
        }
        if (currentHeight - blocks > chainHeight) {
          throw new Error("Timeout");
        }
        if ((/* @__PURE__ */ new Date()).getTime() - t0 > timeout) {
          throw new Error("Timeout");
        }
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
    }
  }
};
var PinkContractPromise = class {
  constructor(api, phatRegistry, abi, address, contractKey) {
    this.#query = {};
    this.#tx = {};
    this.#inkQuery = (isEstimating, messageOrId, options2, params) => {
      const message = this.abi.findMessage(messageOrId);
      const api = this.api;
      if (!options2.cert) {
        throw new Error(
          "You need to provide the `cert` parameter in the options to process a Phat Contract query. Please check the document for a more detailed code snippet: https://www.npmjs.com/package/@phala/sdk"
        );
      }
      const { cert } = options2;
      const seed = hexToU8a6(hexAddPrefix5(randomHex(32)));
      const pair = sr25519PairFromSeed2(seed);
      const [sk, pk] = [pair.secretKey, pair.publicKey];
      const queryAgreementKey = sr25519Agreement2(sk, hexToU8a6(hexAddPrefix5(this.phatRegistry.remotePubkey)));
      const inkQueryInternal = async (origin) => {
        var _a;
        if (typeof origin === "string") {
          assert(origin === cert.address, "origin must be the same as the certificate address");
        } else if (origin.hasOwnProperty("verify") && origin.hasOwnProperty("adddress")) {
          throw new Error("Contract query expected AccountId as first parameter but since we got signer object here.");
        } else {
          assert(origin.toString() === cert.address, "origin must be the same as the certificate address");
        }
        const payload = InkQueryMessage(
          this.address,
          message.toU8a(params),
          options2.deposit,
          options2.transfer,
          options2.estimating !== void 0 ? !!options2.estimating : isEstimating
        );
        const data = await pinkQuery(this.phatRegistry.phactory, pk, queryAgreementKey, payload.toHex(), cert);
        const inkResponse = api.createType("InkResponse", data);
        if (inkResponse.result.isErr) {
          throw new Error(`InkResponse Error: ${inkResponse.result.asErr.toString()}`);
        }
        if (!inkResponse.result.asOk.isInkMessageReturn) {
          throw new Error(`Unexpected InkMessageReturn: ${(_a = inkResponse.result.asOk.toJSON()) == null ? void 0 : _a.toString()}`);
        }
        const { debugMessage, gasConsumed, gasRequired, result, storageDeposit } = api.createType(
          "ContractExecResult",
          inkResponse.result.asOk.asInkMessageReturn.toString()
        );
        return {
          debugMessage,
          gasConsumed,
          gasRequired: gasRequired && !convertWeight(gasRequired).v1Weight.isZero() ? gasRequired : gasConsumed,
          output: result.isOk && message.returnType ? this.abi.registry.createTypeUnsafe(
            message.returnType.lookupName || message.returnType.type,
            [result.asOk.data.toU8a(true)],
            { isPedantic: true }
          ) : null,
          result,
          storageDeposit
        };
      };
      return {
        send: this._decorateMethod((origin) => from3(inkQueryInternal(origin)))
      };
    };
    this.#inkCommand = (messageOrId, options2, params) => {
      options2.nonce && assert(isHex(options2.nonce) && options2.nonce.length === 66, "Invalid nonce provided");
      const nonce = options2.nonce || hexAddPrefix5(randomHex(32));
      const command = options2.plain ? PlainInkCommand : EncryptedInkCommand;
      const message = this.abi.findMessage(messageOrId);
      const payload = command(
        this.contractKey,
        message.toU8a(params),
        nonce,
        options2.value,
        convertWeight(options2.gasLimit || BN_ZERO2).v2Weight,
        options2.storageDepositLimit
      );
      return this.api.tx.phalaPhatContracts.pushContractMessage(this.address, payload.toHex(), options2.deposit || BN_ZERO2).withResultTransform((result) => {
        return new PinkContractSubmittableResult(
          this.phatRegistry,
          this,
          nonce,
          message,
          result,
          applyOnEvent(result, ["ContractEmitted", "ContractExecution"], (records) => {
            return records.map(
              ({
                event: {
                  data: [, data]
                }
              }) => {
                try {
                  return this.abi.decodeEvent(data);
                } catch (error) {
                  console.error(`Unable to decode contract event: ${error.message}`);
                  return null;
                }
              }
            ).filter((decoded) => !!decoded);
          })
        );
      });
    };
    if (!api || !api.isConnected || !api.tx) {
      throw new Error("Your API has not been initialized correctly and is not connected to a chain");
    }
    if (!phatRegistry.isReady()) {
      throw new Error("Your phatRegistry has not been initialized correctly.");
    }
    this.abi = abi instanceof Abi ? abi : new Abi(abi, api.registry.getChainProperties());
    this.api = api;
    this._decorateMethod = toPromiseMethod;
    this.phatRegistry = phatRegistry;
    this.address = this.registry.createType("AccountId", address);
    this.contractKey = contractKey;
    this.abi.messages.forEach((meta) => {
      if (meta.isMutating) {
        this.#tx[meta.method] = withMeta(
          meta,
          (options2, ...params) => {
            return this.#inkCommand(meta, options2, params);
          }
        );
        this.#query[meta.method] = withMeta(
          meta,
          (origin, options2, ...params) => {
            return this.#inkQuery(true, meta, options2, params).send(origin);
          }
        );
      } else {
        this.#query[meta.method] = withMeta(
          meta,
          (origin, options2, ...params) => {
            return this.#inkQuery(false, meta, options2, params).send(origin);
          }
        );
      }
    });
  }
  #query;
  #tx;
  get send() {
    return new Proxy(
      {},
      {
        get: (_target, prop, _receiver) => {
          const meta = this.abi.messages.filter((i) => i.method === prop);
          if (!meta || !meta.length) {
            throw new Error("Method not found");
          }
          return withMeta(meta[0], (options2, ...arags) => {
            return this.#send(prop, options2, ...arags);
          });
        }
      }
    );
  }
  get registry() {
    return this.api.registry;
  }
  get query() {
    return this.#query;
  }
  get tx() {
    return this.#tx;
  }
  #inkQuery;
  #inkCommand;
  async #send(messageOrId, options2, ...args) {
    const { cert: userCert, ...rest } = options2;
    const txOptions = {
      gasLimit: options2.gasLimit,
      value: options2.value,
      storageDepositLimit: options2.storageDepositLimit,
      plain: options2.plain,
      nonce: options2.nonce
    };
    const tx = this.#tx[messageOrId];
    if (!tx) {
      throw new Error(`Message not found: ${messageOrId}`);
    }
    const address = "signer" in rest ? rest.address : rest.pair.address;
    const cert = userCert || await this.phatRegistry.getAnonymousCert();
    const estimate = this.#query[messageOrId];
    if (!estimate) {
      throw new Error(`Message not found: ${messageOrId}`);
    }
    const { gasPrice } = this.phatRegistry.clusterInfo ?? {};
    if (!gasPrice) {
      throw new Error("No Gas Price or deposit Per Byte from cluster info.");
    }
    const [clusterBalance, onchainBalance, { gasRequired, storageDeposit }] = await Promise.all([
      this.phatRegistry.getClusterBalance(address),
      this.api.query.system.account(address),
      estimate(cert.address, { cert, deposit: BN_MAX_SUPPLY }, ...args)
    ]);
    const gasLimit = gasRequired.refTime.toBn();
    const storageDepositFee = storageDeposit.isCharge ? storageDeposit.asCharge.toBn() : BN_ZERO2;
    const minRequired = gasLimit.mul(gasPrice).add(storageDepositFee);
    if (clusterBalance.free.lt(minRequired)) {
      const deposit = minRequired.sub(clusterBalance.free);
      if (onchainBalance.data.free.lt(deposit)) {
        throw new Error(`Not enough balance to pay for gas and storage deposit: ${minRequired.toNumber()}`);
      }
      txOptions.deposit = deposit;
    }
    if (!txOptions.gasLimit) {
      txOptions.gasLimit = gasRequired.refTime.toBn();
    }
    if ("signer" in rest) {
      return await signAndSend_default(tx(txOptions, ...args), rest.address, rest.signer);
    } else {
      return await signAndSend_default(tx(txOptions, ...args), rest.pair);
    }
  }
};

// src/contracts/PinkBlueprint.ts
var PinkBlueprintSubmittableResult = class extends SubmittableResult {
  constructor(result, abi, registry, contractId) {
    super(result);
    this.#isFinalized = false;
    this.registry = registry;
    this.abi = abi;
    this.#contractId = contractId;
  }
  #contractId;
  #isFinalized;
  #contract;
  get contractId() {
    if (!this.#contractId) {
      throw new Error(`Failed to find contract ID in events, maybe instantiate failed: ${this.#contractId}`);
    }
    return this.#contractId;
  }
  async waitFinalized(timeout = 12e4) {
    if (this.#isFinalized) {
      return;
    }
    if (this.isInBlock || this.isFinalized) {
      let contractId;
      for (const event of this.events) {
        if (event.event.method === "Instantiating") {
          contractId = event.event.data.contract.toString();
          break;
        }
      }
      if (!contractId) {
        throw new Error("Failed to find contract ID in events, maybe instantiate failed.");
      }
      this.#contractId = contractId;
      const logger = this.registry.loggerContract;
      const t0 = (/* @__PURE__ */ new Date()).getTime();
      while (true) {
        if (logger) {
          const { records } = await logger.tail(10, { contract: contractId });
          if (records.length > 0 && records[0].type === "Log" && records[0].execMode === "transaction" && records[0].message.indexOf("instantiate failed") !== -1) {
            throw new Error(records[0].message);
          }
        }
        const result1 = await this.registry.api.query.phalaPhatContracts.clusterContracts(
          this.registry.clusterId
        );
        const contractIds = result1.map((i) => i.toString());
        if (contractIds.indexOf(contractId) !== -1) {
          const result2 = await this.registry.api.query.phalaRegistry.contractKeys(
            contractId
          );
          if (result2.isSome) {
            this.#isFinalized = true;
            if (this.contractId) {
              const contractKey = await this.registry.getContractKeyOrFail(this.contractId);
              this.#contract = new PinkContractPromise(
                this.registry.api,
                this.registry,
                this.abi,
                this.contractId,
                contractKey
              );
            }
            return;
          }
        }
        const t1 = (/* @__PURE__ */ new Date()).getTime();
        if (t1 - t0 > timeout) {
          throw new Error("Timeout");
        }
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
    }
    throw new Error(`instantiate failed for ${this.abi.info.source.wasmHash.toString()}`);
  }
  get contract() {
    if (!this.#contract) {
      throw new Error("contract is not ready yet, please call waitFinalized first");
    }
    return this.#contract;
  }
};
var PinkBlueprintPromise = class {
  constructor(api, phatRegistry, abi, codeHash) {
    this.#query = {};
    this.#tx = {};
    this.#deploy = (constructorOrId, { gasLimit = BN_ZERO3, storageDepositLimit = null, value = BN_ZERO3, deposit = BN_ZERO3, salt }, params) => {
      if (!salt) {
        salt = randomHex(4);
      }
      const codeHash = this.abi.info.source.wasmHash.toString();
      return this.api.tx.phalaPhatContracts.instantiateContract(
        { WasmCode: codeHash },
        this.abi.findConstructor(constructorOrId).toU8a(params),
        salt,
        this.phatRegistry.clusterId,
        value,
        // not transfer any token to the contract during initialization
        gasLimit,
        storageDepositLimit,
        deposit
      ).withResultTransform((result) => {
        let maybeContactId;
        const instantiateEvent = result.events.filter((i) => i.event.method === "Instantiating")[0];
        if (instantiateEvent) {
          const contractId = instantiateEvent.event.data.contract;
          if (contractId) {
            maybeContactId = contractId.toString();
          }
        }
        return new PinkBlueprintSubmittableResult(result, this.abi, this.phatRegistry, maybeContactId);
      });
    };
    this.#estimateGas = (constructorOrId, options2, params) => {
      const seed = hexToU8a7(hexAddPrefix6(randomHex(32)));
      const pair = sr25519PairFromSeed3(seed);
      const [sk, pk] = [pair.secretKey, pair.publicKey];
      const { cert } = options2;
      const queryAgreementKey = sr25519Agreement3(sk, hexToU8a7(hexAddPrefix6(this.phatRegistry.remotePubkey)));
      const inkQueryInternal = async (origin) => {
        if (typeof origin === "string") {
          assert(origin === cert.address, "origin must be the same as the certificate address");
        } else if (origin.hasOwnProperty("verify") && origin.hasOwnProperty("adddress")) {
          throw new Error("Contract query expected AccountId as first parameter but since we got signer object here.");
        } else {
          assert(origin.toString() === cert.address, "origin must be the same as the certificate address");
        }
        if (!this.phatRegistry.systemContract) {
          throw new Error(
            "The associated System Contract was not set up for You OnChainRegistry, causing the estimate gas to fail."
          );
        }
        const salt = options2.salt || randomHex(4);
        const payload = InkQueryInstantiate(
          this.phatRegistry.systemContract.address,
          this.abi.info.source.wasmHash,
          this.abi.findConstructor(constructorOrId).toU8a(params),
          salt,
          options2.deposit,
          options2.transfer
        );
        const rawResponse = await pinkQuery(this.phatRegistry.phactory, pk, queryAgreementKey, payload.toHex(), cert);
        const response = phalaTypes.createType("InkResponse", rawResponse);
        if (response.result.isErr) {
          return phalaTypes.createType("InkQueryError", response.result.asErr.toHex());
        }
        const result = phalaTypes.createType(
          "ContractInstantiateResult",
          response.result.asOk.asInkMessageReturn.toHex()
        );
        result.salt = salt;
        if (result.result.isErr) {
          const err = result.result.asErr;
          if (err.isModule && err.asModule.index.toNumber() === 4) {
            const contractError = phalaTypes.createType("ContractError", result.result.asErr.asModule.error);
            throw new Error(`Estimation failed: ${contractError.toHuman()}`);
          }
          throw new Error("Estimation failed: " + JSON.stringify(result.result.asErr.toHuman()));
        }
        return result;
      };
      return {
        send: this._decorateMethod((origin) => from4(inkQueryInternal(origin)))
      };
    };
    if (!api || !api.isConnected || !api.tx) {
      throw new Error("Your API has not been initialized correctly and is not connected to a chain");
    }
    if (!phatRegistry.isReady()) {
      throw new Error("Your phatRegistry has not been initialized correctly.");
    }
    this.abi = abi instanceof Abi2 ? abi : new Abi2(abi, api.registry.getChainProperties());
    this.api = api;
    this._decorateMethod = toPromiseMethod2;
    this.phatRegistry = phatRegistry;
    this.codeHash = phalaTypes.createType("Hash", codeHash);
    this.abi.constructors.forEach((meta) => {
      if (isUndefined2(this.#tx[meta.method])) {
        this.#tx[meta.method] = createBluePrintTx(
          meta,
          (o, p) => this.#deploy(meta, o, p)
        );
        this.#query[meta.method] = withMeta2(
          meta,
          (origin, options2, ...params) => this.#estimateGas(meta, options2, params).send(origin)
        );
      }
    });
  }
  #query;
  #tx;
  get tx() {
    return this.#tx;
  }
  get query() {
    return this.#query;
  }
  get send() {
    return new Proxy(
      {},
      {
        get: (_target, prop, _receiver) => {
          const meta = this.abi.constructors.filter((i) => i.method === prop);
          if (!meta || !meta.length) {
            throw new Error("Method not found");
          }
          return withMeta2(meta[0], (options2, ...arags) => {
            return this.#send(prop, options2, ...arags);
          });
        }
      }
    );
  }
  #deploy;
  #estimateGas;
  async #send(constructorOrId, options2, ...args) {
    const { cert: userCert, ...rest } = options2;
    const txOptions = {
      gasLimit: options2.gasLimit,
      value: options2.value,
      storageDepositLimit: options2.storageDepositLimit
    };
    const tx = this.#tx[constructorOrId];
    if (!tx) {
      throw new Error(`Constructor not found: ${constructorOrId}`);
    }
    const address = "signer" in rest ? rest.address : rest.pair.address;
    const cert = userCert || await this.phatRegistry.getAnonymousCert();
    const estimate = this.#query[constructorOrId];
    if (!estimate) {
      throw new Error(`Constructor not found: ${constructorOrId}`);
    }
    const { gasPrice } = this.phatRegistry.clusterInfo ?? {};
    if (!gasPrice) {
      throw new Error("No Gas Price or deposit Per Byte from cluster info.");
    }
    const [clusterBalance, onchainBalance, { gasRequired, storageDeposit }] = await Promise.all([
      this.phatRegistry.getClusterBalance(address),
      this.api.query.system.account(address),
      // We estimating the gas & storage deposit cost with deposit propose.
      estimate(cert.address, { cert, deposit: BN_MAX_SUPPLY }, ...args)
    ]);
    const gasLimit = gasRequired.refTime.toBn();
    const storageDepositFee = storageDeposit.isCharge ? storageDeposit.asCharge.toBn() : BN_ZERO3;
    const minRequired = gasLimit.mul(gasPrice).add(storageDepositFee);
    if (clusterBalance.free.lt(minRequired)) {
      const deposit = minRequired.sub(clusterBalance.free);
      if (onchainBalance.data.free.lt(deposit)) {
        throw new Error(`Not enough balance to pay for gas and storage deposit: ${minRequired.toNumber()}`);
      }
      txOptions.deposit = deposit;
    }
    if (!txOptions.gasLimit) {
      txOptions.gasLimit = gasLimit;
    }
    if ("signer" in rest) {
      return await signAndSend_default(tx(txOptions, ...args), rest.address, rest.signer);
    } else {
      return await signAndSend_default(tx(txOptions, ...args), rest.pair);
    }
  }
};

// src/contracts/PinkCode.ts
var InkCodeSubmittableResult = class extends SubmittableResult2 {
  constructor(result, abi, registry) {
    super(result);
    this.#isFinalized = false;
    this.registry = registry;
    this.abi = abi;
    this.blueprint = new PinkBlueprintPromise(this.registry.api, this.registry, this.abi, this.abi.info.source.wasmHash);
  }
  #isFinalized;
  async waitFinalized(pair, cert, timeout = 1e4) {
    if (this.#isFinalized) {
      return;
    }
    if (this.isInBlock || this.isFinalized) {
      const system = this.registry.systemContract;
      const codeHash = this.abi.info.source.wasmHash.toString();
      const t0 = (/* @__PURE__ */ new Date()).getTime();
      while (true) {
        const { output } = await system.query["system::codeExists"](pair.address, { cert }, codeHash, "Ink");
        if (output && output.asOk.toPrimitive()) {
          this.#isFinalized = true;
          return;
        }
        const t1 = (/* @__PURE__ */ new Date()).getTime();
        if (t1 - t0 > timeout) {
          throw new Error("Timeout");
        }
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
    }
    throw new Error("Not in block, your Code may upload failed.");
  }
};
var PinkCodePromise = class {
  constructor(api, phatRegistry, abi, wasm) {
    this.#tx = {};
    this.#instantiate = (_constructorOrId, _params) => {
      return this.api.tx.phalaPhatContracts.clusterUploadResource(this.phatRegistry.clusterId, "InkCode", u8aToHex5(this.code)).withResultTransform((result) => {
        return new InkCodeSubmittableResult(result, this.abi, this.phatRegistry);
      });
    };
    if (!api || !api.isConnected || !api.tx) {
      throw new Error("Your API has not been initialized correctly and is not connected to a chain");
    }
    if (!phatRegistry.isReady()) {
      throw new Error("Your phatRegistry has not been initialized correctly.");
    }
    this.abi = abi instanceof Abi3 ? abi : new Abi3(abi, api.registry.getChainProperties());
    this.api = api;
    this._decorateMethod = toPromiseMethod3;
    this.phatRegistry = phatRegistry;
    if (isWasm(this.abi.info.source.wasm)) {
      this.code = this.abi.info.source.wasm;
    } else if (isU8a(wasm)) {
      this.code = wasm;
    } else if (typeof wasm === "string" && wasm.substring(0, 2) === "0x") {
      this.code = hexToU8a8(wasm);
    } else {
      throw new Error("`wasm` should hex encoded string or Uint8Array.");
    }
    if (!isWasm(this.code)) {
      throw new Error("No WASM code provided");
    }
    this.#tx = new Proxy(
      {},
      {
        get: (_target, prop, _receiver) => {
          const meta = this.abi.constructors.filter((i) => i.method === prop);
          if (!meta || !meta.length) {
            throw new Error("Method not found");
          }
          return () => this.#instantiate(meta[0], []);
        }
      }
    );
  }
  #tx;
  get tx() {
    return this.#tx;
  }
  upload() {
    return this.#instantiate(0, []);
  }
  #instantiate;
};

// src/contracts/PinkLoggerContract.ts
init_process();
init_buffer();
import { Keyring } from "@polkadot/api";
import { Abi as Abi4 } from "@polkadot/api-contract";
import { hexAddPrefix as hexAddPrefix7, hexToString, hexToU8a as hexToU8a9, u8aToHex as u8aToHex6 } from "@polkadot/util";
import { blake2AsU8a as blake2AsU8a2, sr25519Agreement as sr25519Agreement4 } from "@polkadot/util-crypto";

// src/utils/snakeToPascalCase.ts
init_process();
init_buffer();
function snakeToPascalCase(snakeStr) {
  return snakeStr.toLowerCase().split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join("");
}
var regex_pascal_case = /^[A-Z][a-zA-Z0-9]*$/;
function isPascalCase(str) {
  return regex_pascal_case.test(str);
}

// src/contracts/Errors.ts
init_process();
init_buffer();
var ContractInitialError = class extends Error {
};

// src/contracts/PinkLoggerContract.ts
function sidevmQueryWithReader({ phactory, remotePubkey, address, cert }) {
  return async function unsafeRunSidevmQuery(sidevmMessage) {
    const [sk, pk] = generatePair();
    const encodedQuery = InkQuerySidevmMessage(address, sidevmMessage);
    const queryAgreementKey = sr25519Agreement4(sk, hexToU8a9(hexAddPrefix7(remotePubkey)));
    const response = await pinkQuery(phactory, pk, queryAgreementKey, encodedQuery.toHex(), cert);
    const inkResponse = phalaTypes.createType("InkResponse", response);
    if (inkResponse.result.isErr) {
      let error = `[${inkResponse.result.asErr.index}] ${inkResponse.result.asErr.type}`;
      if (inkResponse.result.asErr.type === "RuntimeError") {
        error = `${error}: ${inkResponse.result.asErr.value}`;
      }
      throw new Error(error);
    }
    const payload = inkResponse.result.asOk.asInkMessageReturn.toString();
    const parsed = payload.substring(0, 2) === "0x" ? JSON.parse(hexToString(payload)) : JSON.parse(payload);
    if (parsed.error) {
      throw new Error(parsed.error);
    }
    return parsed;
  };
}
function postProcessLogRecord(messages, abiLike) {
  let abi;
  if (abiLike) {
    abi = abiLike instanceof Abi4 ? abiLike : new Abi4(abiLike);
  }
  return messages.map((message) => {
    var _a;
    if (message.type === "MessageOutput") {
      const execResult = phalaTypes.createType("ContractExecResult", hexToU8a9(message.output));
      const output = execResult.toJSON();
      if (execResult.result.isErr && execResult.result.asErr.isModule && ((_a = execResult.result.asErr.asModule) == null ? void 0 : _a.index) === 4) {
        const err = phalaTypes.createType("ContractError", execResult.result.asErr.asModule.error);
        output.result = {
          err: {
            ...output.result.err,
            module: {
              error: err.toJSON(),
              index: 4
            }
          }
        };
      }
      return { ...message, output };
    } else if (message.type === "Event" && abi) {
      try {
        const decoded = abi.decodeEvent(hexToU8a9(message.payload));
        return { ...message, decoded };
      } catch (_err) {
      }
    }
    return message;
  });
}
function buildGetLogRequest(params, getFrom, getDefaults) {
  let request = getDefaults();
  switch (params.length) {
    case 0:
      request.from = getFrom(request);
      break;
    case 1:
      if (typeof params[0] === "number") {
        request.count = params[0];
        request.from = getFrom(request);
      } else {
        request.from = getFrom(params[0]);
        if (params[0].count) {
          request.count = params[0].count;
        }
        request = { ...params[0], ...request };
      }
      break;
    case 2:
      request.count = params[0];
      if (typeof params[1] === "number") {
        request.from = params[1];
      } else {
        request.from = getFrom(request);
        request = { ...params[1], ...request };
      }
      break;
    case 3:
      request = { ...params[2], count: params[0], from: params[1] };
      break;
    default:
      throw new Error("Unexpected parameters.");
  }
  return request;
}
function getTopicHash(topic) {
  if (topic.indexOf("::") === -1) {
    throw new Error("Invalid topic.");
  }
  let [contract, event] = topic.split("::");
  if (!isPascalCase(contract)) {
    contract = snakeToPascalCase(contract);
  }
  event = `${contract}::${event}`;
  const length = event.length;
  const encoded = phalaTypes.createType(`(Vec<u8>, [u8; ${length}])`, [null, event]).toU8a();
  if (encoded.length > 32) {
    return u8aToHex6(blake2AsU8a2(encoded));
  } else {
    return u8aToHex6(encoded) + "00".repeat(32 - encoded.length);
  }
}
var PinkLoggerContractPromise = class _PinkLoggerContractPromise {
  #phactory;
  #remotePubkey;
  #address;
  #pair;
  #systemContractId;
  static async create(_api, registry, systemContract, pair) {
    var _a;
    let _pair = pair;
    if (!_pair) {
      const keyring = new Keyring({ type: "sr25519" });
      _pair = keyring.addFromUri("//Alice");
    }
    const cert = await signCertificate({ pair: _pair });
    const { output } = await systemContract.query["system::getDriver"](_pair.address, { cert }, "PinkLogger");
    const contractId = output.asOk.toHex();
    if (!contractId) {
      throw new ContractInitialError("No PinkLogger contract registered in the cluster.");
    }
    const systemContractId = (_a = systemContract.address) == null ? void 0 : _a.toHex();
    if (!registry.phactory || !registry.remotePubkey) {
      throw new Error("No Pruntime connection found.");
    }
    return new _PinkLoggerContractPromise(registry.phactory, registry.remotePubkey, _pair, contractId, systemContractId);
  }
  // constructor(api: ApiPromise, registry: OnChainRegistry, contractId: string | AccountId, pair: KeyringPair, systemContractId: string) {
  constructor(phactory, remotePubkey, pair, contractId, systemContractId) {
    this.#phactory = phactory;
    this.#remotePubkey = remotePubkey;
    this.#address = phalaTypes.createType("AccountId", contractId);
    this.#pair = pair;
    this.#systemContractId = systemContractId;
  }
  async getSidevmQueryContext() {
    const cert = await signCertificate({ pair: this.#pair });
    const address = this.#address;
    const phactory = this.#phactory;
    const remotePubkey = this.#remotePubkey;
    return { phactory, remotePubkey, address, cert };
  }
  /**
   * This method call `GetLog` directly, and return the raw result. All encapulation methods is based on this method.
   * We keep this one for testing purpose, and it should less likely to be used in production.
   */
  async getLogRaw(query = {}) {
    const ctx = await this.getSidevmQueryContext();
    const unsafeRunSidevmQuery = sidevmQueryWithReader(ctx);
    return await unsafeRunSidevmQuery({
      action: "GetLog",
      from: query.from,
      count: query.count,
      contract: query.contract
    });
  }
  get address() {
    return this.#address;
  }
  /**
   * Get log records from the contract.
   *
   * @deprecated
   */
  async getLog(contract, from5 = 0, count = 100) {
    const result = await this.getLogRaw({
      contract,
      from: from5,
      count
    });
    return { records: postProcessLogRecord(result.records), next: result.next };
  }
  /**
   * Get the logger info. It use for probe the logger status.
   */
  async getInfo() {
    const ctx = await this.getSidevmQueryContext();
    const unsafeRunSidevmQuery = sidevmQueryWithReader(ctx);
    return await unsafeRunSidevmQuery({ action: "GetInfo" });
  }
  async tail(...params) {
    const { abi, type, topic, nonce, ...request } = buildGetLogRequest(
      params,
      (x) => {
        if (!x.from) {
          return x.count ? -x.count : -10;
        }
        return -(x.from + (x.count || 10));
      },
      () => ({ count: 10 })
    );
    const result = await this.getLogRaw(request);
    if (type) {
      if (Array.isArray(type)) {
        result.records = result.records.filter((record) => type.includes(record.type));
      } else if (type === "Event" && topic) {
        const topicHash = getTopicHash(topic);
        result.records = result.records.filter((record) => record.type === type && record.topics[0] === topicHash);
      } else if (type === "MessageOutput" && nonce) {
        result.records = result.records.filter((record) => record.type === type && record.nonce === nonce);
      } else {
        result.records = result.records.filter((record) => record.type === type);
      }
    }
    return { records: postProcessLogRecord(result.records, abi), next: result.next };
  }
  async head(...params) {
    const { abi, type, topic, nonce, ...request } = buildGetLogRequest(
      params,
      (x) => x.from || 0,
      () => ({ from: 0, count: 10 })
    );
    const result = await this.getLogRaw(request);
    if (type) {
      if (Array.isArray(type)) {
        result.records = result.records.filter((record) => type.includes(record.type));
      } else if (type === "Event" && topic) {
        const topicHash = getTopicHash(topic);
        result.records = result.records.filter((record) => record.type === type && record.topics[0] === topicHash);
      } else if (type === "MessageOutput" && nonce) {
        result.records = result.records.filter((record) => record.type === type && record.nonce === nonce);
      } else {
        result.records = result.records.filter((record) => record.type === type);
      }
    }
    return { records: postProcessLogRecord(result.records, abi), next: result.next };
  }
  /// System Contract Related.
  setSystemContract(contract) {
    var _a;
    if (typeof contract === "string") {
      this.#systemContractId = contract;
    } else {
      this.#systemContractId = (_a = contract.address) == null ? void 0 : _a.toHex();
    }
  }
  async headSystemLog(counts = 10, from5 = 0) {
    if (!this.#systemContractId) {
      throw new Error("System contract ID is not set.");
    }
    const contract = typeof this.#systemContractId === "string" ? this.#systemContractId : this.#systemContractId.toHex();
    return this.head(counts, from5, { contract });
  }
  async tailSystemLog(counts = 10, from5 = -10) {
    if (!this.#systemContractId) {
      throw new Error("System contract ID is not set.");
    }
    const contract = typeof this.#systemContractId === "string" ? this.#systemContractId : this.#systemContractId.toHex();
    return this.tail(counts, from5, { contract });
  }
};

// src/OnChainRegistry.ts
init_process();
init_buffer();
import { Keyring as Keyring2 } from "@polkadot/api";
import { cryptoWaitReady as cryptoWaitReady2 } from "@polkadot/util-crypto";

// src/ha/ack-first.ts
init_process();
init_buffer();

// src/pruntime/createPruntimeClient.ts
init_process();
init_buffer();
var import_proto3 = __toESM(require_proto());
import fetch from "cross-fetch";
function createPruntimeClient(baseURL) {
  const pruntimeApi = import_proto3.pruntime_rpc.PhactoryAPI.create(async (method, requestData, callback2) => {
    try {
      const resp = await fetch(`${baseURL}/prpc/PhactoryAPI.${method.name}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/octet-stream"
        },
        body: new Uint8Array(requestData)
      });
      if (resp.status === 200) {
        const buffer = await (await resp.blob()).arrayBuffer();
        callback2(null, new Uint8Array(buffer));
      } else if (resp.status === 400 || resp.status === 500) {
        let error;
        try {
          const buffer = await (await resp.blob()).arrayBuffer();
          const prpcError = import_proto3.prpc.PrpcError.decode(new Uint8Array(buffer));
          error = new Error(`PrpcError: ${prpcError.message}`);
        } catch (err) {
          error = new Error(`ServerError: ${resp.status}: ${await resp.text()}`);
        }
        throw error;
      } else {
        throw new Error(`Unexpected Response Status: ${resp.status}`);
      }
    } catch (err) {
      callback2(err);
    }
  });
  return pruntimeApi;
}

// src/ha/ack-first.ts
async function ack(workerId, endpoint) {
  const client = createPruntimeClient(endpoint);
  const info = await client.getInfo({});
  const actually = `0x${info.ecdhPublicKey || ""}`;
  if (actually === workerId) {
    return [workerId, endpoint, client];
  }
  throw new Error("On-chain worker ID not match to the worker ECDH PublicKey.");
}
function ackFirst() {
  return async function ackFirst2(apiPromise, clusterId) {
    const workersQuery = await apiPromise.query.phalaPhatContracts.clusterWorkers(clusterId);
    const workerIds = workersQuery.map((i) => i.toHex());
    const endpointsQuery = await apiPromise.query.phalaRegistry.endpoints.multi(workerIds);
    const pairs = endpointsQuery.map((i, idx) => [workerIds[idx], i]).filter(([_, maybeEndpoint]) => maybeEndpoint.isSome).map(([workerId, maybeEndpoint]) => [workerId, maybeEndpoint.unwrap().asV1[0].toString()]);
    try {
      return await Promise.any(pairs.map(([workerId, endpoint]) => ack(workerId, endpoint)));
    } catch (_err) {
      throw new Error("No worker available.");
    }
  };
}

// src/OnChainRegistry.ts
var UnexpectedEndpointError = class extends Error {
};
var OnChainRegistry = class _OnChainRegistry {
  constructor(api) {
    this.#ready = false;
    this.api = api;
  }
  #ready;
  #phactory;
  #alice;
  #cert;
  #systemContract;
  #loggerContract;
  async getContractKey(contractId) {
    const contractKey = await this.api.query.phalaRegistry.contractKeys(contractId);
    if (!contractKey) {
      return void 0;
    }
    return contractKey.toString();
  }
  async getContractKeyOrFail(contractId) {
    const contractKey = await this.getContractKey(contractId);
    if (!contractKey) {
      throw new Error(`Contract ${contractId} not found in cluster.`);
    }
    return contractKey;
  }
  isReady() {
    return this.#ready;
  }
  get phactory() {
    if (!this.#ready || !this.#phactory) {
      throw new Error("You need initialize OnChainRegistry first.");
    }
    return this.#phactory;
  }
  get gasPrice() {
    if (!this.#ready || !this.clusterInfo || !this.clusterInfo.gasPrice) {
      throw new Error("You need initialize OnChainRegistry first.");
    }
    return this.clusterInfo.gasPrice;
  }
  /**
   * Static factory method returns a ready to use PhatRegistry object.
   */
  static async create(api, options2) {
    options2 = { autoConnect: true, ...options2 || {} };
    const instance = new _OnChainRegistry(api);
    await Promise.all([cryptoWaitReady2(), api.isReady]);
    if (options2.autoConnect) {
      if (!options2.clusterId && !options2.workerId && !options2.pruntimeURL) {
        await instance.connect();
      } else if (options2.pruntimeURL) {
        const workerInfo = {
          clusterId: options2.clusterId,
          pruntimeURL: options2.pruntimeURL
        };
        await instance.connect(workerInfo);
      } else if (options2.strategy) {
        await instance.connect({
          clusterId: options2.clusterId,
          strategy: options2.strategy
        });
      } else {
        console.warn("Failed back to legacy connection mode, please use pruntimeURL instead.");
        await instance.connect(
          options2.clusterId,
          options2.workerId,
          options2.pruntimeURL,
          options2.systemContractId,
          !!options2.skipCheck
        );
      }
    }
    return instance;
  }
  async getAllClusters() {
    const result = await this.api.query.phalaPhatContracts.clusters.entries();
    return result.map(([storageKey, value]) => {
      const clusterId = storageKey.args.map((i) => i.toPrimitive())[0];
      const clusterInfo = value.unwrap();
      return [clusterId, clusterInfo];
    });
  }
  async getClusterInfoById(clusterId) {
    const result = await this.api.query.phalaPhatContracts.clusters(clusterId);
    if (result.isNone) {
      return null;
    }
    return result.unwrap();
  }
  async getClusters(clusterId) {
    if (clusterId) {
      const result = await this.api.query.phalaPhatContracts.clusters(clusterId);
      if (result.isNone) {
        return null;
      }
      return result.unwrap();
    } else {
      return await this.getAllClusters();
    }
  }
  async getEndpoints(workerId) {
    if (workerId) {
      if (typeof workerId !== "string") {
        workerId = workerId.toHex();
      }
      return await this.api.query.phalaRegistry.endpoints(workerId);
    }
    const result = await this.api.query.phalaRegistry.endpoints.entries();
    return result.map(([storageKey, value]) => {
      const workerId2 = storageKey.args.map((i) => i.toPrimitive())[0];
      return [workerId2, value];
    });
  }
  async getClusterWorkers(clusterId) {
    let _clusterId = clusterId || this.clusterId;
    if (!_clusterId) {
      const clusters = await this.getAllClusters();
      if (!clusters || clusters.length === 0) {
        throw new Error("You need specified clusterId to list workers inside it.");
      }
      _clusterId = clusters[0][0];
    }
    const result = await this.api.query.phalaPhatContracts.clusterWorkers(_clusterId);
    const workerIds = result.toJSON();
    const infos = await this.api.query.phalaRegistry.endpoints.multi(workerIds);
    return infos.map((i, idx) => [workerIds[idx], i]).filter(([_, maybeEndpoint]) => maybeEndpoint.isSome).map(
      ([workerId, maybeEndpoint]) => ({
        pubkey: workerId,
        clusterId: _clusterId,
        endpoints: {
          default: maybeEndpoint.unwrap().asV1[0].toString(),
          v1: maybeEndpoint.unwrap().asV1.map((i) => i.toString())
        }
      })
    );
  }
  async preparePruntimeClientOrThrows(endpoint) {
    try {
      const phactory = createPruntimeClient(endpoint);
      await phactory.getInfo({});
      return phactory;
    } catch (err) {
      console.error(err);
      throw new Error(
        "Phactory API not compatible, you might need downgrade your @phala/sdk or connect to an up-to-date endpoint."
      );
    }
  }
  async prepareSystemOrThrows(clusterInfo) {
    const systemContractId = clusterInfo.systemContract;
    if (systemContractId) {
      const systemContractKey = await this.getContractKey(systemContractId);
      if (systemContractKey) {
        this.#systemContract = new PinkContractPromise(this.api, this, system_default, systemContractId, systemContractKey);
        this.#loggerContract = await PinkLoggerContractPromise.create(this.api, this, this.#systemContract);
      } else {
        throw new Error(`System contract not found: ${systemContractId}`);
      }
    }
  }
  async connect(...args) {
    var _a;
    this.#ready = false;
    if (args.length === 0 || args.length === 1) {
      if (args.length === 0) {
        const clusters = await this.getAllClusters();
        if (!clusters || clusters.length === 0) {
          throw new Error("No cluster found.");
        }
        const [clusterId2, clusterInfo2] = clusters[0];
        const [workerId2, endpoint, phactory] = await ackFirst()(this.api, clusterId2);
        this.#phactory = phactory;
        this.clusterId = clusterId2;
        this.clusterInfo = clusterInfo2;
        this.workerInfo = {
          pubkey: workerId2,
          clusterId: clusterId2,
          endpoints: {
            default: endpoint,
            v1: [endpoint]
          }
        };
        this.#ready = true;
        await this.prepareSystemOrThrows(clusterInfo2);
        return;
      }
      if (args.length === 1 && args[0] instanceof Object) {
        if (args[0].strategy) {
          let clusterId2 = args[0].clusterId;
          let clusterInfo2;
          if (!clusterId2) {
            const clusters = await this.getAllClusters();
            if (!clusters || clusters.length === 0) {
              throw new Error("No cluster found.");
            }
            ;
            [clusterId2, clusterInfo2] = clusters[0];
          } else {
            clusterInfo2 = await this.getClusterInfoById(clusterId2);
            if (!clusterInfo2) {
              throw new Error(`Cluster not found: ${clusterId2}`);
            }
          }
          if (args[0].strategy === "ack-first") {
            const [workerId2, endpoint, phactory] = await ackFirst()(this.api, clusterId2);
            this.#phactory = phactory;
            this.clusterId = clusterId2;
            this.clusterInfo = clusterInfo2;
            this.workerInfo = {
              pubkey: workerId2,
              clusterId: clusterId2,
              endpoints: {
                default: endpoint,
                v1: [endpoint]
              }
            };
            this.#ready = true;
            await this.prepareSystemOrThrows(clusterInfo2);
          } else if (typeof args[0].strategy === "function") {
            const [workerId2, phactory] = await args[0].strategy(this.api, clusterId2);
            this.#phactory = phactory;
            this.clusterId = clusterId2;
            this.clusterInfo = clusterInfo2;
            this.workerInfo = {
              pubkey: workerId2,
              clusterId: clusterId2,
              endpoints: {
                default: phactory.endpoint,
                v1: [phactory.endpoint]
              }
            };
            this.#ready = true;
            await this.prepareSystemOrThrows(clusterInfo2);
          } else {
            throw new Error(`Unknown strategy: ${args[0].strategy}`);
          }
        } else if (args[0].pruntimeURL) {
          const partialInfo = args[0];
          const pruntimeURL2 = partialInfo.pruntimeURL;
          let clusterId2 = partialInfo.clusterId;
          if (!pruntimeURL2) {
            throw new Error("pruntimeURL is required.");
          }
          const phactory = createPruntimeClient(pruntimeURL2);
          if (!clusterId2) {
            const clusterInfoQuery = await phactory.getClusterInfo({});
            if ((_a = clusterInfoQuery == null ? void 0 : clusterInfoQuery.info) == null ? void 0 : _a.id) {
              clusterId2 = clusterInfoQuery.info.id;
            } else {
              throw new Error(`getClusterInfo is unavailable, please ensure ${pruntimeURL2} is valid PRuntime endpoint.`);
            }
          }
          const clusterInfo2 = await this.getClusterInfoById(clusterId2);
          if (!clusterInfo2) {
            throw new Error(`Cluster not found: ${partialInfo.clusterId}`);
          }
          const nodeInfo = await phactory.getInfo({});
          if (!nodeInfo || !nodeInfo.publicKey) {
            throw new Error(`Get PRuntime Pubkey failed.`);
          }
          this.#phactory = phactory;
          this.clusterId = clusterId2;
          this.clusterInfo = clusterInfo2;
          this.workerInfo = {
            pubkey: nodeInfo.publicKey,
            clusterId: clusterId2,
            endpoints: {
              default: pruntimeURL2
            }
          };
          this.#ready = true;
          await this.prepareSystemOrThrows(clusterInfo2);
        } else {
          const worker = args[0];
          const clusterInfo2 = await this.getClusterInfoById(worker.clusterId);
          if (!clusterInfo2) {
            throw new Error(`Cluster not found: ${worker.clusterId}`);
          }
          this.#phactory = await this.preparePruntimeClientOrThrows(worker.endpoints.default);
          this.clusterId = worker.clusterId;
          this.clusterInfo = clusterInfo2;
          this.workerInfo = worker;
          this.#ready = true;
          await this.prepareSystemOrThrows(clusterInfo2);
        }
        return;
      }
    }
    console.warn("Deprecated: connect to dedicated worker via legacy mode, please migrate to the new API.");
    let clusterId = args[0];
    let workerId = args[1];
    let pruntimeURL = args[2];
    let systemContractId = args[3];
    const skipCheck = args[4];
    let clusterInfo;
    if (clusterId) {
      clusterInfo = await this.getClusters(clusterId);
      if (!clusterInfo) {
        throw new Error(`Cluster not found: ${clusterId}`);
      }
    } else {
      const clusters = await this.getClusters();
      if (!clusters || !Array.isArray(clusters)) {
        throw new Error("No cluster found.");
      }
      if (clusters.length === 0) {
        throw new Error("No cluster found.");
      }
      clusterId = clusters[0][0];
      clusterInfo = clusters[0][1];
    }
    if (!skipCheck) {
      const endpoints = await this.getEndpoints();
      if (!Array.isArray(endpoints) || endpoints.length === 0) {
        throw new Error("No worker found.");
      }
      if (!workerId && !pruntimeURL) {
        workerId = endpoints[0][0];
        pruntimeURL = endpoints[0][1].unwrap().asV1[0].toPrimitive();
      } else if (pruntimeURL) {
        const endpoint = endpoints.find(([_, v]) => {
          const url = v.unwrap().asV1[0].toPrimitive();
          return url === pruntimeURL;
        });
        if (endpoint) {
          workerId = endpoint[0];
        }
      } else if (workerId) {
        const endpoint = endpoints.find(([id, _]) => id === workerId);
        if (!endpoint) {
          throw new Error(`Worker not found: ${workerId}`);
        }
        pruntimeURL = endpoint[1].unwrap().asV1[0].toPrimitive();
      }
    }
    this.#phactory = createPruntimeClient(pruntimeURL);
    try {
      await this.#phactory.getInfo({});
    } catch (err) {
      console.error(err);
      throw new Error(
        "Phactory API not compatible, you might need downgrade your @phala/sdk or connect to an up-to-date endpoint."
      );
    }
    this.clusterId = clusterId;
    this.workerInfo = {
      pubkey: workerId,
      clusterId,
      endpoints: {
        default: pruntimeURL,
        v1: [pruntimeURL]
      }
    };
    this.clusterInfo = clusterInfo;
    this.#ready = true;
    if (this.clusterInfo && this.clusterInfo.systemContract) {
      systemContractId = this.clusterInfo.systemContract;
    }
    if (systemContractId) {
      const systemContractKey = await this.getContractKey(systemContractId);
      if (systemContractKey) {
        this.#systemContract = new PinkContractPromise(this.api, this, system_default, systemContractId, systemContractKey);
        this.#loggerContract = await PinkLoggerContractPromise.create(this.api, this, this.#systemContract);
      } else {
        throw new Error(`System contract not found: ${systemContractId}`);
      }
    }
  }
  get systemContract() {
    if (this.#systemContract) {
      return this.#systemContract;
    }
    console.warn("System contract not found, you might not connect to a health cluster.");
  }
  get alice() {
    if (!this.#alice) {
      const keyring = new Keyring2({ type: "sr25519" });
      this.#alice = keyring.addFromUri("//Alice");
    }
    return this.#alice;
  }
  async getAnonymousCert() {
    if (!this.#cert) {
      this.#cert = await signCertificate({ pair: this.alice });
    }
    return this.#cert;
  }
  resetAnonymousCert() {
    this.#cert = void 0;
  }
  async getClusterBalance(address, cert) {
    const system = this.#systemContract;
    if (!system) {
      throw new Error("System contract not found, you might not connect to a health cluster.");
    }
    if (!cert) {
      cert = await this.getAnonymousCert();
    }
    const [{ output: totalBalanceOf }, { output: freeBalanceOf }] = await Promise.all([
      system.query["system::totalBalanceOf"](cert.address, { cert }, address),
      system.query["system::freeBalanceOf"](cert.address, { cert }, address)
    ]);
    return {
      total: totalBalanceOf.asOk.toBn(),
      free: freeBalanceOf.asOk.toBn()
    };
  }
  transferToCluster(address, amount) {
    return this.api.tx.phalaPhatContracts.transferToCluster(amount, this.clusterId, address);
  }
  get loggerContract() {
    if (this.#loggerContract) {
      return this.#loggerContract;
    }
    console.warn("Logger contract not found, you might not connect to a health cluster.");
  }
  get remotePubkey() {
    var _a;
    return (_a = this.workerInfo) == null ? void 0 : _a.pubkey;
  }
  get pruntimeURL() {
    var _a;
    return (_a = this.workerInfo) == null ? void 0 : _a.endpoints.default;
  }
};

// src/abis/fetchers.ts
init_process();
init_buffer();
import fetch2 from "cross-fetch";
var OFFICIAL_ARTIFACTS_URL = "https://phala-network.github.io/phat-contract-artifacts";
function unsafeCheckCodeHashExists(env3) {
  const { systemContract, cert } = env3;
  return async function _unsafeCheckCodeHashExists(codeHash) {
    const { output } = await systemContract.query["system::codeExists"](
      cert.address,
      { cert },
      `0x${codeHash}`,
      "Ink"
    );
    return output && output.isOk && output.asOk.isTrue;
  };
}
async function unsafeGetContractCodeHash(phatRegistry, contractId) {
  var _a;
  const payload = await phatRegistry.phactory.getContractInfo({ contracts: [contractId] });
  return ((_a = payload == null ? void 0 : payload.contracts[0]) == null ? void 0 : _a.codeHash) || null;
}
async function unsafeGetAbiFromPatronByCodeHash(codeHash) {
  const codeHashWithoutPrefix = codeHash.indexOf("0x") === 0 ? codeHash.replace("0x", "") : codeHash;
  const resp = await fetch2(`https://api.patron.works/buildSessions/metadata/${codeHashWithoutPrefix}`);
  if (resp.status !== 200) {
    let payload;
    try {
      payload = await resp.json();
    } catch (_err1) {
      try {
        const text = await resp.text();
        throw new Error(`Failed to get abi from Patron: ${resp.status}: ${text}`);
      } catch (_err2) {
        throw new Error(`Unknown Error: ${resp.status}: ${_err2}`);
      }
    }
    throw new Error(`Failed to get abi from Patron: ${resp.status}: ${(payload == null ? void 0 : payload.error) || "Unknown Error"}`);
  }
  return await resp.json();
}
async function unsafeGetAbiFromGitHubRepoByCodeHash(codeHash) {
  const codeHashWithPrefix = codeHash.indexOf("0x") !== 0 ? `0x${codeHash}` : codeHash;
  const resp = await fetch2(`${OFFICIAL_ARTIFACTS_URL}/artifacts/${codeHashWithPrefix}/metadata.json`);
  if (resp.status !== 200) {
    throw new Error(`Failed to get abi from GitHub: ${resp.status}`);
  }
  return await resp.json();
}
async function unsafeGetWasmFromPatronByCodeHash(codeHash) {
  const codeHashWithoutPrefix = codeHash.indexOf("0x") === 0 ? codeHash.replace("0x", "") : codeHash;
  const resp = await fetch2(`https://api.patron.works/buildSessions/wasm/${codeHashWithoutPrefix}`);
  if (resp.status !== 200) {
    throw new Error(`Failed to get wasm from Patron: ${resp.status}`);
  }
  const buffer = await resp.arrayBuffer();
  return new Uint8Array(buffer);
}
async function unsafeGetWasmFromGithubRepoByCodeHash(codeHash) {
  const codeHashWithPrefix = codeHash.indexOf("0x") !== 0 ? `0x${codeHash}` : codeHash;
  const resp = await fetch2(`${OFFICIAL_ARTIFACTS_URL}/artifacts/${codeHashWithPrefix}/out.wasm`);
  if (resp.status !== 200) {
    throw new Error(`Failed to get wasm from GitHub: ${resp.status}`);
  }
  const buffer = await resp.arrayBuffer();
  return new Uint8Array(buffer);
}

// src/ha/periodicity-checker.ts
init_process();
init_buffer();
import fetch3 from "cross-fetch";
var PRUNTIME_NODE_LIST = "https://phala-network.github.io/pruntime-node-list/nodes.json";
function periodicityChecker(url) {
  return async function(_apiPromise, clusterId) {
    const resp = await fetch3(url || PRUNTIME_NODE_LIST);
    const data = await resp.json();
    const endpoints = (data == null ? void 0 : data[clusterId]) || [];
    if (endpoints.length === 0) {
      throw new Error("No worker available.");
    }
    const picked = endpoints[Math.floor(Math.random() * endpoints.length)];
    const client = createPruntimeClient(picked);
    const info = await client.getInfo({});
    return [`0x${info.ecdhPublicKey || ""}`, picked, client];
  };
}

// src/ha/fixture.ts
init_process();
init_buffer();
function fixture(endpoints) {
  return async function(_apiPromise, _clusterId) {
    if (endpoints.length === 0) {
      throw new Error("No worker available.");
    }
    const picked = endpoints[Math.floor(Math.random() * endpoints.length)];
    const client = createPruntimeClient(picked);
    const info = await client.getInfo({});
    return [`0x${info.ecdhPublicKey || ""}`, picked, client];
  };
}

// src/factory_functions.ts
init_process();
init_buffer();
import { ApiPromise, Keyring as Keyring3, WsProvider } from "@polkadot/api";
import { cryptoWaitReady as cryptoWaitReady3 } from "@polkadot/util-crypto";
async function getClient(opts) {
  const { transport, ...rest } = opts;
  const provider = typeof transport === "string" ? new WsProvider(transport) : transport;
  const api = await ApiPromise.create(options({ provider, noInitWarn: true }));
  return await OnChainRegistry.create(api, rest);
}
async function getContract(options2) {
  const { client, contractId, abi } = options2;
  const contractKey = await client.getContractKeyOrFail(contractId);
  return new PinkContractPromise(client.api, client, abi, contractId, contractKey);
}
async function getLogger(options2) {
  if ("transport" in options2) {
    const client = await getClient(options2);
    if (!client.loggerContract) {
      throw new Error("Logger contract not found in the cluster.");
    }
    return client.loggerContract;
  } else if ("contractId" in options2 && "pruntimeURL" in options2) {
    await cryptoWaitReady3();
    const keyring = new Keyring3({ type: "sr25519" });
    const alice = keyring.addFromUri("//Alice");
    const { contractId, pruntimeURL } = options2;
    const phactory = createPruntimeClient(pruntimeURL);
    const info = await phactory.getInfo({});
    return new PinkLoggerContractPromise(phactory, info.publicKey, alice, contractId, options2.systemContract);
  } else {
    throw new Error("Invalid options.");
  }
}

// src/index.ts
var pruntimeRpc4 = import_proto4.pruntime_rpc;
var PhactoryAPI = import_proto4.pruntime_rpc.PhactoryAPI;
var abis = { system: system_default };
export {
  InkCodeSubmittableResult,
  OnChainRegistry,
  PhactoryAPI,
  PinkBlueprintPromise,
  PinkBlueprintSubmittableResult,
  PinkCodePromise,
  PinkContractPromise,
  PinkLoggerContractPromise,
  SignAndSendError,
  UnexpectedEndpointError,
  abis,
  ackFirst,
  buildGetLogRequest,
  createEip712StructedDataSignCertificate,
  createEip712StructedDataSignQuery,
  createPruntimeClient,
  etherAddressToCompactPubkey,
  etherAddressToSubstrateAddress,
  fixture,
  generatePair,
  getClient,
  getContract,
  getLogger,
  getTopicHash,
  options,
  periodicityChecker,
  phalaRegistryTypes,
  phalaTypes,
  pruntimeRpc4 as pruntimeRpc,
  randomHex,
  signAndSend_default as signAndSend,
  signCertificate,
  types,
  unsafeCheckCodeHashExists,
  unsafeGetAbiFromGitHubRepoByCodeHash,
  unsafeGetAbiFromPatronByCodeHash,
  unsafeGetContractCodeHash,
  unsafeGetWasmFromGithubRepoByCodeHash,
  unsafeGetWasmFromPatronByCodeHash,
  unstable_signEip712Certificate
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*! Bundled license information:

@esbuild-plugins/node-globals-polyfill/Buffer.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
