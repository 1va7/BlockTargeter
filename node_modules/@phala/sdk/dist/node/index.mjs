var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback2(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from3(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer3 = util.inquire("buffer").Buffer;
        return Buffer3.prototype.utf8Write ? Buffer3 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get() {
            return name;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer3 = util.Buffer;
      if (!Buffer3) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer3.from !== Uint8Array.from && Buffer3.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer3(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer3.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer3(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback2) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback2)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback2(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback2(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback2(err2);
              }
            }
            self2.emit("data", response, method);
            return callback2(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback2(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// src/pruntime/proto/index.js
var require_proto = __commonJS({
  "src/pruntime/proto/index.js"(exports2, module2) {
    "use strict";
    var $protobuf = require_minimal2();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.prpc = function() {
      var prpc2 = {};
      prpc2.PrpcError = function() {
        function PrpcError(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        PrpcError.prototype.message = "";
        PrpcError.create = function create(properties) {
          return new PrpcError(properties);
        };
        PrpcError.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.message);
          return writer;
        };
        PrpcError.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        PrpcError.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.prpc.PrpcError();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.message = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        PrpcError.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        PrpcError.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.message != null && message.hasOwnProperty("message")) {
            if (!$util.isString(message.message))
              return "message: string expected";
          }
          return null;
        };
        PrpcError.fromObject = function fromObject(object) {
          if (object instanceof $root.prpc.PrpcError)
            return object;
          var message = new $root.prpc.PrpcError();
          if (object.message != null)
            message.message = String(object.message);
          return message;
        };
        PrpcError.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults)
            object.message = "";
          if (message.message != null && message.hasOwnProperty("message"))
            object.message = message.message;
          return object;
        };
        PrpcError.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        PrpcError.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/prpc.PrpcError";
        };
        return PrpcError;
      }();
      return prpc2;
    }();
    $root.pruntime_rpc = function() {
      var pruntime_rpc2 = {};
      pruntime_rpc2.PhactoryAPI = function() {
        function PhactoryAPI2(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }
        (PhactoryAPI2.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = PhactoryAPI2;
        PhactoryAPI2.create = function create(rpcImpl, requestDelimited, responseDelimited) {
          return new this(rpcImpl, requestDelimited, responseDelimited);
        };
        Object.defineProperty(PhactoryAPI2.prototype.getInfo = function getInfo(request, callback2) {
          return this.rpcCall(getInfo, $root.google.protobuf.Empty, $root.pruntime_rpc.PhactoryInfo, request, callback2);
        }, "name", { value: "GetInfo" });
        Object.defineProperty(PhactoryAPI2.prototype.syncHeader = function syncHeader(request, callback2) {
          return this.rpcCall(syncHeader, $root.pruntime_rpc.HeadersToSync, $root.pruntime_rpc.SyncedTo, request, callback2);
        }, "name", { value: "SyncHeader" });
        Object.defineProperty(PhactoryAPI2.prototype.syncParaHeader = function syncParaHeader(request, callback2) {
          return this.rpcCall(syncParaHeader, $root.pruntime_rpc.ParaHeadersToSync, $root.pruntime_rpc.SyncedTo, request, callback2);
        }, "name", { value: "SyncParaHeader" });
        Object.defineProperty(PhactoryAPI2.prototype.syncCombinedHeaders = function syncCombinedHeaders(request, callback2) {
          return this.rpcCall(syncCombinedHeaders, $root.pruntime_rpc.CombinedHeadersToSync, $root.pruntime_rpc.HeadersSyncedTo, request, callback2);
        }, "name", { value: "SyncCombinedHeaders" });
        Object.defineProperty(PhactoryAPI2.prototype.dispatchBlocks = function dispatchBlocks(request, callback2) {
          return this.rpcCall(dispatchBlocks, $root.pruntime_rpc.Blocks, $root.pruntime_rpc.SyncedTo, request, callback2);
        }, "name", { value: "DispatchBlocks" });
        Object.defineProperty(PhactoryAPI2.prototype.initRuntime = function initRuntime(request, callback2) {
          return this.rpcCall(initRuntime, $root.pruntime_rpc.InitRuntimeRequest, $root.pruntime_rpc.InitRuntimeResponse, request, callback2);
        }, "name", { value: "InitRuntime" });
        Object.defineProperty(PhactoryAPI2.prototype.getRuntimeInfo = function getRuntimeInfo(request, callback2) {
          return this.rpcCall(getRuntimeInfo, $root.pruntime_rpc.GetRuntimeInfoRequest, $root.pruntime_rpc.InitRuntimeResponse, request, callback2);
        }, "name", { value: "GetRuntimeInfo" });
        Object.defineProperty(PhactoryAPI2.prototype.getEgressMessages = function getEgressMessages(request, callback2) {
          return this.rpcCall(getEgressMessages, $root.google.protobuf.Empty, $root.pruntime_rpc.GetEgressMessagesResponse, request, callback2);
        }, "name", { value: "GetEgressMessages" });
        Object.defineProperty(PhactoryAPI2.prototype.contractQuery = function contractQuery(request, callback2) {
          return this.rpcCall(contractQuery, $root.pruntime_rpc.ContractQueryRequest, $root.pruntime_rpc.ContractQueryResponse, request, callback2);
        }, "name", { value: "ContractQuery" });
        Object.defineProperty(PhactoryAPI2.prototype.getWorkerState = function getWorkerState(request, callback2) {
          return this.rpcCall(getWorkerState, $root.pruntime_rpc.GetWorkerStateRequest, $root.pruntime_rpc.WorkerState, request, callback2);
        }, "name", { value: "GetWorkerState" });
        Object.defineProperty(PhactoryAPI2.prototype.addEndpoint = function addEndpoint(request, callback2) {
          return this.rpcCall(addEndpoint, $root.pruntime_rpc.AddEndpointRequest, $root.pruntime_rpc.GetEndpointResponse, request, callback2);
        }, "name", { value: "AddEndpoint" });
        Object.defineProperty(PhactoryAPI2.prototype.refreshEndpointSigningTime = function refreshEndpointSigningTime(request, callback2) {
          return this.rpcCall(refreshEndpointSigningTime, $root.google.protobuf.Empty, $root.pruntime_rpc.GetEndpointResponse, request, callback2);
        }, "name", { value: "RefreshEndpointSigningTime" });
        Object.defineProperty(PhactoryAPI2.prototype.getEndpointInfo = function getEndpointInfo(request, callback2) {
          return this.rpcCall(getEndpointInfo, $root.google.protobuf.Empty, $root.pruntime_rpc.GetEndpointResponse, request, callback2);
        }, "name", { value: "GetEndpointInfo" });
        Object.defineProperty(PhactoryAPI2.prototype.signEndpointInfo = function signEndpointInfo(request, callback2) {
          return this.rpcCall(signEndpointInfo, $root.pruntime_rpc.SignEndpointsRequest, $root.pruntime_rpc.GetEndpointResponse, request, callback2);
        }, "name", { value: "SignEndpointInfo" });
        Object.defineProperty(PhactoryAPI2.prototype.derivePhalaI2pKey = function derivePhalaI2pKey(request, callback2) {
          return this.rpcCall(derivePhalaI2pKey, $root.google.protobuf.Empty, $root.pruntime_rpc.DerivePhalaI2pKeyResponse, request, callback2);
        }, "name", { value: "DerivePhalaI2pKey" });
        Object.defineProperty(PhactoryAPI2.prototype.echo = function echo(request, callback2) {
          return this.rpcCall(echo, $root.pruntime_rpc.EchoMessage, $root.pruntime_rpc.EchoMessage, request, callback2);
        }, "name", { value: "Echo" });
        Object.defineProperty(PhactoryAPI2.prototype.handoverCreateChallenge = function handoverCreateChallenge(request, callback2) {
          return this.rpcCall(handoverCreateChallenge, $root.google.protobuf.Empty, $root.pruntime_rpc.HandoverChallenge, request, callback2);
        }, "name", { value: "HandoverCreateChallenge" });
        Object.defineProperty(PhactoryAPI2.prototype.handoverStart = function handoverStart(request, callback2) {
          return this.rpcCall(handoverStart, $root.pruntime_rpc.HandoverChallengeResponse, $root.pruntime_rpc.HandoverWorkerKey, request, callback2);
        }, "name", { value: "HandoverStart" });
        Object.defineProperty(PhactoryAPI2.prototype.handoverAcceptChallenge = function handoverAcceptChallenge(request, callback2) {
          return this.rpcCall(handoverAcceptChallenge, $root.pruntime_rpc.HandoverChallenge, $root.pruntime_rpc.HandoverChallengeResponse, request, callback2);
        }, "name", { value: "HandoverAcceptChallenge" });
        Object.defineProperty(PhactoryAPI2.prototype.handoverReceive = function handoverReceive(request, callback2) {
          return this.rpcCall(handoverReceive, $root.pruntime_rpc.HandoverWorkerKey, $root.google.protobuf.Empty, request, callback2);
        }, "name", { value: "HandoverReceive" });
        Object.defineProperty(PhactoryAPI2.prototype.configNetwork = function configNetwork(request, callback2) {
          return this.rpcCall(configNetwork, $root.pruntime_rpc.NetworkConfig, $root.google.protobuf.Empty, request, callback2);
        }, "name", { value: "ConfigNetwork" });
        Object.defineProperty(PhactoryAPI2.prototype.httpFetch = function httpFetch(request, callback2) {
          return this.rpcCall(httpFetch, $root.pruntime_rpc.HttpRequest, $root.pruntime_rpc.HttpResponse, request, callback2);
        }, "name", { value: "HttpFetch" });
        Object.defineProperty(PhactoryAPI2.prototype.getContractInfo = function getContractInfo(request, callback2) {
          return this.rpcCall(getContractInfo, $root.pruntime_rpc.GetContractInfoRequest, $root.pruntime_rpc.GetContractInfoResponse, request, callback2);
        }, "name", { value: "GetContractInfo" });
        Object.defineProperty(PhactoryAPI2.prototype.getClusterInfo = function getClusterInfo(request, callback2) {
          return this.rpcCall(getClusterInfo, $root.google.protobuf.Empty, $root.pruntime_rpc.GetClusterInfoResponse, request, callback2);
        }, "name", { value: "GetClusterInfo" });
        Object.defineProperty(PhactoryAPI2.prototype.uploadSidevmCode = function uploadSidevmCode(request, callback2) {
          return this.rpcCall(uploadSidevmCode, $root.pruntime_rpc.SidevmCode, $root.google.protobuf.Empty, request, callback2);
        }, "name", { value: "UploadSidevmCode" });
        Object.defineProperty(PhactoryAPI2.prototype.calculateContractId = function calculateContractId(request, callback2) {
          return this.rpcCall(calculateContractId, $root.pruntime_rpc.ContractParameters, $root.pruntime_rpc.ContractId, request, callback2);
        }, "name", { value: "CalculateContractId" });
        Object.defineProperty(PhactoryAPI2.prototype.getNetworkConfig = function getNetworkConfig(request, callback2) {
          return this.rpcCall(getNetworkConfig, $root.google.protobuf.Empty, $root.pruntime_rpc.NetworkConfigResponse, request, callback2);
        }, "name", { value: "GetNetworkConfig" });
        Object.defineProperty(PhactoryAPI2.prototype.loadChainState = function loadChainState(request, callback2) {
          return this.rpcCall(loadChainState, $root.pruntime_rpc.ChainState, $root.google.protobuf.Empty, request, callback2);
        }, "name", { value: "LoadChainState" });
        Object.defineProperty(PhactoryAPI2.prototype.stop = function stop(request, callback2) {
          return this.rpcCall(stop, $root.pruntime_rpc.StopOptions, $root.google.protobuf.Empty, request, callback2);
        }, "name", { value: "Stop" });
        Object.defineProperty(PhactoryAPI2.prototype.loadStorageProof = function loadStorageProof(request, callback2) {
          return this.rpcCall(loadStorageProof, $root.pruntime_rpc.StorageProof, $root.google.protobuf.Empty, request, callback2);
        }, "name", { value: "LoadStorageProof" });
        Object.defineProperty(PhactoryAPI2.prototype.takeCheckpoint = function takeCheckpoint(request, callback2) {
          return this.rpcCall(takeCheckpoint, $root.google.protobuf.Empty, $root.pruntime_rpc.SyncedTo, request, callback2);
        }, "name", { value: "TakeCheckpoint" });
        Object.defineProperty(PhactoryAPI2.prototype.statistics = function statistics(request, callback2) {
          return this.rpcCall(statistics, $root.pruntime_rpc.StatisticsReqeust, $root.pruntime_rpc.StatisticsResponse, request, callback2);
        }, "name", { value: "Statistics" });
        Object.defineProperty(PhactoryAPI2.prototype.generateClusterStateRequest = function generateClusterStateRequest(request, callback2) {
          return this.rpcCall(generateClusterStateRequest, $root.google.protobuf.Empty, $root.pruntime_rpc.SaveClusterStateArguments, request, callback2);
        }, "name", { value: "GenerateClusterStateRequest" });
        Object.defineProperty(PhactoryAPI2.prototype.saveClusterState = function saveClusterState(request, callback2) {
          return this.rpcCall(saveClusterState, $root.pruntime_rpc.SaveClusterStateArguments, $root.pruntime_rpc.SaveClusterStateResponse, request, callback2);
        }, "name", { value: "SaveClusterState" });
        Object.defineProperty(PhactoryAPI2.prototype.loadClusterState = function loadClusterState(request, callback2) {
          return this.rpcCall(loadClusterState, $root.pruntime_rpc.SaveClusterStateResponse, $root.google.protobuf.Empty, request, callback2);
        }, "name", { value: "LoadClusterState" });
        Object.defineProperty(PhactoryAPI2.prototype.tryUpgradePinkRuntime = function tryUpgradePinkRuntime(request, callback2) {
          return this.rpcCall(tryUpgradePinkRuntime, $root.pruntime_rpc.PinkRuntimeVersion, $root.google.protobuf.Empty, request, callback2);
        }, "name", { value: "TryUpgradePinkRuntime" });
        return PhactoryAPI2;
      }();
      pruntime_rpc2.PhactoryInfo = function() {
        function PhactoryInfo(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        PhactoryInfo.prototype.initialized = false;
        PhactoryInfo.prototype.registered = false;
        PhactoryInfo.prototype.genesisBlockHash = null;
        PhactoryInfo.prototype.publicKey = null;
        PhactoryInfo.prototype.ecdhPublicKey = null;
        PhactoryInfo.prototype.headernum = 0;
        PhactoryInfo.prototype.paraHeadernum = 0;
        PhactoryInfo.prototype.blocknum = 0;
        PhactoryInfo.prototype.stateRoot = "";
        PhactoryInfo.prototype.devMode = false;
        PhactoryInfo.prototype.pendingMessages = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        PhactoryInfo.prototype.score = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        PhactoryInfo.prototype.gatekeeper = null;
        PhactoryInfo.prototype.version = "";
        PhactoryInfo.prototype.gitRevision = "";
        PhactoryInfo.prototype.memoryUsage = null;
        PhactoryInfo.prototype.waitingForParaheaders = false;
        PhactoryInfo.prototype.system = null;
        PhactoryInfo.prototype.canLoadChainState = false;
        PhactoryInfo.prototype.safeModeLevel = 0;
        PhactoryInfo.prototype.currentBlockTime = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        PhactoryInfo.prototype.maxSupportedPinkRuntimeVersion = "";
        var $oneOfFields;
        Object.defineProperty(PhactoryInfo.prototype, "_genesisBlockHash", {
          get: $util.oneOfGetter($oneOfFields = ["genesisBlockHash"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        Object.defineProperty(PhactoryInfo.prototype, "_publicKey", {
          get: $util.oneOfGetter($oneOfFields = ["publicKey"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        Object.defineProperty(PhactoryInfo.prototype, "_ecdhPublicKey", {
          get: $util.oneOfGetter($oneOfFields = ["ecdhPublicKey"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        PhactoryInfo.create = function create(properties) {
          return new PhactoryInfo(properties);
        };
        PhactoryInfo.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.initialized != null && Object.hasOwnProperty.call(message, "initialized"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).bool(message.initialized);
          if (message.registered != null && Object.hasOwnProperty.call(message, "registered"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).bool(message.registered);
          if (message.genesisBlockHash != null && Object.hasOwnProperty.call(message, "genesisBlockHash"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.genesisBlockHash);
          if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).string(message.publicKey);
          if (message.ecdhPublicKey != null && Object.hasOwnProperty.call(message, "ecdhPublicKey"))
            writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).string(message.ecdhPublicKey);
          if (message.headernum != null && Object.hasOwnProperty.call(message, "headernum"))
            writer.uint32(
              /* id 7, wireType 0 =*/
              56
            ).uint32(message.headernum);
          if (message.paraHeadernum != null && Object.hasOwnProperty.call(message, "paraHeadernum"))
            writer.uint32(
              /* id 8, wireType 0 =*/
              64
            ).uint32(message.paraHeadernum);
          if (message.blocknum != null && Object.hasOwnProperty.call(message, "blocknum"))
            writer.uint32(
              /* id 9, wireType 0 =*/
              72
            ).uint32(message.blocknum);
          if (message.stateRoot != null && Object.hasOwnProperty.call(message, "stateRoot"))
            writer.uint32(
              /* id 10, wireType 2 =*/
              82
            ).string(message.stateRoot);
          if (message.devMode != null && Object.hasOwnProperty.call(message, "devMode"))
            writer.uint32(
              /* id 11, wireType 0 =*/
              88
            ).bool(message.devMode);
          if (message.pendingMessages != null && Object.hasOwnProperty.call(message, "pendingMessages"))
            writer.uint32(
              /* id 12, wireType 0 =*/
              96
            ).uint64(message.pendingMessages);
          if (message.score != null && Object.hasOwnProperty.call(message, "score"))
            writer.uint32(
              /* id 13, wireType 0 =*/
              104
            ).uint64(message.score);
          if (message.gatekeeper != null && Object.hasOwnProperty.call(message, "gatekeeper"))
            $root.pruntime_rpc.GatekeeperStatus.encode(message.gatekeeper, writer.uint32(
              /* id 14, wireType 2 =*/
              114
            ).fork()).ldelim();
          if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(
              /* id 15, wireType 2 =*/
              122
            ).string(message.version);
          if (message.gitRevision != null && Object.hasOwnProperty.call(message, "gitRevision"))
            writer.uint32(
              /* id 16, wireType 2 =*/
              130
            ).string(message.gitRevision);
          if (message.memoryUsage != null && Object.hasOwnProperty.call(message, "memoryUsage"))
            $root.pruntime_rpc.MemoryUsage.encode(message.memoryUsage, writer.uint32(
              /* id 18, wireType 2 =*/
              146
            ).fork()).ldelim();
          if (message.waitingForParaheaders != null && Object.hasOwnProperty.call(message, "waitingForParaheaders"))
            writer.uint32(
              /* id 21, wireType 0 =*/
              168
            ).bool(message.waitingForParaheaders);
          if (message.system != null && Object.hasOwnProperty.call(message, "system"))
            $root.pruntime_rpc.SystemInfo.encode(message.system, writer.uint32(
              /* id 23, wireType 2 =*/
              186
            ).fork()).ldelim();
          if (message.canLoadChainState != null && Object.hasOwnProperty.call(message, "canLoadChainState"))
            writer.uint32(
              /* id 24, wireType 0 =*/
              192
            ).bool(message.canLoadChainState);
          if (message.safeModeLevel != null && Object.hasOwnProperty.call(message, "safeModeLevel"))
            writer.uint32(
              /* id 25, wireType 0 =*/
              200
            ).uint32(message.safeModeLevel);
          if (message.currentBlockTime != null && Object.hasOwnProperty.call(message, "currentBlockTime"))
            writer.uint32(
              /* id 26, wireType 0 =*/
              208
            ).uint64(message.currentBlockTime);
          if (message.maxSupportedPinkRuntimeVersion != null && Object.hasOwnProperty.call(message, "maxSupportedPinkRuntimeVersion"))
            writer.uint32(
              /* id 27, wireType 2 =*/
              218
            ).string(message.maxSupportedPinkRuntimeVersion);
          return writer;
        };
        PhactoryInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        PhactoryInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.PhactoryInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.initialized = reader.bool();
                break;
              }
              case 2: {
                message.registered = reader.bool();
                break;
              }
              case 4: {
                message.genesisBlockHash = reader.string();
                break;
              }
              case 5: {
                message.publicKey = reader.string();
                break;
              }
              case 6: {
                message.ecdhPublicKey = reader.string();
                break;
              }
              case 7: {
                message.headernum = reader.uint32();
                break;
              }
              case 8: {
                message.paraHeadernum = reader.uint32();
                break;
              }
              case 9: {
                message.blocknum = reader.uint32();
                break;
              }
              case 10: {
                message.stateRoot = reader.string();
                break;
              }
              case 11: {
                message.devMode = reader.bool();
                break;
              }
              case 12: {
                message.pendingMessages = reader.uint64();
                break;
              }
              case 13: {
                message.score = reader.uint64();
                break;
              }
              case 14: {
                message.gatekeeper = $root.pruntime_rpc.GatekeeperStatus.decode(reader, reader.uint32());
                break;
              }
              case 15: {
                message.version = reader.string();
                break;
              }
              case 16: {
                message.gitRevision = reader.string();
                break;
              }
              case 18: {
                message.memoryUsage = $root.pruntime_rpc.MemoryUsage.decode(reader, reader.uint32());
                break;
              }
              case 21: {
                message.waitingForParaheaders = reader.bool();
                break;
              }
              case 23: {
                message.system = $root.pruntime_rpc.SystemInfo.decode(reader, reader.uint32());
                break;
              }
              case 24: {
                message.canLoadChainState = reader.bool();
                break;
              }
              case 25: {
                message.safeModeLevel = reader.uint32();
                break;
              }
              case 26: {
                message.currentBlockTime = reader.uint64();
                break;
              }
              case 27: {
                message.maxSupportedPinkRuntimeVersion = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        PhactoryInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        PhactoryInfo.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.initialized != null && message.hasOwnProperty("initialized")) {
            if (typeof message.initialized !== "boolean")
              return "initialized: boolean expected";
          }
          if (message.registered != null && message.hasOwnProperty("registered")) {
            if (typeof message.registered !== "boolean")
              return "registered: boolean expected";
          }
          if (message.genesisBlockHash != null && message.hasOwnProperty("genesisBlockHash")) {
            properties._genesisBlockHash = 1;
            if (!$util.isString(message.genesisBlockHash))
              return "genesisBlockHash: string expected";
          }
          if (message.publicKey != null && message.hasOwnProperty("publicKey")) {
            properties._publicKey = 1;
            if (!$util.isString(message.publicKey))
              return "publicKey: string expected";
          }
          if (message.ecdhPublicKey != null && message.hasOwnProperty("ecdhPublicKey")) {
            properties._ecdhPublicKey = 1;
            if (!$util.isString(message.ecdhPublicKey))
              return "ecdhPublicKey: string expected";
          }
          if (message.headernum != null && message.hasOwnProperty("headernum")) {
            if (!$util.isInteger(message.headernum))
              return "headernum: integer expected";
          }
          if (message.paraHeadernum != null && message.hasOwnProperty("paraHeadernum")) {
            if (!$util.isInteger(message.paraHeadernum))
              return "paraHeadernum: integer expected";
          }
          if (message.blocknum != null && message.hasOwnProperty("blocknum")) {
            if (!$util.isInteger(message.blocknum))
              return "blocknum: integer expected";
          }
          if (message.stateRoot != null && message.hasOwnProperty("stateRoot")) {
            if (!$util.isString(message.stateRoot))
              return "stateRoot: string expected";
          }
          if (message.devMode != null && message.hasOwnProperty("devMode")) {
            if (typeof message.devMode !== "boolean")
              return "devMode: boolean expected";
          }
          if (message.pendingMessages != null && message.hasOwnProperty("pendingMessages")) {
            if (!$util.isInteger(message.pendingMessages) && !(message.pendingMessages && $util.isInteger(message.pendingMessages.low) && $util.isInteger(message.pendingMessages.high)))
              return "pendingMessages: integer|Long expected";
          }
          if (message.score != null && message.hasOwnProperty("score")) {
            if (!$util.isInteger(message.score) && !(message.score && $util.isInteger(message.score.low) && $util.isInteger(message.score.high)))
              return "score: integer|Long expected";
          }
          if (message.gatekeeper != null && message.hasOwnProperty("gatekeeper")) {
            var error = $root.pruntime_rpc.GatekeeperStatus.verify(message.gatekeeper);
            if (error)
              return "gatekeeper." + error;
          }
          if (message.version != null && message.hasOwnProperty("version")) {
            if (!$util.isString(message.version))
              return "version: string expected";
          }
          if (message.gitRevision != null && message.hasOwnProperty("gitRevision")) {
            if (!$util.isString(message.gitRevision))
              return "gitRevision: string expected";
          }
          if (message.memoryUsage != null && message.hasOwnProperty("memoryUsage")) {
            var error = $root.pruntime_rpc.MemoryUsage.verify(message.memoryUsage);
            if (error)
              return "memoryUsage." + error;
          }
          if (message.waitingForParaheaders != null && message.hasOwnProperty("waitingForParaheaders")) {
            if (typeof message.waitingForParaheaders !== "boolean")
              return "waitingForParaheaders: boolean expected";
          }
          if (message.system != null && message.hasOwnProperty("system")) {
            var error = $root.pruntime_rpc.SystemInfo.verify(message.system);
            if (error)
              return "system." + error;
          }
          if (message.canLoadChainState != null && message.hasOwnProperty("canLoadChainState")) {
            if (typeof message.canLoadChainState !== "boolean")
              return "canLoadChainState: boolean expected";
          }
          if (message.safeModeLevel != null && message.hasOwnProperty("safeModeLevel")) {
            if (!$util.isInteger(message.safeModeLevel))
              return "safeModeLevel: integer expected";
          }
          if (message.currentBlockTime != null && message.hasOwnProperty("currentBlockTime")) {
            if (!$util.isInteger(message.currentBlockTime) && !(message.currentBlockTime && $util.isInteger(message.currentBlockTime.low) && $util.isInteger(message.currentBlockTime.high)))
              return "currentBlockTime: integer|Long expected";
          }
          if (message.maxSupportedPinkRuntimeVersion != null && message.hasOwnProperty("maxSupportedPinkRuntimeVersion")) {
            if (!$util.isString(message.maxSupportedPinkRuntimeVersion))
              return "maxSupportedPinkRuntimeVersion: string expected";
          }
          return null;
        };
        PhactoryInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.PhactoryInfo)
            return object;
          var message = new $root.pruntime_rpc.PhactoryInfo();
          if (object.initialized != null)
            message.initialized = Boolean(object.initialized);
          if (object.registered != null)
            message.registered = Boolean(object.registered);
          if (object.genesisBlockHash != null)
            message.genesisBlockHash = String(object.genesisBlockHash);
          if (object.publicKey != null)
            message.publicKey = String(object.publicKey);
          if (object.ecdhPublicKey != null)
            message.ecdhPublicKey = String(object.ecdhPublicKey);
          if (object.headernum != null)
            message.headernum = object.headernum >>> 0;
          if (object.paraHeadernum != null)
            message.paraHeadernum = object.paraHeadernum >>> 0;
          if (object.blocknum != null)
            message.blocknum = object.blocknum >>> 0;
          if (object.stateRoot != null)
            message.stateRoot = String(object.stateRoot);
          if (object.devMode != null)
            message.devMode = Boolean(object.devMode);
          if (object.pendingMessages != null) {
            if ($util.Long)
              (message.pendingMessages = $util.Long.fromValue(object.pendingMessages)).unsigned = true;
            else if (typeof object.pendingMessages === "string")
              message.pendingMessages = parseInt(object.pendingMessages, 10);
            else if (typeof object.pendingMessages === "number")
              message.pendingMessages = object.pendingMessages;
            else if (typeof object.pendingMessages === "object")
              message.pendingMessages = new $util.LongBits(object.pendingMessages.low >>> 0, object.pendingMessages.high >>> 0).toNumber(true);
          }
          if (object.score != null) {
            if ($util.Long)
              (message.score = $util.Long.fromValue(object.score)).unsigned = true;
            else if (typeof object.score === "string")
              message.score = parseInt(object.score, 10);
            else if (typeof object.score === "number")
              message.score = object.score;
            else if (typeof object.score === "object")
              message.score = new $util.LongBits(object.score.low >>> 0, object.score.high >>> 0).toNumber(true);
          }
          if (object.gatekeeper != null) {
            if (typeof object.gatekeeper !== "object")
              throw TypeError(".pruntime_rpc.PhactoryInfo.gatekeeper: object expected");
            message.gatekeeper = $root.pruntime_rpc.GatekeeperStatus.fromObject(object.gatekeeper);
          }
          if (object.version != null)
            message.version = String(object.version);
          if (object.gitRevision != null)
            message.gitRevision = String(object.gitRevision);
          if (object.memoryUsage != null) {
            if (typeof object.memoryUsage !== "object")
              throw TypeError(".pruntime_rpc.PhactoryInfo.memoryUsage: object expected");
            message.memoryUsage = $root.pruntime_rpc.MemoryUsage.fromObject(object.memoryUsage);
          }
          if (object.waitingForParaheaders != null)
            message.waitingForParaheaders = Boolean(object.waitingForParaheaders);
          if (object.system != null) {
            if (typeof object.system !== "object")
              throw TypeError(".pruntime_rpc.PhactoryInfo.system: object expected");
            message.system = $root.pruntime_rpc.SystemInfo.fromObject(object.system);
          }
          if (object.canLoadChainState != null)
            message.canLoadChainState = Boolean(object.canLoadChainState);
          if (object.safeModeLevel != null)
            message.safeModeLevel = object.safeModeLevel >>> 0;
          if (object.currentBlockTime != null) {
            if ($util.Long)
              (message.currentBlockTime = $util.Long.fromValue(object.currentBlockTime)).unsigned = true;
            else if (typeof object.currentBlockTime === "string")
              message.currentBlockTime = parseInt(object.currentBlockTime, 10);
            else if (typeof object.currentBlockTime === "number")
              message.currentBlockTime = object.currentBlockTime;
            else if (typeof object.currentBlockTime === "object")
              message.currentBlockTime = new $util.LongBits(object.currentBlockTime.low >>> 0, object.currentBlockTime.high >>> 0).toNumber(true);
          }
          if (object.maxSupportedPinkRuntimeVersion != null)
            message.maxSupportedPinkRuntimeVersion = String(object.maxSupportedPinkRuntimeVersion);
          return message;
        };
        PhactoryInfo.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.initialized = false;
            object.registered = false;
            object.headernum = 0;
            object.paraHeadernum = 0;
            object.blocknum = 0;
            object.stateRoot = "";
            object.devMode = false;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.pendingMessages = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.pendingMessages = options2.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.score = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.score = options2.longs === String ? "0" : 0;
            object.gatekeeper = null;
            object.version = "";
            object.gitRevision = "";
            object.memoryUsage = null;
            object.waitingForParaheaders = false;
            object.system = null;
            object.canLoadChainState = false;
            object.safeModeLevel = 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.currentBlockTime = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.currentBlockTime = options2.longs === String ? "0" : 0;
            object.maxSupportedPinkRuntimeVersion = "";
          }
          if (message.initialized != null && message.hasOwnProperty("initialized"))
            object.initialized = message.initialized;
          if (message.registered != null && message.hasOwnProperty("registered"))
            object.registered = message.registered;
          if (message.genesisBlockHash != null && message.hasOwnProperty("genesisBlockHash")) {
            object.genesisBlockHash = message.genesisBlockHash;
            if (options2.oneofs)
              object._genesisBlockHash = "genesisBlockHash";
          }
          if (message.publicKey != null && message.hasOwnProperty("publicKey")) {
            object.publicKey = message.publicKey;
            if (options2.oneofs)
              object._publicKey = "publicKey";
          }
          if (message.ecdhPublicKey != null && message.hasOwnProperty("ecdhPublicKey")) {
            object.ecdhPublicKey = message.ecdhPublicKey;
            if (options2.oneofs)
              object._ecdhPublicKey = "ecdhPublicKey";
          }
          if (message.headernum != null && message.hasOwnProperty("headernum"))
            object.headernum = message.headernum;
          if (message.paraHeadernum != null && message.hasOwnProperty("paraHeadernum"))
            object.paraHeadernum = message.paraHeadernum;
          if (message.blocknum != null && message.hasOwnProperty("blocknum"))
            object.blocknum = message.blocknum;
          if (message.stateRoot != null && message.hasOwnProperty("stateRoot"))
            object.stateRoot = message.stateRoot;
          if (message.devMode != null && message.hasOwnProperty("devMode"))
            object.devMode = message.devMode;
          if (message.pendingMessages != null && message.hasOwnProperty("pendingMessages"))
            if (typeof message.pendingMessages === "number")
              object.pendingMessages = options2.longs === String ? String(message.pendingMessages) : message.pendingMessages;
            else
              object.pendingMessages = options2.longs === String ? $util.Long.prototype.toString.call(message.pendingMessages) : options2.longs === Number ? new $util.LongBits(message.pendingMessages.low >>> 0, message.pendingMessages.high >>> 0).toNumber(true) : message.pendingMessages;
          if (message.score != null && message.hasOwnProperty("score"))
            if (typeof message.score === "number")
              object.score = options2.longs === String ? String(message.score) : message.score;
            else
              object.score = options2.longs === String ? $util.Long.prototype.toString.call(message.score) : options2.longs === Number ? new $util.LongBits(message.score.low >>> 0, message.score.high >>> 0).toNumber(true) : message.score;
          if (message.gatekeeper != null && message.hasOwnProperty("gatekeeper"))
            object.gatekeeper = $root.pruntime_rpc.GatekeeperStatus.toObject(message.gatekeeper, options2);
          if (message.version != null && message.hasOwnProperty("version"))
            object.version = message.version;
          if (message.gitRevision != null && message.hasOwnProperty("gitRevision"))
            object.gitRevision = message.gitRevision;
          if (message.memoryUsage != null && message.hasOwnProperty("memoryUsage"))
            object.memoryUsage = $root.pruntime_rpc.MemoryUsage.toObject(message.memoryUsage, options2);
          if (message.waitingForParaheaders != null && message.hasOwnProperty("waitingForParaheaders"))
            object.waitingForParaheaders = message.waitingForParaheaders;
          if (message.system != null && message.hasOwnProperty("system"))
            object.system = $root.pruntime_rpc.SystemInfo.toObject(message.system, options2);
          if (message.canLoadChainState != null && message.hasOwnProperty("canLoadChainState"))
            object.canLoadChainState = message.canLoadChainState;
          if (message.safeModeLevel != null && message.hasOwnProperty("safeModeLevel"))
            object.safeModeLevel = message.safeModeLevel;
          if (message.currentBlockTime != null && message.hasOwnProperty("currentBlockTime"))
            if (typeof message.currentBlockTime === "number")
              object.currentBlockTime = options2.longs === String ? String(message.currentBlockTime) : message.currentBlockTime;
            else
              object.currentBlockTime = options2.longs === String ? $util.Long.prototype.toString.call(message.currentBlockTime) : options2.longs === Number ? new $util.LongBits(message.currentBlockTime.low >>> 0, message.currentBlockTime.high >>> 0).toNumber(true) : message.currentBlockTime;
          if (message.maxSupportedPinkRuntimeVersion != null && message.hasOwnProperty("maxSupportedPinkRuntimeVersion"))
            object.maxSupportedPinkRuntimeVersion = message.maxSupportedPinkRuntimeVersion;
          return object;
        };
        PhactoryInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        PhactoryInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.PhactoryInfo";
        };
        return PhactoryInfo;
      }();
      pruntime_rpc2.SystemInfo = function() {
        function SystemInfo(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        SystemInfo.prototype.registered = false;
        SystemInfo.prototype.publicKey = "";
        SystemInfo.prototype.ecdhPublicKey = "";
        SystemInfo.prototype.gatekeeper = null;
        SystemInfo.prototype.numberOfClusters = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        SystemInfo.prototype.numberOfContracts = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        SystemInfo.prototype.maxSupportedConsensusVersion = 0;
        SystemInfo.prototype.genesisBlock = 0;
        SystemInfo.create = function create(properties) {
          return new SystemInfo(properties);
        };
        SystemInfo.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.registered != null && Object.hasOwnProperty.call(message, "registered"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).bool(message.registered);
          if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.publicKey);
          if (message.ecdhPublicKey != null && Object.hasOwnProperty.call(message, "ecdhPublicKey"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.ecdhPublicKey);
          if (message.gatekeeper != null && Object.hasOwnProperty.call(message, "gatekeeper"))
            $root.pruntime_rpc.GatekeeperStatus.encode(message.gatekeeper, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          if (message.numberOfClusters != null && Object.hasOwnProperty.call(message, "numberOfClusters"))
            writer.uint32(
              /* id 5, wireType 0 =*/
              40
            ).uint64(message.numberOfClusters);
          if (message.numberOfContracts != null && Object.hasOwnProperty.call(message, "numberOfContracts"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).uint64(message.numberOfContracts);
          if (message.maxSupportedConsensusVersion != null && Object.hasOwnProperty.call(message, "maxSupportedConsensusVersion"))
            writer.uint32(
              /* id 7, wireType 0 =*/
              56
            ).uint32(message.maxSupportedConsensusVersion);
          if (message.genesisBlock != null && Object.hasOwnProperty.call(message, "genesisBlock"))
            writer.uint32(
              /* id 8, wireType 0 =*/
              64
            ).uint32(message.genesisBlock);
          return writer;
        };
        SystemInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        SystemInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.SystemInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.registered = reader.bool();
                break;
              }
              case 2: {
                message.publicKey = reader.string();
                break;
              }
              case 3: {
                message.ecdhPublicKey = reader.string();
                break;
              }
              case 4: {
                message.gatekeeper = $root.pruntime_rpc.GatekeeperStatus.decode(reader, reader.uint32());
                break;
              }
              case 5: {
                message.numberOfClusters = reader.uint64();
                break;
              }
              case 6: {
                message.numberOfContracts = reader.uint64();
                break;
              }
              case 7: {
                message.maxSupportedConsensusVersion = reader.uint32();
                break;
              }
              case 8: {
                message.genesisBlock = reader.uint32();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        SystemInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        SystemInfo.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.registered != null && message.hasOwnProperty("registered")) {
            if (typeof message.registered !== "boolean")
              return "registered: boolean expected";
          }
          if (message.publicKey != null && message.hasOwnProperty("publicKey")) {
            if (!$util.isString(message.publicKey))
              return "publicKey: string expected";
          }
          if (message.ecdhPublicKey != null && message.hasOwnProperty("ecdhPublicKey")) {
            if (!$util.isString(message.ecdhPublicKey))
              return "ecdhPublicKey: string expected";
          }
          if (message.gatekeeper != null && message.hasOwnProperty("gatekeeper")) {
            var error = $root.pruntime_rpc.GatekeeperStatus.verify(message.gatekeeper);
            if (error)
              return "gatekeeper." + error;
          }
          if (message.numberOfClusters != null && message.hasOwnProperty("numberOfClusters")) {
            if (!$util.isInteger(message.numberOfClusters) && !(message.numberOfClusters && $util.isInteger(message.numberOfClusters.low) && $util.isInteger(message.numberOfClusters.high)))
              return "numberOfClusters: integer|Long expected";
          }
          if (message.numberOfContracts != null && message.hasOwnProperty("numberOfContracts")) {
            if (!$util.isInteger(message.numberOfContracts) && !(message.numberOfContracts && $util.isInteger(message.numberOfContracts.low) && $util.isInteger(message.numberOfContracts.high)))
              return "numberOfContracts: integer|Long expected";
          }
          if (message.maxSupportedConsensusVersion != null && message.hasOwnProperty("maxSupportedConsensusVersion")) {
            if (!$util.isInteger(message.maxSupportedConsensusVersion))
              return "maxSupportedConsensusVersion: integer expected";
          }
          if (message.genesisBlock != null && message.hasOwnProperty("genesisBlock")) {
            if (!$util.isInteger(message.genesisBlock))
              return "genesisBlock: integer expected";
          }
          return null;
        };
        SystemInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.SystemInfo)
            return object;
          var message = new $root.pruntime_rpc.SystemInfo();
          if (object.registered != null)
            message.registered = Boolean(object.registered);
          if (object.publicKey != null)
            message.publicKey = String(object.publicKey);
          if (object.ecdhPublicKey != null)
            message.ecdhPublicKey = String(object.ecdhPublicKey);
          if (object.gatekeeper != null) {
            if (typeof object.gatekeeper !== "object")
              throw TypeError(".pruntime_rpc.SystemInfo.gatekeeper: object expected");
            message.gatekeeper = $root.pruntime_rpc.GatekeeperStatus.fromObject(object.gatekeeper);
          }
          if (object.numberOfClusters != null) {
            if ($util.Long)
              (message.numberOfClusters = $util.Long.fromValue(object.numberOfClusters)).unsigned = true;
            else if (typeof object.numberOfClusters === "string")
              message.numberOfClusters = parseInt(object.numberOfClusters, 10);
            else if (typeof object.numberOfClusters === "number")
              message.numberOfClusters = object.numberOfClusters;
            else if (typeof object.numberOfClusters === "object")
              message.numberOfClusters = new $util.LongBits(object.numberOfClusters.low >>> 0, object.numberOfClusters.high >>> 0).toNumber(true);
          }
          if (object.numberOfContracts != null) {
            if ($util.Long)
              (message.numberOfContracts = $util.Long.fromValue(object.numberOfContracts)).unsigned = true;
            else if (typeof object.numberOfContracts === "string")
              message.numberOfContracts = parseInt(object.numberOfContracts, 10);
            else if (typeof object.numberOfContracts === "number")
              message.numberOfContracts = object.numberOfContracts;
            else if (typeof object.numberOfContracts === "object")
              message.numberOfContracts = new $util.LongBits(object.numberOfContracts.low >>> 0, object.numberOfContracts.high >>> 0).toNumber(true);
          }
          if (object.maxSupportedConsensusVersion != null)
            message.maxSupportedConsensusVersion = object.maxSupportedConsensusVersion >>> 0;
          if (object.genesisBlock != null)
            message.genesisBlock = object.genesisBlock >>> 0;
          return message;
        };
        SystemInfo.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.registered = false;
            object.publicKey = "";
            object.ecdhPublicKey = "";
            object.gatekeeper = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.numberOfClusters = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.numberOfClusters = options2.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.numberOfContracts = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.numberOfContracts = options2.longs === String ? "0" : 0;
            object.maxSupportedConsensusVersion = 0;
            object.genesisBlock = 0;
          }
          if (message.registered != null && message.hasOwnProperty("registered"))
            object.registered = message.registered;
          if (message.publicKey != null && message.hasOwnProperty("publicKey"))
            object.publicKey = message.publicKey;
          if (message.ecdhPublicKey != null && message.hasOwnProperty("ecdhPublicKey"))
            object.ecdhPublicKey = message.ecdhPublicKey;
          if (message.gatekeeper != null && message.hasOwnProperty("gatekeeper"))
            object.gatekeeper = $root.pruntime_rpc.GatekeeperStatus.toObject(message.gatekeeper, options2);
          if (message.numberOfClusters != null && message.hasOwnProperty("numberOfClusters"))
            if (typeof message.numberOfClusters === "number")
              object.numberOfClusters = options2.longs === String ? String(message.numberOfClusters) : message.numberOfClusters;
            else
              object.numberOfClusters = options2.longs === String ? $util.Long.prototype.toString.call(message.numberOfClusters) : options2.longs === Number ? new $util.LongBits(message.numberOfClusters.low >>> 0, message.numberOfClusters.high >>> 0).toNumber(true) : message.numberOfClusters;
          if (message.numberOfContracts != null && message.hasOwnProperty("numberOfContracts"))
            if (typeof message.numberOfContracts === "number")
              object.numberOfContracts = options2.longs === String ? String(message.numberOfContracts) : message.numberOfContracts;
            else
              object.numberOfContracts = options2.longs === String ? $util.Long.prototype.toString.call(message.numberOfContracts) : options2.longs === Number ? new $util.LongBits(message.numberOfContracts.low >>> 0, message.numberOfContracts.high >>> 0).toNumber(true) : message.numberOfContracts;
          if (message.maxSupportedConsensusVersion != null && message.hasOwnProperty("maxSupportedConsensusVersion"))
            object.maxSupportedConsensusVersion = message.maxSupportedConsensusVersion;
          if (message.genesisBlock != null && message.hasOwnProperty("genesisBlock"))
            object.genesisBlock = message.genesisBlock;
          return object;
        };
        SystemInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        SystemInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.SystemInfo";
        };
        return SystemInfo;
      }();
      pruntime_rpc2.GatekeeperRole = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "None"] = 0;
        values[valuesById[1] = "Dummy"] = 1;
        values[valuesById[2] = "Active"] = 2;
        return values;
      }();
      pruntime_rpc2.GatekeeperStatus = function() {
        function GatekeeperStatus(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        GatekeeperStatus.prototype.role = 0;
        GatekeeperStatus.prototype.masterPublicKey = "";
        GatekeeperStatus.create = function create(properties) {
          return new GatekeeperStatus(properties);
        };
        GatekeeperStatus.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.role != null && Object.hasOwnProperty.call(message, "role"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.role);
          if (message.masterPublicKey != null && Object.hasOwnProperty.call(message, "masterPublicKey"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.masterPublicKey);
          return writer;
        };
        GatekeeperStatus.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        GatekeeperStatus.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.GatekeeperStatus();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.role = reader.int32();
                break;
              }
              case 2: {
                message.masterPublicKey = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        GatekeeperStatus.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        GatekeeperStatus.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.role != null && message.hasOwnProperty("role"))
            switch (message.role) {
              default:
                return "role: enum value expected";
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey")) {
            if (!$util.isString(message.masterPublicKey))
              return "masterPublicKey: string expected";
          }
          return null;
        };
        GatekeeperStatus.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.GatekeeperStatus)
            return object;
          var message = new $root.pruntime_rpc.GatekeeperStatus();
          switch (object.role) {
            default:
              if (typeof object.role === "number") {
                message.role = object.role;
                break;
              }
              break;
            case "None":
            case 0:
              message.role = 0;
              break;
            case "Dummy":
            case 1:
              message.role = 1;
              break;
            case "Active":
            case 2:
              message.role = 2;
              break;
          }
          if (object.masterPublicKey != null)
            message.masterPublicKey = String(object.masterPublicKey);
          return message;
        };
        GatekeeperStatus.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.role = options2.enums === String ? "None" : 0;
            object.masterPublicKey = "";
          }
          if (message.role != null && message.hasOwnProperty("role"))
            object.role = options2.enums === String ? $root.pruntime_rpc.GatekeeperRole[message.role] === void 0 ? message.role : $root.pruntime_rpc.GatekeeperRole[message.role] : message.role;
          if (message.masterPublicKey != null && message.hasOwnProperty("masterPublicKey"))
            object.masterPublicKey = message.masterPublicKey;
          return object;
        };
        GatekeeperStatus.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        GatekeeperStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.GatekeeperStatus";
        };
        return GatekeeperStatus;
      }();
      pruntime_rpc2.MemoryUsage = function() {
        function MemoryUsage(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        MemoryUsage.prototype.rustUsed = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        MemoryUsage.prototype.rustPeakUsed = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        MemoryUsage.prototype.totalPeakUsed = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        MemoryUsage.prototype.free = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        MemoryUsage.prototype.rustSpike = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        MemoryUsage.create = function create(properties) {
          return new MemoryUsage(properties);
        };
        MemoryUsage.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.rustUsed != null && Object.hasOwnProperty.call(message, "rustUsed"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).uint64(message.rustUsed);
          if (message.rustPeakUsed != null && Object.hasOwnProperty.call(message, "rustPeakUsed"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint64(message.rustPeakUsed);
          if (message.totalPeakUsed != null && Object.hasOwnProperty.call(message, "totalPeakUsed"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint64(message.totalPeakUsed);
          if (message.free != null && Object.hasOwnProperty.call(message, "free"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).uint64(message.free);
          if (message.rustSpike != null && Object.hasOwnProperty.call(message, "rustSpike"))
            writer.uint32(
              /* id 5, wireType 0 =*/
              40
            ).uint64(message.rustSpike);
          return writer;
        };
        MemoryUsage.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        MemoryUsage.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.MemoryUsage();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.rustUsed = reader.uint64();
                break;
              }
              case 2: {
                message.rustPeakUsed = reader.uint64();
                break;
              }
              case 3: {
                message.totalPeakUsed = reader.uint64();
                break;
              }
              case 4: {
                message.free = reader.uint64();
                break;
              }
              case 5: {
                message.rustSpike = reader.uint64();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        MemoryUsage.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        MemoryUsage.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.rustUsed != null && message.hasOwnProperty("rustUsed")) {
            if (!$util.isInteger(message.rustUsed) && !(message.rustUsed && $util.isInteger(message.rustUsed.low) && $util.isInteger(message.rustUsed.high)))
              return "rustUsed: integer|Long expected";
          }
          if (message.rustPeakUsed != null && message.hasOwnProperty("rustPeakUsed")) {
            if (!$util.isInteger(message.rustPeakUsed) && !(message.rustPeakUsed && $util.isInteger(message.rustPeakUsed.low) && $util.isInteger(message.rustPeakUsed.high)))
              return "rustPeakUsed: integer|Long expected";
          }
          if (message.totalPeakUsed != null && message.hasOwnProperty("totalPeakUsed")) {
            if (!$util.isInteger(message.totalPeakUsed) && !(message.totalPeakUsed && $util.isInteger(message.totalPeakUsed.low) && $util.isInteger(message.totalPeakUsed.high)))
              return "totalPeakUsed: integer|Long expected";
          }
          if (message.free != null && message.hasOwnProperty("free")) {
            if (!$util.isInteger(message.free) && !(message.free && $util.isInteger(message.free.low) && $util.isInteger(message.free.high)))
              return "free: integer|Long expected";
          }
          if (message.rustSpike != null && message.hasOwnProperty("rustSpike")) {
            if (!$util.isInteger(message.rustSpike) && !(message.rustSpike && $util.isInteger(message.rustSpike.low) && $util.isInteger(message.rustSpike.high)))
              return "rustSpike: integer|Long expected";
          }
          return null;
        };
        MemoryUsage.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.MemoryUsage)
            return object;
          var message = new $root.pruntime_rpc.MemoryUsage();
          if (object.rustUsed != null) {
            if ($util.Long)
              (message.rustUsed = $util.Long.fromValue(object.rustUsed)).unsigned = true;
            else if (typeof object.rustUsed === "string")
              message.rustUsed = parseInt(object.rustUsed, 10);
            else if (typeof object.rustUsed === "number")
              message.rustUsed = object.rustUsed;
            else if (typeof object.rustUsed === "object")
              message.rustUsed = new $util.LongBits(object.rustUsed.low >>> 0, object.rustUsed.high >>> 0).toNumber(true);
          }
          if (object.rustPeakUsed != null) {
            if ($util.Long)
              (message.rustPeakUsed = $util.Long.fromValue(object.rustPeakUsed)).unsigned = true;
            else if (typeof object.rustPeakUsed === "string")
              message.rustPeakUsed = parseInt(object.rustPeakUsed, 10);
            else if (typeof object.rustPeakUsed === "number")
              message.rustPeakUsed = object.rustPeakUsed;
            else if (typeof object.rustPeakUsed === "object")
              message.rustPeakUsed = new $util.LongBits(object.rustPeakUsed.low >>> 0, object.rustPeakUsed.high >>> 0).toNumber(true);
          }
          if (object.totalPeakUsed != null) {
            if ($util.Long)
              (message.totalPeakUsed = $util.Long.fromValue(object.totalPeakUsed)).unsigned = true;
            else if (typeof object.totalPeakUsed === "string")
              message.totalPeakUsed = parseInt(object.totalPeakUsed, 10);
            else if (typeof object.totalPeakUsed === "number")
              message.totalPeakUsed = object.totalPeakUsed;
            else if (typeof object.totalPeakUsed === "object")
              message.totalPeakUsed = new $util.LongBits(object.totalPeakUsed.low >>> 0, object.totalPeakUsed.high >>> 0).toNumber(true);
          }
          if (object.free != null) {
            if ($util.Long)
              (message.free = $util.Long.fromValue(object.free)).unsigned = true;
            else if (typeof object.free === "string")
              message.free = parseInt(object.free, 10);
            else if (typeof object.free === "number")
              message.free = object.free;
            else if (typeof object.free === "object")
              message.free = new $util.LongBits(object.free.low >>> 0, object.free.high >>> 0).toNumber(true);
          }
          if (object.rustSpike != null) {
            if ($util.Long)
              (message.rustSpike = $util.Long.fromValue(object.rustSpike)).unsigned = true;
            else if (typeof object.rustSpike === "string")
              message.rustSpike = parseInt(object.rustSpike, 10);
            else if (typeof object.rustSpike === "number")
              message.rustSpike = object.rustSpike;
            else if (typeof object.rustSpike === "object")
              message.rustSpike = new $util.LongBits(object.rustSpike.low >>> 0, object.rustSpike.high >>> 0).toNumber(true);
          }
          return message;
        };
        MemoryUsage.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.rustUsed = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.rustUsed = options2.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.rustPeakUsed = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.rustPeakUsed = options2.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.totalPeakUsed = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.totalPeakUsed = options2.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.free = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.free = options2.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.rustSpike = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.rustSpike = options2.longs === String ? "0" : 0;
          }
          if (message.rustUsed != null && message.hasOwnProperty("rustUsed"))
            if (typeof message.rustUsed === "number")
              object.rustUsed = options2.longs === String ? String(message.rustUsed) : message.rustUsed;
            else
              object.rustUsed = options2.longs === String ? $util.Long.prototype.toString.call(message.rustUsed) : options2.longs === Number ? new $util.LongBits(message.rustUsed.low >>> 0, message.rustUsed.high >>> 0).toNumber(true) : message.rustUsed;
          if (message.rustPeakUsed != null && message.hasOwnProperty("rustPeakUsed"))
            if (typeof message.rustPeakUsed === "number")
              object.rustPeakUsed = options2.longs === String ? String(message.rustPeakUsed) : message.rustPeakUsed;
            else
              object.rustPeakUsed = options2.longs === String ? $util.Long.prototype.toString.call(message.rustPeakUsed) : options2.longs === Number ? new $util.LongBits(message.rustPeakUsed.low >>> 0, message.rustPeakUsed.high >>> 0).toNumber(true) : message.rustPeakUsed;
          if (message.totalPeakUsed != null && message.hasOwnProperty("totalPeakUsed"))
            if (typeof message.totalPeakUsed === "number")
              object.totalPeakUsed = options2.longs === String ? String(message.totalPeakUsed) : message.totalPeakUsed;
            else
              object.totalPeakUsed = options2.longs === String ? $util.Long.prototype.toString.call(message.totalPeakUsed) : options2.longs === Number ? new $util.LongBits(message.totalPeakUsed.low >>> 0, message.totalPeakUsed.high >>> 0).toNumber(true) : message.totalPeakUsed;
          if (message.free != null && message.hasOwnProperty("free"))
            if (typeof message.free === "number")
              object.free = options2.longs === String ? String(message.free) : message.free;
            else
              object.free = options2.longs === String ? $util.Long.prototype.toString.call(message.free) : options2.longs === Number ? new $util.LongBits(message.free.low >>> 0, message.free.high >>> 0).toNumber(true) : message.free;
          if (message.rustSpike != null && message.hasOwnProperty("rustSpike"))
            if (typeof message.rustSpike === "number")
              object.rustSpike = options2.longs === String ? String(message.rustSpike) : message.rustSpike;
            else
              object.rustSpike = options2.longs === String ? $util.Long.prototype.toString.call(message.rustSpike) : options2.longs === Number ? new $util.LongBits(message.rustSpike.low >>> 0, message.rustSpike.high >>> 0).toNumber(true) : message.rustSpike;
          return object;
        };
        MemoryUsage.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        MemoryUsage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.MemoryUsage";
        };
        return MemoryUsage;
      }();
      pruntime_rpc2.GetRuntimeInfoRequest = function() {
        function GetRuntimeInfoRequest(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        GetRuntimeInfoRequest.prototype.forceRefreshRa = false;
        GetRuntimeInfoRequest.prototype.encodedOperator = null;
        var $oneOfFields;
        Object.defineProperty(GetRuntimeInfoRequest.prototype, "_encodedOperator", {
          get: $util.oneOfGetter($oneOfFields = ["encodedOperator"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        GetRuntimeInfoRequest.create = function create(properties) {
          return new GetRuntimeInfoRequest(properties);
        };
        GetRuntimeInfoRequest.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.forceRefreshRa != null && Object.hasOwnProperty.call(message, "forceRefreshRa"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).bool(message.forceRefreshRa);
          if (message.encodedOperator != null && Object.hasOwnProperty.call(message, "encodedOperator"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.encodedOperator);
          return writer;
        };
        GetRuntimeInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        GetRuntimeInfoRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.GetRuntimeInfoRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.forceRefreshRa = reader.bool();
                break;
              }
              case 2: {
                message.encodedOperator = reader.bytes();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        GetRuntimeInfoRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        GetRuntimeInfoRequest.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.forceRefreshRa != null && message.hasOwnProperty("forceRefreshRa")) {
            if (typeof message.forceRefreshRa !== "boolean")
              return "forceRefreshRa: boolean expected";
          }
          if (message.encodedOperator != null && message.hasOwnProperty("encodedOperator")) {
            properties._encodedOperator = 1;
            if (!(message.encodedOperator && typeof message.encodedOperator.length === "number" || $util.isString(message.encodedOperator)))
              return "encodedOperator: buffer expected";
          }
          return null;
        };
        GetRuntimeInfoRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.GetRuntimeInfoRequest)
            return object;
          var message = new $root.pruntime_rpc.GetRuntimeInfoRequest();
          if (object.forceRefreshRa != null)
            message.forceRefreshRa = Boolean(object.forceRefreshRa);
          if (object.encodedOperator != null) {
            if (typeof object.encodedOperator === "string")
              $util.base64.decode(object.encodedOperator, message.encodedOperator = $util.newBuffer($util.base64.length(object.encodedOperator)), 0);
            else if (object.encodedOperator.length >= 0)
              message.encodedOperator = object.encodedOperator;
          }
          return message;
        };
        GetRuntimeInfoRequest.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults)
            object.forceRefreshRa = false;
          if (message.forceRefreshRa != null && message.hasOwnProperty("forceRefreshRa"))
            object.forceRefreshRa = message.forceRefreshRa;
          if (message.encodedOperator != null && message.hasOwnProperty("encodedOperator")) {
            object.encodedOperator = options2.bytes === String ? $util.base64.encode(message.encodedOperator, 0, message.encodedOperator.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedOperator) : message.encodedOperator;
            if (options2.oneofs)
              object._encodedOperator = "encodedOperator";
          }
          return object;
        };
        GetRuntimeInfoRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        GetRuntimeInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.GetRuntimeInfoRequest";
        };
        return GetRuntimeInfoRequest;
      }();
      pruntime_rpc2.InitRuntimeResponse = function() {
        function InitRuntimeResponse(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        InitRuntimeResponse.prototype.encodedRuntimeInfo = $util.newBuffer([]);
        InitRuntimeResponse.prototype.encodedGenesisBlockHash = $util.newBuffer([]);
        InitRuntimeResponse.prototype.encodedPublicKey = $util.newBuffer([]);
        InitRuntimeResponse.prototype.encodedEcdhPublicKey = $util.newBuffer([]);
        InitRuntimeResponse.prototype.attestation = null;
        var $oneOfFields;
        Object.defineProperty(InitRuntimeResponse.prototype, "_attestation", {
          get: $util.oneOfGetter($oneOfFields = ["attestation"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        InitRuntimeResponse.create = function create(properties) {
          return new InitRuntimeResponse(properties);
        };
        InitRuntimeResponse.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.encodedRuntimeInfo != null && Object.hasOwnProperty.call(message, "encodedRuntimeInfo"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.encodedRuntimeInfo);
          if (message.encodedGenesisBlockHash != null && Object.hasOwnProperty.call(message, "encodedGenesisBlockHash"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.encodedGenesisBlockHash);
          if (message.encodedPublicKey != null && Object.hasOwnProperty.call(message, "encodedPublicKey"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).bytes(message.encodedPublicKey);
          if (message.encodedEcdhPublicKey != null && Object.hasOwnProperty.call(message, "encodedEcdhPublicKey"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).bytes(message.encodedEcdhPublicKey);
          if (message.attestation != null && Object.hasOwnProperty.call(message, "attestation"))
            $root.pruntime_rpc.Attestation.encode(message.attestation, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          return writer;
        };
        InitRuntimeResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        InitRuntimeResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.InitRuntimeResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.encodedRuntimeInfo = reader.bytes();
                break;
              }
              case 2: {
                message.encodedGenesisBlockHash = reader.bytes();
                break;
              }
              case 3: {
                message.encodedPublicKey = reader.bytes();
                break;
              }
              case 4: {
                message.encodedEcdhPublicKey = reader.bytes();
                break;
              }
              case 5: {
                message.attestation = $root.pruntime_rpc.Attestation.decode(reader, reader.uint32());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        InitRuntimeResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        InitRuntimeResponse.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.encodedRuntimeInfo != null && message.hasOwnProperty("encodedRuntimeInfo")) {
            if (!(message.encodedRuntimeInfo && typeof message.encodedRuntimeInfo.length === "number" || $util.isString(message.encodedRuntimeInfo)))
              return "encodedRuntimeInfo: buffer expected";
          }
          if (message.encodedGenesisBlockHash != null && message.hasOwnProperty("encodedGenesisBlockHash")) {
            if (!(message.encodedGenesisBlockHash && typeof message.encodedGenesisBlockHash.length === "number" || $util.isString(message.encodedGenesisBlockHash)))
              return "encodedGenesisBlockHash: buffer expected";
          }
          if (message.encodedPublicKey != null && message.hasOwnProperty("encodedPublicKey")) {
            if (!(message.encodedPublicKey && typeof message.encodedPublicKey.length === "number" || $util.isString(message.encodedPublicKey)))
              return "encodedPublicKey: buffer expected";
          }
          if (message.encodedEcdhPublicKey != null && message.hasOwnProperty("encodedEcdhPublicKey")) {
            if (!(message.encodedEcdhPublicKey && typeof message.encodedEcdhPublicKey.length === "number" || $util.isString(message.encodedEcdhPublicKey)))
              return "encodedEcdhPublicKey: buffer expected";
          }
          if (message.attestation != null && message.hasOwnProperty("attestation")) {
            properties._attestation = 1;
            {
              var error = $root.pruntime_rpc.Attestation.verify(message.attestation);
              if (error)
                return "attestation." + error;
            }
          }
          return null;
        };
        InitRuntimeResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.InitRuntimeResponse)
            return object;
          var message = new $root.pruntime_rpc.InitRuntimeResponse();
          if (object.encodedRuntimeInfo != null) {
            if (typeof object.encodedRuntimeInfo === "string")
              $util.base64.decode(object.encodedRuntimeInfo, message.encodedRuntimeInfo = $util.newBuffer($util.base64.length(object.encodedRuntimeInfo)), 0);
            else if (object.encodedRuntimeInfo.length >= 0)
              message.encodedRuntimeInfo = object.encodedRuntimeInfo;
          }
          if (object.encodedGenesisBlockHash != null) {
            if (typeof object.encodedGenesisBlockHash === "string")
              $util.base64.decode(object.encodedGenesisBlockHash, message.encodedGenesisBlockHash = $util.newBuffer($util.base64.length(object.encodedGenesisBlockHash)), 0);
            else if (object.encodedGenesisBlockHash.length >= 0)
              message.encodedGenesisBlockHash = object.encodedGenesisBlockHash;
          }
          if (object.encodedPublicKey != null) {
            if (typeof object.encodedPublicKey === "string")
              $util.base64.decode(object.encodedPublicKey, message.encodedPublicKey = $util.newBuffer($util.base64.length(object.encodedPublicKey)), 0);
            else if (object.encodedPublicKey.length >= 0)
              message.encodedPublicKey = object.encodedPublicKey;
          }
          if (object.encodedEcdhPublicKey != null) {
            if (typeof object.encodedEcdhPublicKey === "string")
              $util.base64.decode(object.encodedEcdhPublicKey, message.encodedEcdhPublicKey = $util.newBuffer($util.base64.length(object.encodedEcdhPublicKey)), 0);
            else if (object.encodedEcdhPublicKey.length >= 0)
              message.encodedEcdhPublicKey = object.encodedEcdhPublicKey;
          }
          if (object.attestation != null) {
            if (typeof object.attestation !== "object")
              throw TypeError(".pruntime_rpc.InitRuntimeResponse.attestation: object expected");
            message.attestation = $root.pruntime_rpc.Attestation.fromObject(object.attestation);
          }
          return message;
        };
        InitRuntimeResponse.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            if (options2.bytes === String)
              object.encodedRuntimeInfo = "";
            else {
              object.encodedRuntimeInfo = [];
              if (options2.bytes !== Array)
                object.encodedRuntimeInfo = $util.newBuffer(object.encodedRuntimeInfo);
            }
            if (options2.bytes === String)
              object.encodedGenesisBlockHash = "";
            else {
              object.encodedGenesisBlockHash = [];
              if (options2.bytes !== Array)
                object.encodedGenesisBlockHash = $util.newBuffer(object.encodedGenesisBlockHash);
            }
            if (options2.bytes === String)
              object.encodedPublicKey = "";
            else {
              object.encodedPublicKey = [];
              if (options2.bytes !== Array)
                object.encodedPublicKey = $util.newBuffer(object.encodedPublicKey);
            }
            if (options2.bytes === String)
              object.encodedEcdhPublicKey = "";
            else {
              object.encodedEcdhPublicKey = [];
              if (options2.bytes !== Array)
                object.encodedEcdhPublicKey = $util.newBuffer(object.encodedEcdhPublicKey);
            }
          }
          if (message.encodedRuntimeInfo != null && message.hasOwnProperty("encodedRuntimeInfo"))
            object.encodedRuntimeInfo = options2.bytes === String ? $util.base64.encode(message.encodedRuntimeInfo, 0, message.encodedRuntimeInfo.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedRuntimeInfo) : message.encodedRuntimeInfo;
          if (message.encodedGenesisBlockHash != null && message.hasOwnProperty("encodedGenesisBlockHash"))
            object.encodedGenesisBlockHash = options2.bytes === String ? $util.base64.encode(message.encodedGenesisBlockHash, 0, message.encodedGenesisBlockHash.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedGenesisBlockHash) : message.encodedGenesisBlockHash;
          if (message.encodedPublicKey != null && message.hasOwnProperty("encodedPublicKey"))
            object.encodedPublicKey = options2.bytes === String ? $util.base64.encode(message.encodedPublicKey, 0, message.encodedPublicKey.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedPublicKey) : message.encodedPublicKey;
          if (message.encodedEcdhPublicKey != null && message.hasOwnProperty("encodedEcdhPublicKey"))
            object.encodedEcdhPublicKey = options2.bytes === String ? $util.base64.encode(message.encodedEcdhPublicKey, 0, message.encodedEcdhPublicKey.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedEcdhPublicKey) : message.encodedEcdhPublicKey;
          if (message.attestation != null && message.hasOwnProperty("attestation")) {
            object.attestation = $root.pruntime_rpc.Attestation.toObject(message.attestation, options2);
            if (options2.oneofs)
              object._attestation = "attestation";
          }
          return object;
        };
        InitRuntimeResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        InitRuntimeResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.InitRuntimeResponse";
        };
        return InitRuntimeResponse;
      }();
      pruntime_rpc2.Attestation = function() {
        function Attestation(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Attestation.prototype.version = 0;
        Attestation.prototype.provider = "";
        Attestation.prototype.payload = null;
        Attestation.prototype.encodedReport = $util.newBuffer([]);
        Attestation.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        Attestation.create = function create(properties) {
          return new Attestation(properties);
        };
        Attestation.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.version);
          if (message.provider != null && Object.hasOwnProperty.call(message, "provider"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.provider);
          if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
            $root.pruntime_rpc.AttestationReport.encode(message.payload, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).uint64(message.timestamp);
          if (message.encodedReport != null && Object.hasOwnProperty.call(message, "encodedReport"))
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).bytes(message.encodedReport);
          return writer;
        };
        Attestation.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Attestation.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.Attestation();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.version = reader.int32();
                break;
              }
              case 2: {
                message.provider = reader.string();
                break;
              }
              case 3: {
                message.payload = $root.pruntime_rpc.AttestationReport.decode(reader, reader.uint32());
                break;
              }
              case 5: {
                message.encodedReport = reader.bytes();
                break;
              }
              case 4: {
                message.timestamp = reader.uint64();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Attestation.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Attestation.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.version != null && message.hasOwnProperty("version")) {
            if (!$util.isInteger(message.version))
              return "version: integer expected";
          }
          if (message.provider != null && message.hasOwnProperty("provider")) {
            if (!$util.isString(message.provider))
              return "provider: string expected";
          }
          if (message.payload != null && message.hasOwnProperty("payload")) {
            var error = $root.pruntime_rpc.AttestationReport.verify(message.payload);
            if (error)
              return "payload." + error;
          }
          if (message.encodedReport != null && message.hasOwnProperty("encodedReport")) {
            if (!(message.encodedReport && typeof message.encodedReport.length === "number" || $util.isString(message.encodedReport)))
              return "encodedReport: buffer expected";
          }
          if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
              return "timestamp: integer|Long expected";
          }
          return null;
        };
        Attestation.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.Attestation)
            return object;
          var message = new $root.pruntime_rpc.Attestation();
          if (object.version != null)
            message.version = object.version | 0;
          if (object.provider != null)
            message.provider = String(object.provider);
          if (object.payload != null) {
            if (typeof object.payload !== "object")
              throw TypeError(".pruntime_rpc.Attestation.payload: object expected");
            message.payload = $root.pruntime_rpc.AttestationReport.fromObject(object.payload);
          }
          if (object.encodedReport != null) {
            if (typeof object.encodedReport === "string")
              $util.base64.decode(object.encodedReport, message.encodedReport = $util.newBuffer($util.base64.length(object.encodedReport)), 0);
            else if (object.encodedReport.length >= 0)
              message.encodedReport = object.encodedReport;
          }
          if (object.timestamp != null) {
            if ($util.Long)
              (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
            else if (typeof object.timestamp === "string")
              message.timestamp = parseInt(object.timestamp, 10);
            else if (typeof object.timestamp === "number")
              message.timestamp = object.timestamp;
            else if (typeof object.timestamp === "object")
              message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
          }
          return message;
        };
        Attestation.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.version = 0;
            object.provider = "";
            object.payload = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.timestamp = options2.longs === String ? long.toString() : options2.longs === Number ? long.toNumber() : long;
            } else
              object.timestamp = options2.longs === String ? "0" : 0;
            if (options2.bytes === String)
              object.encodedReport = "";
            else {
              object.encodedReport = [];
              if (options2.bytes !== Array)
                object.encodedReport = $util.newBuffer(object.encodedReport);
            }
          }
          if (message.version != null && message.hasOwnProperty("version"))
            object.version = message.version;
          if (message.provider != null && message.hasOwnProperty("provider"))
            object.provider = message.provider;
          if (message.payload != null && message.hasOwnProperty("payload"))
            object.payload = $root.pruntime_rpc.AttestationReport.toObject(message.payload, options2);
          if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (typeof message.timestamp === "number")
              object.timestamp = options2.longs === String ? String(message.timestamp) : message.timestamp;
            else
              object.timestamp = options2.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options2.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
          if (message.encodedReport != null && message.hasOwnProperty("encodedReport"))
            object.encodedReport = options2.bytes === String ? $util.base64.encode(message.encodedReport, 0, message.encodedReport.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedReport) : message.encodedReport;
          return object;
        };
        Attestation.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        Attestation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.Attestation";
        };
        return Attestation;
      }();
      pruntime_rpc2.AttestationReport = function() {
        function AttestationReport(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        AttestationReport.prototype.report = "";
        AttestationReport.prototype.signature = $util.newBuffer([]);
        AttestationReport.prototype.signingCert = $util.newBuffer([]);
        AttestationReport.create = function create(properties) {
          return new AttestationReport(properties);
        };
        AttestationReport.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.report != null && Object.hasOwnProperty.call(message, "report"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.report);
          if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.signature);
          if (message.signingCert != null && Object.hasOwnProperty.call(message, "signingCert"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).bytes(message.signingCert);
          return writer;
        };
        AttestationReport.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        AttestationReport.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.AttestationReport();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.report = reader.string();
                break;
              }
              case 2: {
                message.signature = reader.bytes();
                break;
              }
              case 3: {
                message.signingCert = reader.bytes();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        AttestationReport.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        AttestationReport.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.report != null && message.hasOwnProperty("report")) {
            if (!$util.isString(message.report))
              return "report: string expected";
          }
          if (message.signature != null && message.hasOwnProperty("signature")) {
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
              return "signature: buffer expected";
          }
          if (message.signingCert != null && message.hasOwnProperty("signingCert")) {
            if (!(message.signingCert && typeof message.signingCert.length === "number" || $util.isString(message.signingCert)))
              return "signingCert: buffer expected";
          }
          return null;
        };
        AttestationReport.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.AttestationReport)
            return object;
          var message = new $root.pruntime_rpc.AttestationReport();
          if (object.report != null)
            message.report = String(object.report);
          if (object.signature != null) {
            if (typeof object.signature === "string")
              $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length >= 0)
              message.signature = object.signature;
          }
          if (object.signingCert != null) {
            if (typeof object.signingCert === "string")
              $util.base64.decode(object.signingCert, message.signingCert = $util.newBuffer($util.base64.length(object.signingCert)), 0);
            else if (object.signingCert.length >= 0)
              message.signingCert = object.signingCert;
          }
          return message;
        };
        AttestationReport.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.report = "";
            if (options2.bytes === String)
              object.signature = "";
            else {
              object.signature = [];
              if (options2.bytes !== Array)
                object.signature = $util.newBuffer(object.signature);
            }
            if (options2.bytes === String)
              object.signingCert = "";
            else {
              object.signingCert = [];
              if (options2.bytes !== Array)
                object.signingCert = $util.newBuffer(object.signingCert);
            }
          }
          if (message.report != null && message.hasOwnProperty("report"))
            object.report = message.report;
          if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = options2.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options2.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
          if (message.signingCert != null && message.hasOwnProperty("signingCert"))
            object.signingCert = options2.bytes === String ? $util.base64.encode(message.signingCert, 0, message.signingCert.length) : options2.bytes === Array ? Array.prototype.slice.call(message.signingCert) : message.signingCert;
          return object;
        };
        AttestationReport.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        AttestationReport.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.AttestationReport";
        };
        return AttestationReport;
      }();
      pruntime_rpc2.ContractQueryRequest = function() {
        function ContractQueryRequest(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ContractQueryRequest.prototype.encodedEncryptedData = $util.newBuffer([]);
        ContractQueryRequest.prototype.signature = null;
        ContractQueryRequest.create = function create(properties) {
          return new ContractQueryRequest(properties);
        };
        ContractQueryRequest.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.encodedEncryptedData != null && Object.hasOwnProperty.call(message, "encodedEncryptedData"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.encodedEncryptedData);
          if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            $root.pruntime_rpc.Signature.encode(message.signature, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          return writer;
        };
        ContractQueryRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ContractQueryRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.ContractQueryRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.encodedEncryptedData = reader.bytes();
                break;
              }
              case 2: {
                message.signature = $root.pruntime_rpc.Signature.decode(reader, reader.uint32());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ContractQueryRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ContractQueryRequest.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.encodedEncryptedData != null && message.hasOwnProperty("encodedEncryptedData")) {
            if (!(message.encodedEncryptedData && typeof message.encodedEncryptedData.length === "number" || $util.isString(message.encodedEncryptedData)))
              return "encodedEncryptedData: buffer expected";
          }
          if (message.signature != null && message.hasOwnProperty("signature")) {
            var error = $root.pruntime_rpc.Signature.verify(message.signature);
            if (error)
              return "signature." + error;
          }
          return null;
        };
        ContractQueryRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.ContractQueryRequest)
            return object;
          var message = new $root.pruntime_rpc.ContractQueryRequest();
          if (object.encodedEncryptedData != null) {
            if (typeof object.encodedEncryptedData === "string")
              $util.base64.decode(object.encodedEncryptedData, message.encodedEncryptedData = $util.newBuffer($util.base64.length(object.encodedEncryptedData)), 0);
            else if (object.encodedEncryptedData.length >= 0)
              message.encodedEncryptedData = object.encodedEncryptedData;
          }
          if (object.signature != null) {
            if (typeof object.signature !== "object")
              throw TypeError(".pruntime_rpc.ContractQueryRequest.signature: object expected");
            message.signature = $root.pruntime_rpc.Signature.fromObject(object.signature);
          }
          return message;
        };
        ContractQueryRequest.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            if (options2.bytes === String)
              object.encodedEncryptedData = "";
            else {
              object.encodedEncryptedData = [];
              if (options2.bytes !== Array)
                object.encodedEncryptedData = $util.newBuffer(object.encodedEncryptedData);
            }
            object.signature = null;
          }
          if (message.encodedEncryptedData != null && message.hasOwnProperty("encodedEncryptedData"))
            object.encodedEncryptedData = options2.bytes === String ? $util.base64.encode(message.encodedEncryptedData, 0, message.encodedEncryptedData.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedEncryptedData) : message.encodedEncryptedData;
          if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = $root.pruntime_rpc.Signature.toObject(message.signature, options2);
          return object;
        };
        ContractQueryRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ContractQueryRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.ContractQueryRequest";
        };
        return ContractQueryRequest;
      }();
      pruntime_rpc2.Signature = function() {
        function Signature(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Signature.prototype.signedBy = null;
        Signature.prototype.signatureType = 0;
        Signature.prototype.signature = $util.newBuffer([]);
        Signature.create = function create(properties) {
          return new Signature(properties);
        };
        Signature.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.signedBy != null && Object.hasOwnProperty.call(message, "signedBy"))
            $root.pruntime_rpc.Certificate.encode(message.signedBy, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.signatureType != null && Object.hasOwnProperty.call(message, "signatureType"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int32(message.signatureType);
          if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).bytes(message.signature);
          return writer;
        };
        Signature.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Signature.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.Signature();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.signedBy = $root.pruntime_rpc.Certificate.decode(reader, reader.uint32());
                break;
              }
              case 2: {
                message.signatureType = reader.int32();
                break;
              }
              case 3: {
                message.signature = reader.bytes();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Signature.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Signature.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.signedBy != null && message.hasOwnProperty("signedBy")) {
            var error = $root.pruntime_rpc.Certificate.verify(message.signedBy);
            if (error)
              return "signedBy." + error;
          }
          if (message.signatureType != null && message.hasOwnProperty("signatureType"))
            switch (message.signatureType) {
              default:
                return "signatureType: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.signature != null && message.hasOwnProperty("signature")) {
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
              return "signature: buffer expected";
          }
          return null;
        };
        Signature.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.Signature)
            return object;
          var message = new $root.pruntime_rpc.Signature();
          if (object.signedBy != null) {
            if (typeof object.signedBy !== "object")
              throw TypeError(".pruntime_rpc.Signature.signedBy: object expected");
            message.signedBy = $root.pruntime_rpc.Certificate.fromObject(object.signedBy);
          }
          switch (object.signatureType) {
            default:
              if (typeof object.signatureType === "number") {
                message.signatureType = object.signatureType;
                break;
              }
              break;
            case "Ed25519":
            case 0:
              message.signatureType = 0;
              break;
            case "Sr25519":
            case 1:
              message.signatureType = 1;
              break;
            case "Ecdsa":
            case 2:
              message.signatureType = 2;
              break;
            case "Ed25519WrapBytes":
            case 3:
              message.signatureType = 3;
              break;
            case "Sr25519WrapBytes":
            case 4:
              message.signatureType = 4;
              break;
            case "EcdsaWrapBytes":
            case 5:
              message.signatureType = 5;
              break;
            case "Eip712":
            case 6:
              message.signatureType = 6;
              break;
          }
          if (object.signature != null) {
            if (typeof object.signature === "string")
              $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length >= 0)
              message.signature = object.signature;
          }
          return message;
        };
        Signature.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.signedBy = null;
            object.signatureType = options2.enums === String ? "Ed25519" : 0;
            if (options2.bytes === String)
              object.signature = "";
            else {
              object.signature = [];
              if (options2.bytes !== Array)
                object.signature = $util.newBuffer(object.signature);
            }
          }
          if (message.signedBy != null && message.hasOwnProperty("signedBy"))
            object.signedBy = $root.pruntime_rpc.Certificate.toObject(message.signedBy, options2);
          if (message.signatureType != null && message.hasOwnProperty("signatureType"))
            object.signatureType = options2.enums === String ? $root.pruntime_rpc.SignatureType[message.signatureType] === void 0 ? message.signatureType : $root.pruntime_rpc.SignatureType[message.signatureType] : message.signatureType;
          if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = options2.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options2.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
          return object;
        };
        Signature.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        Signature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.Signature";
        };
        return Signature;
      }();
      pruntime_rpc2.Certificate = function() {
        function Certificate(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Certificate.prototype.encodedBody = $util.newBuffer([]);
        Certificate.prototype.signature = null;
        Certificate.create = function create(properties) {
          return new Certificate(properties);
        };
        Certificate.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.encodedBody != null && Object.hasOwnProperty.call(message, "encodedBody"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.encodedBody);
          if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            $root.pruntime_rpc.Signature.encode(message.signature, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          return writer;
        };
        Certificate.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Certificate.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.Certificate();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.encodedBody = reader.bytes();
                break;
              }
              case 2: {
                message.signature = $root.pruntime_rpc.Signature.decode(reader, reader.uint32());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Certificate.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Certificate.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.encodedBody != null && message.hasOwnProperty("encodedBody")) {
            if (!(message.encodedBody && typeof message.encodedBody.length === "number" || $util.isString(message.encodedBody)))
              return "encodedBody: buffer expected";
          }
          if (message.signature != null && message.hasOwnProperty("signature")) {
            var error = $root.pruntime_rpc.Signature.verify(message.signature);
            if (error)
              return "signature." + error;
          }
          return null;
        };
        Certificate.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.Certificate)
            return object;
          var message = new $root.pruntime_rpc.Certificate();
          if (object.encodedBody != null) {
            if (typeof object.encodedBody === "string")
              $util.base64.decode(object.encodedBody, message.encodedBody = $util.newBuffer($util.base64.length(object.encodedBody)), 0);
            else if (object.encodedBody.length >= 0)
              message.encodedBody = object.encodedBody;
          }
          if (object.signature != null) {
            if (typeof object.signature !== "object")
              throw TypeError(".pruntime_rpc.Certificate.signature: object expected");
            message.signature = $root.pruntime_rpc.Signature.fromObject(object.signature);
          }
          return message;
        };
        Certificate.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            if (options2.bytes === String)
              object.encodedBody = "";
            else {
              object.encodedBody = [];
              if (options2.bytes !== Array)
                object.encodedBody = $util.newBuffer(object.encodedBody);
            }
            object.signature = null;
          }
          if (message.encodedBody != null && message.hasOwnProperty("encodedBody"))
            object.encodedBody = options2.bytes === String ? $util.base64.encode(message.encodedBody, 0, message.encodedBody.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedBody) : message.encodedBody;
          if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = $root.pruntime_rpc.Signature.toObject(message.signature, options2);
          return object;
        };
        Certificate.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        Certificate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.Certificate";
        };
        return Certificate;
      }();
      pruntime_rpc2.SignatureType = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Ed25519"] = 0;
        values[valuesById[1] = "Sr25519"] = 1;
        values[valuesById[2] = "Ecdsa"] = 2;
        values[valuesById[3] = "Ed25519WrapBytes"] = 3;
        values[valuesById[4] = "Sr25519WrapBytes"] = 4;
        values[valuesById[5] = "EcdsaWrapBytes"] = 5;
        values[valuesById[6] = "Eip712"] = 6;
        return values;
      }();
      pruntime_rpc2.ContractQueryResponse = function() {
        function ContractQueryResponse(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ContractQueryResponse.prototype.encodedEncryptedData = $util.newBuffer([]);
        ContractQueryResponse.create = function create(properties) {
          return new ContractQueryResponse(properties);
        };
        ContractQueryResponse.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.encodedEncryptedData != null && Object.hasOwnProperty.call(message, "encodedEncryptedData"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.encodedEncryptedData);
          return writer;
        };
        ContractQueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ContractQueryResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.ContractQueryResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.encodedEncryptedData = reader.bytes();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ContractQueryResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ContractQueryResponse.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.encodedEncryptedData != null && message.hasOwnProperty("encodedEncryptedData")) {
            if (!(message.encodedEncryptedData && typeof message.encodedEncryptedData.length === "number" || $util.isString(message.encodedEncryptedData)))
              return "encodedEncryptedData: buffer expected";
          }
          return null;
        };
        ContractQueryResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.ContractQueryResponse)
            return object;
          var message = new $root.pruntime_rpc.ContractQueryResponse();
          if (object.encodedEncryptedData != null) {
            if (typeof object.encodedEncryptedData === "string")
              $util.base64.decode(object.encodedEncryptedData, message.encodedEncryptedData = $util.newBuffer($util.base64.length(object.encodedEncryptedData)), 0);
            else if (object.encodedEncryptedData.length >= 0)
              message.encodedEncryptedData = object.encodedEncryptedData;
          }
          return message;
        };
        ContractQueryResponse.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults)
            if (options2.bytes === String)
              object.encodedEncryptedData = "";
            else {
              object.encodedEncryptedData = [];
              if (options2.bytes !== Array)
                object.encodedEncryptedData = $util.newBuffer(object.encodedEncryptedData);
            }
          if (message.encodedEncryptedData != null && message.hasOwnProperty("encodedEncryptedData"))
            object.encodedEncryptedData = options2.bytes === String ? $util.base64.encode(message.encodedEncryptedData, 0, message.encodedEncryptedData.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedEncryptedData) : message.encodedEncryptedData;
          return object;
        };
        ContractQueryResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ContractQueryResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.ContractQueryResponse";
        };
        return ContractQueryResponse;
      }();
      pruntime_rpc2.AddEndpointRequest = function() {
        function AddEndpointRequest(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        AddEndpointRequest.prototype.encodedEndpointType = $util.newBuffer([]);
        AddEndpointRequest.prototype.endpoint = "";
        AddEndpointRequest.create = function create(properties) {
          return new AddEndpointRequest(properties);
        };
        AddEndpointRequest.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.encodedEndpointType != null && Object.hasOwnProperty.call(message, "encodedEndpointType"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.encodedEndpointType);
          if (message.endpoint != null && Object.hasOwnProperty.call(message, "endpoint"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.endpoint);
          return writer;
        };
        AddEndpointRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        AddEndpointRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.AddEndpointRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.encodedEndpointType = reader.bytes();
                break;
              }
              case 2: {
                message.endpoint = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        AddEndpointRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        AddEndpointRequest.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.encodedEndpointType != null && message.hasOwnProperty("encodedEndpointType")) {
            if (!(message.encodedEndpointType && typeof message.encodedEndpointType.length === "number" || $util.isString(message.encodedEndpointType)))
              return "encodedEndpointType: buffer expected";
          }
          if (message.endpoint != null && message.hasOwnProperty("endpoint")) {
            if (!$util.isString(message.endpoint))
              return "endpoint: string expected";
          }
          return null;
        };
        AddEndpointRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.AddEndpointRequest)
            return object;
          var message = new $root.pruntime_rpc.AddEndpointRequest();
          if (object.encodedEndpointType != null) {
            if (typeof object.encodedEndpointType === "string")
              $util.base64.decode(object.encodedEndpointType, message.encodedEndpointType = $util.newBuffer($util.base64.length(object.encodedEndpointType)), 0);
            else if (object.encodedEndpointType.length >= 0)
              message.encodedEndpointType = object.encodedEndpointType;
          }
          if (object.endpoint != null)
            message.endpoint = String(object.endpoint);
          return message;
        };
        AddEndpointRequest.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            if (options2.bytes === String)
              object.encodedEndpointType = "";
            else {
              object.encodedEndpointType = [];
              if (options2.bytes !== Array)
                object.encodedEndpointType = $util.newBuffer(object.encodedEndpointType);
            }
            object.endpoint = "";
          }
          if (message.encodedEndpointType != null && message.hasOwnProperty("encodedEndpointType"))
            object.encodedEndpointType = options2.bytes === String ? $util.base64.encode(message.encodedEndpointType, 0, message.encodedEndpointType.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedEndpointType) : message.encodedEndpointType;
          if (message.endpoint != null && message.hasOwnProperty("endpoint"))
            object.endpoint = message.endpoint;
          return object;
        };
        AddEndpointRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        AddEndpointRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.AddEndpointRequest";
        };
        return AddEndpointRequest;
      }();
      pruntime_rpc2.GetEndpointResponse = function() {
        function GetEndpointResponse(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        GetEndpointResponse.prototype.encodedEndpointPayload = null;
        GetEndpointResponse.prototype.signature = null;
        var $oneOfFields;
        Object.defineProperty(GetEndpointResponse.prototype, "_encodedEndpointPayload", {
          get: $util.oneOfGetter($oneOfFields = ["encodedEndpointPayload"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        Object.defineProperty(GetEndpointResponse.prototype, "_signature", {
          get: $util.oneOfGetter($oneOfFields = ["signature"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        GetEndpointResponse.create = function create(properties) {
          return new GetEndpointResponse(properties);
        };
        GetEndpointResponse.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.encodedEndpointPayload != null && Object.hasOwnProperty.call(message, "encodedEndpointPayload"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.encodedEndpointPayload);
          if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.signature);
          return writer;
        };
        GetEndpointResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        GetEndpointResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.GetEndpointResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.encodedEndpointPayload = reader.bytes();
                break;
              }
              case 2: {
                message.signature = reader.bytes();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        GetEndpointResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        GetEndpointResponse.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.encodedEndpointPayload != null && message.hasOwnProperty("encodedEndpointPayload")) {
            properties._encodedEndpointPayload = 1;
            if (!(message.encodedEndpointPayload && typeof message.encodedEndpointPayload.length === "number" || $util.isString(message.encodedEndpointPayload)))
              return "encodedEndpointPayload: buffer expected";
          }
          if (message.signature != null && message.hasOwnProperty("signature")) {
            properties._signature = 1;
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
              return "signature: buffer expected";
          }
          return null;
        };
        GetEndpointResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.GetEndpointResponse)
            return object;
          var message = new $root.pruntime_rpc.GetEndpointResponse();
          if (object.encodedEndpointPayload != null) {
            if (typeof object.encodedEndpointPayload === "string")
              $util.base64.decode(object.encodedEndpointPayload, message.encodedEndpointPayload = $util.newBuffer($util.base64.length(object.encodedEndpointPayload)), 0);
            else if (object.encodedEndpointPayload.length >= 0)
              message.encodedEndpointPayload = object.encodedEndpointPayload;
          }
          if (object.signature != null) {
            if (typeof object.signature === "string")
              $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length >= 0)
              message.signature = object.signature;
          }
          return message;
        };
        GetEndpointResponse.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (message.encodedEndpointPayload != null && message.hasOwnProperty("encodedEndpointPayload")) {
            object.encodedEndpointPayload = options2.bytes === String ? $util.base64.encode(message.encodedEndpointPayload, 0, message.encodedEndpointPayload.length) : options2.bytes === Array ? Array.prototype.slice.call(message.encodedEndpointPayload) : message.encodedEndpointPayload;
            if (options2.oneofs)
              object._encodedEndpointPayload = "encodedEndpointPayload";
          }
          if (message.signature != null && message.hasOwnProperty("signature")) {
            object.signature = options2.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options2.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            if (options2.oneofs)
              object._signature = "signature";
          }
          return object;
        };
        GetEndpointResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        GetEndpointResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.GetEndpointResponse";
        };
        return GetEndpointResponse;
      }();
      pruntime_rpc2.GetContractInfoRequest = function() {
        function GetContractInfoRequest(properties) {
          this.contracts = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        GetContractInfoRequest.prototype.contracts = $util.emptyArray;
        GetContractInfoRequest.create = function create(properties) {
          return new GetContractInfoRequest(properties);
        };
        GetContractInfoRequest.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.contracts != null && message.contracts.length)
            for (var i = 0; i < message.contracts.length; ++i)
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.contracts[i]);
          return writer;
        };
        GetContractInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        GetContractInfoRequest.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.GetContractInfoRequest();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (!(message.contracts && message.contracts.length))
                  message.contracts = [];
                message.contracts.push(reader.string());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        GetContractInfoRequest.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        GetContractInfoRequest.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.contracts != null && message.hasOwnProperty("contracts")) {
            if (!Array.isArray(message.contracts))
              return "contracts: array expected";
            for (var i = 0; i < message.contracts.length; ++i)
              if (!$util.isString(message.contracts[i]))
                return "contracts: string[] expected";
          }
          return null;
        };
        GetContractInfoRequest.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.GetContractInfoRequest)
            return object;
          var message = new $root.pruntime_rpc.GetContractInfoRequest();
          if (object.contracts) {
            if (!Array.isArray(object.contracts))
              throw TypeError(".pruntime_rpc.GetContractInfoRequest.contracts: array expected");
            message.contracts = [];
            for (var i = 0; i < object.contracts.length; ++i)
              message.contracts[i] = String(object.contracts[i]);
          }
          return message;
        };
        GetContractInfoRequest.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.arrays || options2.defaults)
            object.contracts = [];
          if (message.contracts && message.contracts.length) {
            object.contracts = [];
            for (var j = 0; j < message.contracts.length; ++j)
              object.contracts[j] = message.contracts[j];
          }
          return object;
        };
        GetContractInfoRequest.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        GetContractInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.GetContractInfoRequest";
        };
        return GetContractInfoRequest;
      }();
      pruntime_rpc2.GetContractInfoResponse = function() {
        function GetContractInfoResponse(properties) {
          this.contracts = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        GetContractInfoResponse.prototype.contracts = $util.emptyArray;
        GetContractInfoResponse.create = function create(properties) {
          return new GetContractInfoResponse(properties);
        };
        GetContractInfoResponse.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.contracts != null && message.contracts.length)
            for (var i = 0; i < message.contracts.length; ++i)
              $root.pruntime_rpc.ContractInfo.encode(message.contracts[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
          return writer;
        };
        GetContractInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        GetContractInfoResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.GetContractInfoResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (!(message.contracts && message.contracts.length))
                  message.contracts = [];
                message.contracts.push($root.pruntime_rpc.ContractInfo.decode(reader, reader.uint32()));
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        GetContractInfoResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        GetContractInfoResponse.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.contracts != null && message.hasOwnProperty("contracts")) {
            if (!Array.isArray(message.contracts))
              return "contracts: array expected";
            for (var i = 0; i < message.contracts.length; ++i) {
              var error = $root.pruntime_rpc.ContractInfo.verify(message.contracts[i]);
              if (error)
                return "contracts." + error;
            }
          }
          return null;
        };
        GetContractInfoResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.GetContractInfoResponse)
            return object;
          var message = new $root.pruntime_rpc.GetContractInfoResponse();
          if (object.contracts) {
            if (!Array.isArray(object.contracts))
              throw TypeError(".pruntime_rpc.GetContractInfoResponse.contracts: array expected");
            message.contracts = [];
            for (var i = 0; i < object.contracts.length; ++i) {
              if (typeof object.contracts[i] !== "object")
                throw TypeError(".pruntime_rpc.GetContractInfoResponse.contracts: object expected");
              message.contracts[i] = $root.pruntime_rpc.ContractInfo.fromObject(object.contracts[i]);
            }
          }
          return message;
        };
        GetContractInfoResponse.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.arrays || options2.defaults)
            object.contracts = [];
          if (message.contracts && message.contracts.length) {
            object.contracts = [];
            for (var j = 0; j < message.contracts.length; ++j)
              object.contracts[j] = $root.pruntime_rpc.ContractInfo.toObject(message.contracts[j], options2);
          }
          return object;
        };
        GetContractInfoResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        GetContractInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.GetContractInfoResponse";
        };
        return GetContractInfoResponse;
      }();
      pruntime_rpc2.ContractInfo = function() {
        function ContractInfo(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ContractInfo.prototype.id = "";
        ContractInfo.prototype.codeHash = "";
        ContractInfo.prototype.weight = 0;
        ContractInfo.prototype.sidevm = null;
        ContractInfo.create = function create(properties) {
          return new ContractInfo(properties);
        };
        ContractInfo.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.id);
          if (message.codeHash != null && Object.hasOwnProperty.call(message, "codeHash"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.codeHash);
          if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint32(message.weight);
          if (message.sidevm != null && Object.hasOwnProperty.call(message, "sidevm"))
            $root.pruntime_rpc.SidevmInfo.encode(message.sidevm, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          return writer;
        };
        ContractInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ContractInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.ContractInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.id = reader.string();
                break;
              }
              case 2: {
                message.codeHash = reader.string();
                break;
              }
              case 3: {
                message.weight = reader.uint32();
                break;
              }
              case 4: {
                message.sidevm = $root.pruntime_rpc.SidevmInfo.decode(reader, reader.uint32());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ContractInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ContractInfo.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.id != null && message.hasOwnProperty("id")) {
            if (!$util.isString(message.id))
              return "id: string expected";
          }
          if (message.codeHash != null && message.hasOwnProperty("codeHash")) {
            if (!$util.isString(message.codeHash))
              return "codeHash: string expected";
          }
          if (message.weight != null && message.hasOwnProperty("weight")) {
            if (!$util.isInteger(message.weight))
              return "weight: integer expected";
          }
          if (message.sidevm != null && message.hasOwnProperty("sidevm")) {
            var error = $root.pruntime_rpc.SidevmInfo.verify(message.sidevm);
            if (error)
              return "sidevm." + error;
          }
          return null;
        };
        ContractInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.ContractInfo)
            return object;
          var message = new $root.pruntime_rpc.ContractInfo();
          if (object.id != null)
            message.id = String(object.id);
          if (object.codeHash != null)
            message.codeHash = String(object.codeHash);
          if (object.weight != null)
            message.weight = object.weight >>> 0;
          if (object.sidevm != null) {
            if (typeof object.sidevm !== "object")
              throw TypeError(".pruntime_rpc.ContractInfo.sidevm: object expected");
            message.sidevm = $root.pruntime_rpc.SidevmInfo.fromObject(object.sidevm);
          }
          return message;
        };
        ContractInfo.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.id = "";
            object.codeHash = "";
            object.weight = 0;
            object.sidevm = null;
          }
          if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
          if (message.codeHash != null && message.hasOwnProperty("codeHash"))
            object.codeHash = message.codeHash;
          if (message.weight != null && message.hasOwnProperty("weight"))
            object.weight = message.weight;
          if (message.sidevm != null && message.hasOwnProperty("sidevm"))
            object.sidevm = $root.pruntime_rpc.SidevmInfo.toObject(message.sidevm, options2);
          return object;
        };
        ContractInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ContractInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.ContractInfo";
        };
        return ContractInfo;
      }();
      pruntime_rpc2.SidevmInfo = function() {
        function SidevmInfo(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        SidevmInfo.prototype.state = "";
        SidevmInfo.prototype.codeHash = "";
        SidevmInfo.prototype.startTime = "";
        SidevmInfo.prototype.stopReason = "";
        SidevmInfo.create = function create(properties) {
          return new SidevmInfo(properties);
        };
        SidevmInfo.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.state != null && Object.hasOwnProperty.call(message, "state"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.state);
          if (message.codeHash != null && Object.hasOwnProperty.call(message, "codeHash"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.codeHash);
          if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.startTime);
          if (message.stopReason != null && Object.hasOwnProperty.call(message, "stopReason"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.stopReason);
          return writer;
        };
        SidevmInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        SidevmInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.SidevmInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.state = reader.string();
                break;
              }
              case 2: {
                message.codeHash = reader.string();
                break;
              }
              case 3: {
                message.startTime = reader.string();
                break;
              }
              case 4: {
                message.stopReason = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        SidevmInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        SidevmInfo.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.state != null && message.hasOwnProperty("state")) {
            if (!$util.isString(message.state))
              return "state: string expected";
          }
          if (message.codeHash != null && message.hasOwnProperty("codeHash")) {
            if (!$util.isString(message.codeHash))
              return "codeHash: string expected";
          }
          if (message.startTime != null && message.hasOwnProperty("startTime")) {
            if (!$util.isString(message.startTime))
              return "startTime: string expected";
          }
          if (message.stopReason != null && message.hasOwnProperty("stopReason")) {
            if (!$util.isString(message.stopReason))
              return "stopReason: string expected";
          }
          return null;
        };
        SidevmInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.SidevmInfo)
            return object;
          var message = new $root.pruntime_rpc.SidevmInfo();
          if (object.state != null)
            message.state = String(object.state);
          if (object.codeHash != null)
            message.codeHash = String(object.codeHash);
          if (object.startTime != null)
            message.startTime = String(object.startTime);
          if (object.stopReason != null)
            message.stopReason = String(object.stopReason);
          return message;
        };
        SidevmInfo.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.state = "";
            object.codeHash = "";
            object.startTime = "";
            object.stopReason = "";
          }
          if (message.state != null && message.hasOwnProperty("state"))
            object.state = message.state;
          if (message.codeHash != null && message.hasOwnProperty("codeHash"))
            object.codeHash = message.codeHash;
          if (message.startTime != null && message.hasOwnProperty("startTime"))
            object.startTime = message.startTime;
          if (message.stopReason != null && message.hasOwnProperty("stopReason"))
            object.stopReason = message.stopReason;
          return object;
        };
        SidevmInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        SidevmInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.SidevmInfo";
        };
        return SidevmInfo;
      }();
      pruntime_rpc2.GetClusterInfoResponse = function() {
        function GetClusterInfoResponse(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        GetClusterInfoResponse.prototype.info = null;
        GetClusterInfoResponse.create = function create(properties) {
          return new GetClusterInfoResponse(properties);
        };
        GetClusterInfoResponse.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.info != null && Object.hasOwnProperty.call(message, "info"))
            $root.pruntime_rpc.ClusterInfo.encode(message.info, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          return writer;
        };
        GetClusterInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        GetClusterInfoResponse.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.GetClusterInfoResponse();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.info = $root.pruntime_rpc.ClusterInfo.decode(reader, reader.uint32());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        GetClusterInfoResponse.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        GetClusterInfoResponse.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.info != null && message.hasOwnProperty("info")) {
            var error = $root.pruntime_rpc.ClusterInfo.verify(message.info);
            if (error)
              return "info." + error;
          }
          return null;
        };
        GetClusterInfoResponse.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.GetClusterInfoResponse)
            return object;
          var message = new $root.pruntime_rpc.GetClusterInfoResponse();
          if (object.info != null) {
            if (typeof object.info !== "object")
              throw TypeError(".pruntime_rpc.GetClusterInfoResponse.info: object expected");
            message.info = $root.pruntime_rpc.ClusterInfo.fromObject(object.info);
          }
          return message;
        };
        GetClusterInfoResponse.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults)
            object.info = null;
          if (message.info != null && message.hasOwnProperty("info"))
            object.info = $root.pruntime_rpc.ClusterInfo.toObject(message.info, options2);
          return object;
        };
        GetClusterInfoResponse.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        GetClusterInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.GetClusterInfoResponse";
        };
        return GetClusterInfoResponse;
      }();
      pruntime_rpc2.ClusterInfo = function() {
        function ClusterInfo(properties) {
          this.contracts = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ClusterInfo.prototype.id = "";
        ClusterInfo.prototype.runtimeVersion = "";
        ClusterInfo.prototype.stateRoot = "";
        ClusterInfo.prototype.contracts = $util.emptyArray;
        ClusterInfo.create = function create(properties) {
          return new ClusterInfo(properties);
        };
        ClusterInfo.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.id);
          if (message.runtimeVersion != null && Object.hasOwnProperty.call(message, "runtimeVersion"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.runtimeVersion);
          if (message.stateRoot != null && Object.hasOwnProperty.call(message, "stateRoot"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.stateRoot);
          if (message.contracts != null && message.contracts.length)
            for (var i = 0; i < message.contracts.length; ++i)
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).string(message.contracts[i]);
          return writer;
        };
        ClusterInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ClusterInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.ClusterInfo();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.id = reader.string();
                break;
              }
              case 2: {
                message.runtimeVersion = reader.string();
                break;
              }
              case 3: {
                message.stateRoot = reader.string();
                break;
              }
              case 4: {
                if (!(message.contracts && message.contracts.length))
                  message.contracts = [];
                message.contracts.push(reader.string());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ClusterInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ClusterInfo.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.id != null && message.hasOwnProperty("id")) {
            if (!$util.isString(message.id))
              return "id: string expected";
          }
          if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion")) {
            if (!$util.isString(message.runtimeVersion))
              return "runtimeVersion: string expected";
          }
          if (message.stateRoot != null && message.hasOwnProperty("stateRoot")) {
            if (!$util.isString(message.stateRoot))
              return "stateRoot: string expected";
          }
          if (message.contracts != null && message.hasOwnProperty("contracts")) {
            if (!Array.isArray(message.contracts))
              return "contracts: array expected";
            for (var i = 0; i < message.contracts.length; ++i)
              if (!$util.isString(message.contracts[i]))
                return "contracts: string[] expected";
          }
          return null;
        };
        ClusterInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.ClusterInfo)
            return object;
          var message = new $root.pruntime_rpc.ClusterInfo();
          if (object.id != null)
            message.id = String(object.id);
          if (object.runtimeVersion != null)
            message.runtimeVersion = String(object.runtimeVersion);
          if (object.stateRoot != null)
            message.stateRoot = String(object.stateRoot);
          if (object.contracts) {
            if (!Array.isArray(object.contracts))
              throw TypeError(".pruntime_rpc.ClusterInfo.contracts: array expected");
            message.contracts = [];
            for (var i = 0; i < object.contracts.length; ++i)
              message.contracts[i] = String(object.contracts[i]);
          }
          return message;
        };
        ClusterInfo.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.arrays || options2.defaults)
            object.contracts = [];
          if (options2.defaults) {
            object.id = "";
            object.runtimeVersion = "";
            object.stateRoot = "";
          }
          if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
          if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion"))
            object.runtimeVersion = message.runtimeVersion;
          if (message.stateRoot != null && message.hasOwnProperty("stateRoot"))
            object.stateRoot = message.stateRoot;
          if (message.contracts && message.contracts.length) {
            object.contracts = [];
            for (var j = 0; j < message.contracts.length; ++j)
              object.contracts[j] = message.contracts[j];
          }
          return object;
        };
        ClusterInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ClusterInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.ClusterInfo";
        };
        return ClusterInfo;
      }();
      pruntime_rpc2.SidevmCode = function() {
        function SidevmCode(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        SidevmCode.prototype.contract = $util.newBuffer([]);
        SidevmCode.prototype.code = $util.newBuffer([]);
        SidevmCode.create = function create(properties) {
          return new SidevmCode(properties);
        };
        SidevmCode.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.contract != null && Object.hasOwnProperty.call(message, "contract"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.contract);
          if (message.code != null && Object.hasOwnProperty.call(message, "code"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.code);
          return writer;
        };
        SidevmCode.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        SidevmCode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.SidevmCode();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.contract = reader.bytes();
                break;
              }
              case 2: {
                message.code = reader.bytes();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        SidevmCode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        SidevmCode.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.contract != null && message.hasOwnProperty("contract")) {
            if (!(message.contract && typeof message.contract.length === "number" || $util.isString(message.contract)))
              return "contract: buffer expected";
          }
          if (message.code != null && message.hasOwnProperty("code")) {
            if (!(message.code && typeof message.code.length === "number" || $util.isString(message.code)))
              return "code: buffer expected";
          }
          return null;
        };
        SidevmCode.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.SidevmCode)
            return object;
          var message = new $root.pruntime_rpc.SidevmCode();
          if (object.contract != null) {
            if (typeof object.contract === "string")
              $util.base64.decode(object.contract, message.contract = $util.newBuffer($util.base64.length(object.contract)), 0);
            else if (object.contract.length >= 0)
              message.contract = object.contract;
          }
          if (object.code != null) {
            if (typeof object.code === "string")
              $util.base64.decode(object.code, message.code = $util.newBuffer($util.base64.length(object.code)), 0);
            else if (object.code.length >= 0)
              message.code = object.code;
          }
          return message;
        };
        SidevmCode.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            if (options2.bytes === String)
              object.contract = "";
            else {
              object.contract = [];
              if (options2.bytes !== Array)
                object.contract = $util.newBuffer(object.contract);
            }
            if (options2.bytes === String)
              object.code = "";
            else {
              object.code = [];
              if (options2.bytes !== Array)
                object.code = $util.newBuffer(object.code);
            }
          }
          if (message.contract != null && message.hasOwnProperty("contract"))
            object.contract = options2.bytes === String ? $util.base64.encode(message.contract, 0, message.contract.length) : options2.bytes === Array ? Array.prototype.slice.call(message.contract) : message.contract;
          if (message.code != null && message.hasOwnProperty("code"))
            object.code = options2.bytes === String ? $util.base64.encode(message.code, 0, message.code.length) : options2.bytes === Array ? Array.prototype.slice.call(message.code) : message.code;
          return object;
        };
        SidevmCode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        SidevmCode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.SidevmCode";
        };
        return SidevmCode;
      }();
      pruntime_rpc2.ContractParameters = function() {
        function ContractParameters(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ContractParameters.prototype.deployer = "";
        ContractParameters.prototype.clusterId = "";
        ContractParameters.prototype.codeHash = "";
        ContractParameters.prototype.salt = "";
        ContractParameters.create = function create(properties) {
          return new ContractParameters(properties);
        };
        ContractParameters.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.deployer != null && Object.hasOwnProperty.call(message, "deployer"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.deployer);
          if (message.clusterId != null && Object.hasOwnProperty.call(message, "clusterId"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.clusterId);
          if (message.codeHash != null && Object.hasOwnProperty.call(message, "codeHash"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.codeHash);
          if (message.salt != null && Object.hasOwnProperty.call(message, "salt"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.salt);
          return writer;
        };
        ContractParameters.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ContractParameters.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.ContractParameters();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.deployer = reader.string();
                break;
              }
              case 2: {
                message.clusterId = reader.string();
                break;
              }
              case 3: {
                message.codeHash = reader.string();
                break;
              }
              case 4: {
                message.salt = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ContractParameters.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ContractParameters.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.deployer != null && message.hasOwnProperty("deployer")) {
            if (!$util.isString(message.deployer))
              return "deployer: string expected";
          }
          if (message.clusterId != null && message.hasOwnProperty("clusterId")) {
            if (!$util.isString(message.clusterId))
              return "clusterId: string expected";
          }
          if (message.codeHash != null && message.hasOwnProperty("codeHash")) {
            if (!$util.isString(message.codeHash))
              return "codeHash: string expected";
          }
          if (message.salt != null && message.hasOwnProperty("salt")) {
            if (!$util.isString(message.salt))
              return "salt: string expected";
          }
          return null;
        };
        ContractParameters.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.ContractParameters)
            return object;
          var message = new $root.pruntime_rpc.ContractParameters();
          if (object.deployer != null)
            message.deployer = String(object.deployer);
          if (object.clusterId != null)
            message.clusterId = String(object.clusterId);
          if (object.codeHash != null)
            message.codeHash = String(object.codeHash);
          if (object.salt != null)
            message.salt = String(object.salt);
          return message;
        };
        ContractParameters.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults) {
            object.deployer = "";
            object.clusterId = "";
            object.codeHash = "";
            object.salt = "";
          }
          if (message.deployer != null && message.hasOwnProperty("deployer"))
            object.deployer = message.deployer;
          if (message.clusterId != null && message.hasOwnProperty("clusterId"))
            object.clusterId = message.clusterId;
          if (message.codeHash != null && message.hasOwnProperty("codeHash"))
            object.codeHash = message.codeHash;
          if (message.salt != null && message.hasOwnProperty("salt"))
            object.salt = message.salt;
          return object;
        };
        ContractParameters.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ContractParameters.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.ContractParameters";
        };
        return ContractParameters;
      }();
      pruntime_rpc2.ContractId = function() {
        function ContractId(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ContractId.prototype.id = "";
        ContractId.create = function create(properties) {
          return new ContractId(properties);
        };
        ContractId.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.id);
          return writer;
        };
        ContractId.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ContractId.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.pruntime_rpc.ContractId();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.id = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ContractId.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ContractId.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.id != null && message.hasOwnProperty("id")) {
            if (!$util.isString(message.id))
              return "id: string expected";
          }
          return null;
        };
        ContractId.fromObject = function fromObject(object) {
          if (object instanceof $root.pruntime_rpc.ContractId)
            return object;
          var message = new $root.pruntime_rpc.ContractId();
          if (object.id != null)
            message.id = String(object.id);
          return message;
        };
        ContractId.toObject = function toObject(message, options2) {
          if (!options2)
            options2 = {};
          var object = {};
          if (options2.defaults)
            object.id = "";
          if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
          return object;
        };
        ContractId.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ContractId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/pruntime_rpc.ContractId";
        };
        return ContractId;
      }();
      return pruntime_rpc2;
    }();
    $root.google = function() {
      var google = {};
      google.protobuf = function() {
        var protobuf = {};
        protobuf.Empty = function() {
          function Empty(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Empty.create = function create(properties) {
            return new Empty(properties);
          };
          Empty.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            return writer;
          };
          Empty.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Empty.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Empty.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Empty.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            return null;
          };
          Empty.fromObject = function fromObject(object) {
            if (object instanceof $root.google.protobuf.Empty)
              return object;
            return new $root.google.protobuf.Empty();
          };
          Empty.toObject = function toObject() {
            return {};
          };
          Empty.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          Empty.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/google.protobuf.Empty";
          };
          return Empty;
        }();
        return protobuf;
      }();
      return google;
    }();
    module2.exports = $root;
  }
});

// src/abis/system.json
var system_default = {
  source: {
    hash: "0x4704b2819307adbe67d6b5116174cf6543a959ad8654b34d609b31abd67ac59e",
    language: "ink! 4.2.0",
    compiler: "rustc 1.69.0",
    build_info: {
      build_mode: "Debug",
      cargo_contract_version: "2.2.0",
      rust_toolchain: "stable-x86_64-unknown-linux-gnu",
      wasm_opt_settings: {
        keep_debug_symbols: false,
        optimization_passes: "Z"
      }
    }
  },
  contract: {
    name: "system",
    version: "1.0.0",
    authors: [
      "[your_name] <[your_email]>"
    ]
  },
  spec: {
    constructors: [
      {
        args: [],
        default: false,
        docs: [],
        label: "default",
        payable: false,
        returnType: {
          displayName: [
            "ink_primitives",
            "ConstructorResult"
          ],
          type: 7
        },
        selector: "0xed4b9d1b"
      }
    ],
    docs: [],
    environment: {
      accountId: {
        displayName: [
          "AccountId"
        ],
        type: 0
      },
      balance: {
        displayName: [
          "Balance"
        ],
        type: 24
      },
      blockNumber: {
        displayName: [
          "BlockNumber"
        ],
        type: 4
      },
      chainExtension: {
        displayName: [
          "ChainExtension"
        ],
        type: 39
      },
      hash: {
        displayName: [
          "Hash"
        ],
        type: 31
      },
      maxEventTopics: 4,
      timestamp: {
        displayName: [
          "Timestamp"
        ],
        type: 22
      }
    },
    events: [
      {
        args: [
          {
            docs: [],
            indexed: true,
            label: "name",
            type: {
              displayName: [
                "String"
              ],
              type: 16
            }
          },
          {
            docs: [],
            indexed: false,
            label: "previous",
            type: {
              displayName: [
                "Option"
              ],
              type: 18
            }
          },
          {
            docs: [],
            indexed: false,
            label: "current",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        docs: [
          "A new driver is set."
        ],
        label: "DriverChanged"
      },
      {
        args: [
          {
            docs: [],
            indexed: false,
            label: "user",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        docs: [
          "A new administrator is added."
        ],
        label: "AdministratorAdded"
      }
    ],
    lang_error: {
      displayName: [
        "ink",
        "LangError"
      ],
      type: 8
    },
    messages: [
      {
        args: [],
        default: false,
        docs: [],
        label: "owner",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 9
        },
        selector: "0xfeaea4fa"
      },
      {
        args: [],
        default: false,
        docs: [],
        label: "System::version",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 10
        },
        selector: "0x87c98a8d"
      },
      {
        args: [
          {
            label: "contract_id",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::grant_admin",
        mutates: true,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0x67612061"
      },
      {
        args: [
          {
            label: "name",
            type: {
              displayName: [
                "String"
              ],
              type: 16
            }
          },
          {
            label: "contract_id",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::set_driver",
        mutates: true,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0xaa1e2030"
      },
      {
        args: [
          {
            label: "name",
            type: {
              displayName: [
                "String"
              ],
              type: 16
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::get_driver",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 17
        },
        selector: "0x2740cf0a"
      },
      {
        args: [
          {
            label: "name",
            type: {
              displayName: [
                "String"
              ],
              type: 16
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::get_driver2",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 19
        },
        selector: "0xc0f28223"
      },
      {
        args: [
          {
            label: "contract_id",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          },
          {
            label: "code_hash",
            type: {
              displayName: [
                "pink",
                "Hash"
              ],
              type: 1
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::deploy_sidevm_to",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0x662f4aa4"
      },
      {
        args: [
          {
            label: "contract_id",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::stop_sidevm_at",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0x52a0fd6a"
      },
      {
        args: [
          {
            label: "hook",
            type: {
              displayName: [
                "HookPoint"
              ],
              type: 21
            }
          },
          {
            label: "contract",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          },
          {
            label: "selector",
            type: {
              displayName: [
                "u32"
              ],
              type: 4
            }
          },
          {
            label: "gas_limit",
            type: {
              displayName: [
                "u64"
              ],
              type: 22
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::set_hook",
        mutates: true,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0x352c6b5c"
      },
      {
        args: [
          {
            label: "contract_id",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          },
          {
            label: "weight",
            type: {
              displayName: [
                "u32"
              ],
              type: 4
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::set_contract_weight",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0x45ec9b18"
      },
      {
        args: [
          {
            label: "account",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::total_balance_of",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 23
        },
        selector: "0x5a98f226"
      },
      {
        args: [
          {
            label: "account",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::free_balance_of",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 23
        },
        selector: "0x8a0d40d7"
      },
      {
        args: [
          {
            label: "contract_id",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::is_admin",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 25
        },
        selector: "0xf06f050a"
      },
      {
        args: [],
        default: false,
        docs: [],
        label: "System::upgrade_system_contract",
        mutates: true,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0xaf69ca03"
      },
      {
        args: [
          {
            label: "from_version",
            type: {
              displayName: [
                "VersionTuple"
              ],
              type: 11
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::do_upgrade",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0x667e0041"
      },
      {
        args: [
          {
            label: "version",
            type: {
              displayName: [],
              type: 27
            }
          }
        ],
        default: false,
        docs: [
          " Upgrade the contract runtime",
          "",
          " Be careful when using this function, it would panic the worker if the",
          " runtime version is not supported."
        ],
        label: "System::upgrade_runtime",
        mutates: true,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 13
        },
        selector: "0x317f6bf3"
      },
      {
        args: [
          {
            label: "code_hash",
            type: {
              displayName: [],
              type: 1
            }
          },
          {
            label: "code_type",
            type: {
              displayName: [
                "CodeType"
              ],
              type: 28
            }
          }
        ],
        default: false,
        docs: [
          " Check if the code is already uploaded to the cluster with given code hash."
        ],
        label: "System::code_exists",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 25
        },
        selector: "0x6fc58436"
      },
      {
        args: [
          {
            label: "account",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::code_hash",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 29
        },
        selector: "0x916fdb44"
      },
      {
        args: [
          {
            label: "name",
            type: {
              displayName: [
                "String"
              ],
              type: 16
            }
          }
        ],
        default: false,
        docs: [],
        label: "System::driver_history",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 32
        },
        selector: "0xd519dbec"
      },
      {
        args: [],
        default: false,
        docs: [],
        label: "System::current_event_chain_head",
        mutates: false,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 34
        },
        selector: "0xe14655d3"
      },
      {
        args: [
          {
            label: "contract_id",
            type: {
              displayName: [
                "AccountId"
              ],
              type: 0
            }
          },
          {
            label: "deposit",
            type: {
              displayName: [
                "Balance"
              ],
              type: 24
            }
          }
        ],
        default: false,
        docs: [],
        label: "ContractDeposit::change_deposit",
        mutates: true,
        payable: false,
        returnType: {
          displayName: [
            "ink",
            "MessageResult"
          ],
          type: 36
        },
        selector: "0xa24bcb44"
      }
    ]
  },
  storage: {
    root: {
      layout: {
        struct: {
          fields: [
            {
              layout: {
                leaf: {
                  key: "0x00000000",
                  ty: 0
                }
              },
              name: "owner"
            },
            {
              layout: {
                root: {
                  layout: {
                    leaf: {
                      key: "0x11ab091d",
                      ty: 3
                    }
                  },
                  root_key: "0x11ab091d"
                }
              },
              name: "administrators"
            },
            {
              layout: {
                root: {
                  layout: {
                    leaf: {
                      key: "0xe69daeed",
                      ty: 0
                    }
                  },
                  root_key: "0xe69daeed"
                }
              },
              name: "drivers"
            },
            {
              layout: {
                root: {
                  layout: {
                    struct: {
                      fields: [
                        {
                          layout: {
                            leaf: {
                              key: "0xae67f833",
                              ty: 4
                            }
                          },
                          name: "0"
                        },
                        {
                          layout: {
                            leaf: {
                              key: "0xae67f833",
                              ty: 0
                            }
                          },
                          name: "1"
                        }
                      ],
                      name: "(A, B)"
                    }
                  },
                  root_key: "0xae67f833"
                }
              },
              name: "drivers2"
            },
            {
              layout: {
                root: {
                  layout: {
                    leaf: {
                      key: "0xd2232fce",
                      ty: 5
                    }
                  },
                  root_key: "0xd2232fce"
                }
              },
              name: "drivers_history"
            }
          ],
          name: "System"
        }
      },
      root_key: "0x00000000"
    }
  },
  types: [
    {
      id: 0,
      type: {
        def: {
          composite: {
            fields: [
              {
                type: 1,
                typeName: "[u8; 32]"
              }
            ]
          }
        },
        path: [
          "ink_primitives",
          "types",
          "AccountId"
        ]
      }
    },
    {
      id: 1,
      type: {
        def: {
          array: {
            len: 32,
            type: 2
          }
        }
      }
    },
    {
      id: 2,
      type: {
        def: {
          primitive: "u8"
        }
      }
    },
    {
      id: 3,
      type: {
        def: {
          tuple: []
        }
      }
    },
    {
      id: 4,
      type: {
        def: {
          primitive: "u32"
        }
      }
    },
    {
      id: 5,
      type: {
        def: {
          sequence: {
            type: 6
          }
        }
      }
    },
    {
      id: 6,
      type: {
        def: {
          tuple: [
            4,
            0
          ]
        }
      }
    },
    {
      id: 7,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 3
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 3
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 8,
      type: {
        def: {
          variant: {
            variants: [
              {
                index: 1,
                name: "CouldNotReadInput"
              }
            ]
          }
        },
        path: [
          "ink_primitives",
          "LangError"
        ]
      }
    },
    {
      id: 9,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 0
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 0
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 10,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 11
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 11
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 11,
      type: {
        def: {
          tuple: [
            12,
            12,
            12
          ]
        }
      }
    },
    {
      id: 12,
      type: {
        def: {
          primitive: "u16"
        }
      }
    },
    {
      id: 13,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 14
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 14
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 14,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 3
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 15
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 3
          },
          {
            name: "E",
            type: 15
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 15,
      type: {
        def: {
          variant: {
            variants: [
              {
                index: 0,
                name: "PermisionDenied"
              },
              {
                index: 1,
                name: "DriverNotFound"
              },
              {
                index: 2,
                name: "CodeNotFound"
              },
              {
                index: 3,
                name: "ConditionNotMet"
              }
            ]
          }
        },
        path: [
          "pink_extension",
          "system",
          "Error"
        ]
      }
    },
    {
      id: 16,
      type: {
        def: {
          primitive: "str"
        }
      }
    },
    {
      id: 17,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 18
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 18
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 18,
      type: {
        def: {
          variant: {
            variants: [
              {
                index: 0,
                name: "None"
              },
              {
                fields: [
                  {
                    type: 0
                  }
                ],
                index: 1,
                name: "Some"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 0
          }
        ],
        path: [
          "Option"
        ]
      }
    },
    {
      id: 19,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 20
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 20
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 20,
      type: {
        def: {
          variant: {
            variants: [
              {
                index: 0,
                name: "None"
              },
              {
                fields: [
                  {
                    type: 6
                  }
                ],
                index: 1,
                name: "Some"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 6
          }
        ],
        path: [
          "Option"
        ]
      }
    },
    {
      id: 21,
      type: {
        def: {
          variant: {
            variants: [
              {
                index: 0,
                name: "OnBlockEnd"
              }
            ]
          }
        },
        path: [
          "pink_extension",
          "HookPoint"
        ]
      }
    },
    {
      id: 22,
      type: {
        def: {
          primitive: "u64"
        }
      }
    },
    {
      id: 23,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 24
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 24
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 24,
      type: {
        def: {
          primitive: "u128"
        }
      }
    },
    {
      id: 25,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 26
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 26
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 26,
      type: {
        def: {
          primitive: "bool"
        }
      }
    },
    {
      id: 27,
      type: {
        def: {
          tuple: [
            4,
            4
          ]
        }
      }
    },
    {
      id: 28,
      type: {
        def: {
          variant: {
            variants: [
              {
                index: 0,
                name: "Ink"
              },
              {
                index: 1,
                name: "Sidevm"
              }
            ]
          }
        },
        path: [
          "pink_extension",
          "system",
          "CodeType"
        ]
      }
    },
    {
      id: 29,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 30
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 30
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 30,
      type: {
        def: {
          variant: {
            variants: [
              {
                index: 0,
                name: "None"
              },
              {
                fields: [
                  {
                    type: 31
                  }
                ],
                index: 1,
                name: "Some"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 31
          }
        ],
        path: [
          "Option"
        ]
      }
    },
    {
      id: 31,
      type: {
        def: {
          composite: {
            fields: [
              {
                type: 1,
                typeName: "[u8; 32]"
              }
            ]
          }
        },
        path: [
          "ink_primitives",
          "types",
          "Hash"
        ]
      }
    },
    {
      id: 32,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 33
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 33
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 33,
      type: {
        def: {
          variant: {
            variants: [
              {
                index: 0,
                name: "None"
              },
              {
                fields: [
                  {
                    type: 5
                  }
                ],
                index: 1,
                name: "Some"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 5
          }
        ],
        path: [
          "Option"
        ]
      }
    },
    {
      id: 34,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 35
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 35
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 35,
      type: {
        def: {
          tuple: [
            22,
            1
          ]
        }
      }
    },
    {
      id: 36,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 37
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 8
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 37
          },
          {
            name: "E",
            type: 8
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 37,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 3
                  }
                ],
                index: 0,
                name: "Ok"
              },
              {
                fields: [
                  {
                    type: 38
                  }
                ],
                index: 1,
                name: "Err"
              }
            ]
          }
        },
        params: [
          {
            name: "T",
            type: 3
          },
          {
            name: "E",
            type: 38
          }
        ],
        path: [
          "Result"
        ]
      }
    },
    {
      id: 38,
      type: {
        def: {
          variant: {
            variants: [
              {
                fields: [
                  {
                    type: 16,
                    typeName: "String"
                  }
                ],
                index: 0,
                name: "Other"
              },
              {
                fields: [
                  {
                    type: 15,
                    typeName: "Error"
                  }
                ],
                index: 1,
                name: "SystemError"
              },
              {
                index: 2,
                name: "BadOrigin"
              }
            ]
          }
        },
        path: [
          "pink_extension",
          "system",
          "DriverError"
        ]
      }
    },
    {
      id: 39,
      type: {
        def: {
          variant: {}
        },
        path: [
          "pink_extension",
          "chain_extension",
          "PinkExt"
        ]
      }
    }
  ],
  version: "4"
};

// src/index.ts
var import_proto4 = __toESM(require_proto());

// src/utils/hex.ts
import randomBytes from "randombytes";
var randomHex = (size = 12) => randomBytes(size).toString("hex");

// src/pruntime/certificate.ts
import { hexAddPrefix, hexToU8a as hexToU8a2, u8aToHex as u8aToHex2 } from "@polkadot/util";
import { cryptoWaitReady, decodeAddress, sr25519PairFromSeed } from "@polkadot/util-crypto";
import { signTypedData } from "viem/wallet";

// src/options.ts
import { TypeRegistry, typeDefinitions } from "@polkadot/types";
import SubstrateLookupTypes from "@polkadot/types-augment/lookup/substrate";
var types = {
  ContractId: "H256",
  EcdhPublicKey: "SpCoreSr25519Public",
  ContractQueryHead: {
    id: "ContractId",
    nonce: "[u8; 32]"
  },
  CertificateBody: {
    pubkey: "Vec<u8>",
    ttl: "u32",
    config_bits: "u32"
  },
  EncryptedData: {
    iv: "[u8; 12]",
    pubkey: "EcdhPublicKey",
    data: "Vec<u8>"
  },
  CommandPayload: {
    _enum: {
      Plain: "InkCommand",
      Encrypted: "EncryptedData"
    }
  },
  InkQueryData: {
    _enum: {
      InkMessage: {
        payload: "Vec<u8>",
        deposit: "u128",
        transfer: "u128",
        estimating: "bool"
      },
      SidevmMessage: "Vec<u8>",
      InkInstantiate: {
        codeHash: "H256",
        salt: "Vec<u8>",
        instantiateData: "Vec<u8>",
        deposit: "u128",
        transfer: "u128"
      }
    }
  },
  InkQuery: {
    head: "ContractQueryHead",
    data: "InkQueryData"
  },
  InkQueryError: {
    _enum: {
      BadOrigin: null,
      RuntimeError: "String",
      SidevmNotFound: null,
      NoResponse: null,
      ServiceUnavailable: null,
      Timeout: null
    }
  },
  InkQueryOk: {
    _enum: {
      InkMessageReturn: "Vec<u8>"
    }
  },
  InkResponse: {
    nonce: "[u8; 32]",
    result: "Result<InkQueryOk, InkQueryError>"
  },
  InkMessage: {
    nonce: "Vec<u8>",
    message: "Vec<u8>",
    transfer: "u128",
    gasLimit: "u64",
    storageDepositLimit: "Option<u128>"
  },
  InkCommand: { _enum: { InkMessage: "InkMessage" } },
  ContractError: {
    _enum: {
      InvalidScheduleVersion: null,
      InvalidCallFlags: null,
      OutOfGas: null,
      OutputBufferTooSmall: null,
      TransferFailed: null,
      MaxCallDepthReached: null,
      ContractNotFound: null,
      CodeTooLarge: null,
      CodeNotFound: null,
      OutOfBounds: null,
      DecodingFailed: null,
      ContractTrapped: null,
      ValueTooLarge: null,
      TerminatedWhileReentrant: null,
      InputForwarded: null,
      RandomSubjectTooLong: null,
      TooManyTopics: null,
      NoChainExtension: null,
      DuplicateContract: null,
      TerminatedInConstructor: null,
      ReentranceDenied: null,
      StorageDepositNotEnoughFunds: null,
      StorageDepositLimitExhausted: null,
      CodeInUse: null,
      ContractReverted: null,
      CodeRejected: null,
      Indeterministic: null
    }
  }
};
var phalaRegistryTypes = { ...types, ...typeDefinitions, ...SubstrateLookupTypes };
var phalaTypes = new TypeRegistry();
phalaTypes.register(phalaRegistryTypes);
function options(options2 = {}) {
  return {
    ...options2,
    types: {
      ...phalaRegistryTypes,
      ...options2.types || {}
    }
  };
}

// src/pruntime/certificate.ts
var import_proto = __toESM(require_proto());

// src/pruntime/eip712.ts
import { hexToU8a, u8aToHex } from "@polkadot/util";
import { blake2AsU8a, encodeAddress, secp256k1Compress } from "@polkadot/util-crypto";
import { hashMessage, recoverPublicKey } from "viem";
import { signMessage } from "viem/wallet";
var SALT = "0x0ea813d1592526d672ea2576d7a07914cef2ca301b35c5eed941f7c897512a00";
async function etherAddressToCompactPubkey(client, account) {
  const msg = "0x48656c6c6f";
  const sign = await signMessage(client, { account, message: msg });
  const hash = hashMessage(msg);
  const recovered = await recoverPublicKey({ hash, signature: sign });
  const compactPubkey = u8aToHex(secp256k1Compress(hexToU8a(recovered)));
  return compactPubkey;
}
async function etherAddressToSubstrateAddress(client, account) {
  const compactPubkey = await etherAddressToCompactPubkey(client, account);
  const substratePubkey = encodeAddress(blake2AsU8a(hexToU8a(compactPubkey)), 42);
  return substratePubkey;
}
function createEip712StructedDataSignCertificate(account, encodedCert, ttl) {
  return {
    domain: {
      name: "Phat Query Certificate",
      version: "1",
      salt: SALT
    },
    message: {
      description: "You are signing a Certificate that can be used to query Phat Contracts using your identity without further prompts.",
      timeToLive: `The Certificate will be valid till block ${ttl}.`,
      encodedCert
    },
    primaryType: "IssueQueryCertificate",
    types: {
      EIP712Domain: [
        { name: "name", type: "string" },
        { name: "version", type: "string" },
        { name: "salt", type: "bytes32" }
      ],
      IssueQueryCertificate: [
        { name: "description", type: "string" },
        { name: "timeToLive", type: "string" },
        { name: "encodedCert", type: "bytes" }
      ]
    },
    account
  };
}
function createEip712StructedDataSignQuery(account, encodedQuery) {
  return {
    domain: {
      name: "Phat Contract Query",
      version: "1",
      salt: SALT
    },
    message: {
      description: "You are signing a query request that would be sent to a Phat Contract.",
      encodedQuery
    },
    primaryType: "PhatContractQuery",
    types: {
      EIP712Domain: [
        { name: "name", type: "string" },
        { name: "version", type: "string" },
        { name: "salt", type: "bytes32" }
      ],
      PhatContractQuery: [
        { name: "description", type: "string" },
        { name: "encodedQuery", type: "bytes" }
      ]
    },
    account
  };
}

// src/pruntime/certificate.ts
var isUsingSigner = (params) => params.signer !== void 0;
function generatePair() {
  const generatedSeed = hexToU8a2(hexAddPrefix(randomHex(32)));
  const generatedPair = sr25519PairFromSeed(generatedSeed);
  return [generatedPair.secretKey, generatedPair.publicKey];
}
function getSignatureTypeFromAccount(account) {
  const keypairType = account.type || "sr25519";
  switch (keypairType) {
    case "sr25519":
      return import_proto.pruntime_rpc.SignatureType.Sr25519WrapBytes;
    case "ed25519":
      return import_proto.pruntime_rpc.SignatureType.Ed25519WrapBytes;
    case "ecdsa":
      return import_proto.pruntime_rpc.SignatureType.EcdsaWrapBytes;
  }
}
function getSignatureTypeFromPair(pair) {
  switch (pair.type) {
    case "sr25519":
      return import_proto.pruntime_rpc.SignatureType.Sr25519;
    case "ed25519":
      return import_proto.pruntime_rpc.SignatureType.Ed25519;
    case "ecdsa":
      return import_proto.pruntime_rpc.SignatureType.Ecdsa;
    default:
      throw new Error("Unsupported keypair type");
  }
}
function CertificateBody(pubkey, ttl, config_bits = 0) {
  const created = phalaTypes.createType("CertificateBody", { pubkey, ttl, config_bits });
  return created.toU8a();
}
async function signCertificate(params) {
  var _a;
  await cryptoWaitReady();
  if (params.api) {
    console.warn(
      "signCertificate not longer need pass the ApiPromise as parameter, it will remove from type hint in the next."
    );
  }
  if (!(params.signer && params.account || params.pair)) {
    throw new Error(
      "signCertificate: invalid parameters. Please check document for more information: https://www.npmjs.com/package/@phala/sdk"
    );
  }
  let { signatureType } = params;
  const ttl = params.ttl || 2147483647;
  const [secret, pubkey] = generatePair();
  const encodedCertificateBody = CertificateBody(u8aToHex2(pubkey), ttl);
  let signerPubkey;
  let signature;
  let address;
  if (isUsingSigner(params)) {
    const { account, signer } = params;
    address = account.address;
    signerPubkey = u8aToHex2(decodeAddress(address));
    if (!signatureType) {
      signatureType = getSignatureTypeFromAccount(account);
    }
    const signerResult = await ((_a = signer.signRaw) == null ? void 0 : _a.call(signer, {
      address,
      data: u8aToHex2(encodedCertificateBody),
      type: "bytes"
    }));
    if (signerResult) {
      signature = hexToU8a2(signerResult.signature);
    } else {
      throw new Error("Failed to sign certificate");
    }
  } else {
    const { pair } = params;
    address = pair.address;
    signerPubkey = u8aToHex2(pair.publicKey);
    if (!signatureType) {
      signatureType = getSignatureTypeFromPair(pair);
    }
    signature = pair.sign(encodedCertificateBody);
  }
  const certificate = {
    encodedBody: encodedCertificateBody,
    signature: {
      signedBy: {
        encodedBody: CertificateBody(signerPubkey, ttl),
        signature: null
      },
      signatureType,
      signature
    }
  };
  return { address, certificate, pubkey, secret };
}
async function unstable_signEip712Certificate({
  client,
  account,
  compactPubkey,
  ttl = 2147483647
}) {
  await cryptoWaitReady();
  const [secret, pubkey] = generatePair();
  const address = account.address || account;
  const eip712Cert = CertificateBody(u8aToHex2(pubkey), ttl);
  const signature = await signTypedData(
    client,
    createEip712StructedDataSignCertificate(account, u8aToHex2(eip712Cert), ttl)
  );
  const rootCert = CertificateBody(compactPubkey, ttl);
  const certificate = {
    encodedBody: eip712Cert,
    signature: {
      signedBy: {
        encodedBody: rootCert,
        signature: null
      },
      signatureType: import_proto.pruntime_rpc.SignatureType.Eip712,
      signature: hexToU8a2(signature)
    }
  };
  return { address, certificate, pubkey, secret };
}

// src/contracts/PinkCode.ts
import { SubmittableResult as SubmittableResult2, toPromiseMethod as toPromiseMethod3 } from "@polkadot/api";
import { Abi as Abi3 } from "@polkadot/api-contract/Abi";
import { hexToU8a as hexToU8a8, isU8a, isWasm, u8aToHex as u8aToHex5 } from "@polkadot/util";

// src/contracts/PinkBlueprint.ts
import { SubmittableResult, toPromiseMethod as toPromiseMethod2 } from "@polkadot/api";
import { Abi as Abi2 } from "@polkadot/api-contract/Abi";
import { createBluePrintTx, withMeta as withMeta2 } from "@polkadot/api-contract/base/util";
import { BN_ZERO as BN_ZERO3, hexAddPrefix as hexAddPrefix6, hexToU8a as hexToU8a7, isUndefined } from "@polkadot/util";
import { sr25519Agreement as sr25519Agreement3, sr25519PairFromSeed as sr25519PairFromSeed3 } from "@polkadot/util-crypto";
import { from as from2 } from "rxjs";

// src/pruntime/coders.ts
import { BN, BN_ZERO, hexAddPrefix as hexAddPrefix3, hexToU8a as hexToU8a4, stringToHex, u8aToHex as u8aToHex3 } from "@polkadot/util";
import { sr25519Agreement } from "@polkadot/util-crypto";

// src/utils/aes-256-gcm.ts
import { Buffer as Buffer2 } from "buffer";
import { hexAddPrefix as hexAddPrefix2, hexStripPrefix, hexToU8a as hexToU8a3 } from "@polkadot/util";
import { createCipheriv, createDecipheriv } from "browserify-cipher";
var ALGO = "aes-256-gcm";
var AUTH_TAG_LENGTH = 32;
var toU8a = (param) => {
  if (typeof param === "string") {
    param = hexAddPrefix2(param);
    return hexToU8a3(param);
  }
  return param;
};
var encrypt = (data, key, iv) => {
  data = hexStripPrefix(data);
  const cipher = createCipheriv(ALGO, toU8a(key), Buffer2.from(toU8a(iv)));
  const enc = cipher.update(data, "hex", "hex");
  cipher.final();
  return `${enc}${cipher.getAuthTag().toString("hex")}`;
};
var decrypt = (enc, key, iv) => {
  enc = hexStripPrefix(enc);
  const decipher = createDecipheriv(ALGO, toU8a(key), Buffer2.from(toU8a(iv)));
  const authTag = hexToU8a3(hexAddPrefix2(enc.slice(-AUTH_TAG_LENGTH)));
  decipher.setAuthTag(authTag);
  const data = decipher.update(enc.slice(0, -AUTH_TAG_LENGTH), "hex", "hex");
  decipher.final();
  return data;
};

// src/pruntime/coders.ts
function encodeNumber(n, defaults = BN_ZERO) {
  if (!n) {
    return defaults;
  }
  if (typeof n === "bigint") {
    return n;
  }
  return new BN(n);
}
function InkQueryMessage(address, payload, deposit, transfer, estimating) {
  return phalaTypes.createType("InkQuery", {
    head: {
      nonce: hexAddPrefix3(randomHex(32)),
      id: address
    },
    data: {
      InkMessage: {
        payload,
        deposit: encodeNumber(deposit),
        transfer: encodeNumber(transfer),
        estimating: !!estimating
      }
    }
  });
}
function InkQuerySidevmMessage(address, sidevmMessage) {
  return phalaTypes.createType("InkQuery", {
    head: {
      nonce: hexAddPrefix3(randomHex(32)),
      id: address
    },
    data: {
      SidevmMessage: stringToHex(JSON.stringify(sidevmMessage))
    }
  });
}
function InkQueryInstantiate(address, codeHash, instantiateData, salt, deposit, transfer) {
  return phalaTypes.createType("InkQuery", {
    head: {
      nonce: hexAddPrefix3(randomHex(32)),
      id: address
    },
    data: {
      InkInstantiate: {
        codeHash,
        salt,
        instantiateData,
        deposit: encodeNumber(deposit),
        transfer: encodeNumber(transfer)
      }
    }
  });
}
function PlainInkCommand(address, encParams, nonce, value, gas, storageDepositLimit) {
  return phalaTypes.createType("CommandPayload", {
    Plain: phalaTypes.createType("InkCommand", {
      InkMessage: {
        nonce,
        message: phalaTypes.createType("Vec<u8>", encParams).toHex(),
        transfer: value,
        gasLimit: gas.refTime,
        storageDepositLimit
      }
    })
  });
}
function EncryptedInkCommand(address, encParams, nonce, value, gas, storageDepositLimit) {
  const [sk, pk] = generatePair();
  const commandAgreementKey = sr25519Agreement(sk, hexToU8a4(address));
  const payload = phalaTypes.createType("InkCommand", {
    InkMessage: {
      nonce,
      message: phalaTypes.createType("Vec<u8>", encParams).toHex(),
      transfer: value,
      gasLimit: gas.refTime,
      storageDepositLimit
    }
  });
  const iv = hexAddPrefix3(randomHex(12));
  return phalaTypes.createType("CommandPayload", {
    Encrypted: {
      iv,
      pubkey: u8aToHex3(pk),
      data: hexAddPrefix3(encrypt(payload.toHex(), commandAgreementKey, hexToU8a4(iv)))
    }
  });
}

// src/pruntime/pinkQuery.ts
import { hexAddPrefix as hexAddPrefix4, hexToU8a as hexToU8a5, u8aToHex as u8aToHex4 } from "@polkadot/util";
import { sr25519Sign } from "@polkadot/util-crypto";
var import_proto2 = __toESM(require_proto());
function createEncryptedData(pk, data, agreementKey) {
  const iv = hexAddPrefix4(randomHex(12));
  return {
    iv,
    pubkey: u8aToHex4(pk),
    data: hexAddPrefix4(encrypt(data, agreementKey, hexToU8a5(iv)))
  };
}
async function pinkQuery(pruntimeApi, pk, queryAgreementKey, encodedQuery, { certificate, pubkey, secret }) {
  const encryptedData = createEncryptedData(pk, encodedQuery, queryAgreementKey);
  const encodedEncryptedData = phalaTypes.createType("EncryptedData", encryptedData).toU8a();
  const signature = {
    signedBy: certificate,
    signatureType: import_proto2.pruntime_rpc.SignatureType.Sr25519,
    // signature: sr25519Sign(pubkey, secret, encodedEncryptedData),
    signature: sr25519Sign(encodedEncryptedData, { publicKey: pubkey, secretKey: secret })
  };
  const requestData = {
    encodedEncryptedData,
    signature
  };
  const res = await pruntimeApi.contractQuery(requestData);
  const { data: encryptedResult, iv } = phalaTypes.createType("EncryptedData", res.encodedEncryptedData);
  const data = decrypt(encryptedResult.toString(), queryAgreementKey, iv);
  return hexAddPrefix4(data);
}

// src/utils/assert.ts
function assert(expected, message) {
  if (!expected) {
    throw new Error(message);
  }
}

// src/utils/constants.ts
import { BN as BN2 } from "@polkadot/util";
var BN_MAX_SUPPLY = new BN2(1e12).mul(new BN2(1e9));

// src/utils/signAndSend.ts
var SignAndSendError = class extends Error {
  constructor() {
    super(...arguments);
    this.isCancelled = false;
  }
};
function callback(resolve, reject, result, unsub) {
  if (result.status.isInBlock) {
    let error;
    for (const e of result.events) {
      const {
        event: { data, method, section }
      } = e;
      if (section === "system" && method === "ExtrinsicFailed") {
        error = data[0];
      }
    }
    ;
    unsub();
    if (error) {
      reject(error);
    } else {
      resolve(result);
    }
  } else if (result.status.isInvalid) {
    ;
    unsub();
    reject("Invalid transaction");
  }
}
function signAndSend(target, address, signer) {
  return new Promise(async (resolve, reject) => {
    try {
      if (signer) {
        const unsub = await target.signAndSend(address, { signer }, (result) => {
          callback(resolve, reject, result, unsub);
        });
      } else {
        const unsub = await target.signAndSend(address, (result) => {
          callback(resolve, reject, result, unsub);
        });
      }
    } catch (error) {
      const isCancelled = error.message.indexOf("Cancelled") !== -1;
      Object.defineProperty(error, "isCancelled", {
        enumerable: false,
        value: isCancelled
      });
      reject(error);
    }
  });
}
var signAndSend_default = signAndSend;

// src/contracts/PinkContract.ts
import { toPromiseMethod } from "@polkadot/api";
import { Abi } from "@polkadot/api-contract/Abi";
import { ContractSubmittableResult } from "@polkadot/api-contract/base/Contract";
import { convertWeight, withMeta } from "@polkadot/api-contract/base/util";
import { applyOnEvent } from "@polkadot/api-contract/util";
import { BN_ZERO as BN_ZERO2, hexAddPrefix as hexAddPrefix5, hexToU8a as hexToU8a6, isHex } from "@polkadot/util";
import { sr25519Agreement as sr25519Agreement2, sr25519PairFromSeed as sr25519PairFromSeed2 } from "@polkadot/util-crypto";
import { from } from "rxjs";
var PinkContractSubmittableResult = class extends ContractSubmittableResult {
  #registry;
  #isFinalized = false;
  #contract;
  #message;
  #nonce;
  constructor(registry, contract, nonce, message, result, contractEvents) {
    super(result, contractEvents);
    this.#registry = registry;
    this.#contract = contract;
    this.#message = message;
    this.#nonce = nonce;
  }
  get nonce() {
    return this.#nonce;
  }
  async throwsOnErrorLog(chainHeight) {
    const logger = this.#registry.loggerContract;
    if (!logger) {
      return;
    }
    const { records } = await logger.tail(10, { contract: this.#contract.address.toHex() });
    const sinceSubmitted = records.filter(
      (i) => (i.type === "Log" || i.type === "MessageOutput") && i.blockNumber >= chainHeight
    );
    sinceSubmitted.reverse();
    sinceSubmitted.forEach((msg) => {
      if (msg.type === "MessageOutput" && "ok" in msg.output.result) {
        const { ok } = msg.output.result;
        if (ok.flags.length && ok.flags[0] === "Revert" && this.#message.returnType) {
          const returns = this.#contract.abi.registry.createType(this.#message.returnType.type, hexToU8a6(ok.data));
          throw new Error(JSON.stringify(returns.toHuman()));
        }
      } else if (msg.type === "Log" && msg.execMode === "transaction") {
        throw new Error(msg.message);
      }
    });
  }
  async waitFinalized(predicate, options2) {
    if (this.#isFinalized) {
      return;
    }
    if (!this.isInBlock && !this.isFinalized) {
      throw new Error("Contract transaction submit failed.");
    }
    const codeHash = this.status.asInBlock.toString();
    const block = await this.#registry.api.rpc.chain.getBlock(codeHash);
    const chainHeight = block.block.header.number.toNumber();
    const t0 = (/* @__PURE__ */ new Date()).getTime();
    const timeout = (options2 == null ? void 0 : options2.timeout) ?? 12e4;
    const blocks = (options2 == null ? void 0 : options2.blocks) ?? 10;
    if (!predicate) {
      while (true) {
        await this.throwsOnErrorLog(chainHeight);
        const { blocknum: currentHeight } = await this.#registry.phactory.getInfo({});
        if (currentHeight > chainHeight) {
          this.#isFinalized = true;
          return;
        }
        if (currentHeight - blocks > chainHeight) {
          throw new Error("Timeout");
        }
        if ((/* @__PURE__ */ new Date()).getTime() - t0 > timeout) {
          throw new Error("Timeout");
        }
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
    } else {
      while (true) {
        await this.throwsOnErrorLog(chainHeight);
        const { blocknum: currentHeight } = await this.#registry.phactory.getInfo({});
        const isOk = await predicate();
        if (isOk) {
          this.#isFinalized = true;
          return;
        }
        if (currentHeight - blocks > chainHeight) {
          throw new Error("Timeout");
        }
        if ((/* @__PURE__ */ new Date()).getTime() - t0 > timeout) {
          throw new Error("Timeout");
        }
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
    }
  }
};
var PinkContractPromise = class {
  constructor(api, phatRegistry, abi, address, contractKey) {
    this.#query = {};
    this.#tx = {};
    this.#inkQuery = (isEstimating, messageOrId, options2, params) => {
      const message = this.abi.findMessage(messageOrId);
      const api = this.api;
      if (!options2.cert) {
        throw new Error(
          "You need to provide the `cert` parameter in the options to process a Phat Contract query. Please check the document for a more detailed code snippet: https://www.npmjs.com/package/@phala/sdk"
        );
      }
      const { cert } = options2;
      const seed = hexToU8a6(hexAddPrefix5(randomHex(32)));
      const pair = sr25519PairFromSeed2(seed);
      const [sk, pk] = [pair.secretKey, pair.publicKey];
      const queryAgreementKey = sr25519Agreement2(sk, hexToU8a6(hexAddPrefix5(this.phatRegistry.remotePubkey)));
      const inkQueryInternal = async (origin) => {
        var _a;
        if (typeof origin === "string") {
          assert(origin === cert.address, "origin must be the same as the certificate address");
        } else if (origin.hasOwnProperty("verify") && origin.hasOwnProperty("adddress")) {
          throw new Error("Contract query expected AccountId as first parameter but since we got signer object here.");
        } else {
          assert(origin.toString() === cert.address, "origin must be the same as the certificate address");
        }
        const payload = InkQueryMessage(
          this.address,
          message.toU8a(params),
          options2.deposit,
          options2.transfer,
          options2.estimating !== void 0 ? !!options2.estimating : isEstimating
        );
        const data = await pinkQuery(this.phatRegistry.phactory, pk, queryAgreementKey, payload.toHex(), cert);
        const inkResponse = api.createType("InkResponse", data);
        if (inkResponse.result.isErr) {
          throw new Error(`InkResponse Error: ${inkResponse.result.asErr.toString()}`);
        }
        if (!inkResponse.result.asOk.isInkMessageReturn) {
          throw new Error(`Unexpected InkMessageReturn: ${(_a = inkResponse.result.asOk.toJSON()) == null ? void 0 : _a.toString()}`);
        }
        const { debugMessage, gasConsumed, gasRequired, result, storageDeposit } = api.createType(
          "ContractExecResult",
          inkResponse.result.asOk.asInkMessageReturn.toString()
        );
        return {
          debugMessage,
          gasConsumed,
          gasRequired: gasRequired && !convertWeight(gasRequired).v1Weight.isZero() ? gasRequired : gasConsumed,
          output: result.isOk && message.returnType ? this.abi.registry.createTypeUnsafe(
            message.returnType.lookupName || message.returnType.type,
            [result.asOk.data.toU8a(true)],
            { isPedantic: true }
          ) : null,
          result,
          storageDeposit
        };
      };
      return {
        send: this._decorateMethod((origin) => from(inkQueryInternal(origin)))
      };
    };
    this.#inkCommand = (messageOrId, options2, params) => {
      options2.nonce && assert(isHex(options2.nonce) && options2.nonce.length === 66, "Invalid nonce provided");
      const nonce = options2.nonce || hexAddPrefix5(randomHex(32));
      const command = options2.plain ? PlainInkCommand : EncryptedInkCommand;
      const message = this.abi.findMessage(messageOrId);
      const payload = command(
        this.contractKey,
        message.toU8a(params),
        nonce,
        options2.value,
        convertWeight(options2.gasLimit || BN_ZERO2).v2Weight,
        options2.storageDepositLimit
      );
      return this.api.tx.phalaPhatContracts.pushContractMessage(this.address, payload.toHex(), options2.deposit || BN_ZERO2).withResultTransform((result) => {
        return new PinkContractSubmittableResult(
          this.phatRegistry,
          this,
          nonce,
          message,
          result,
          applyOnEvent(result, ["ContractEmitted", "ContractExecution"], (records) => {
            return records.map(
              ({
                event: {
                  data: [, data]
                }
              }) => {
                try {
                  return this.abi.decodeEvent(data);
                } catch (error) {
                  console.error(`Unable to decode contract event: ${error.message}`);
                  return null;
                }
              }
            ).filter((decoded) => !!decoded);
          })
        );
      });
    };
    if (!api || !api.isConnected || !api.tx) {
      throw new Error("Your API has not been initialized correctly and is not connected to a chain");
    }
    if (!phatRegistry.isReady()) {
      throw new Error("Your phatRegistry has not been initialized correctly.");
    }
    this.abi = abi instanceof Abi ? abi : new Abi(abi, api.registry.getChainProperties());
    this.api = api;
    this._decorateMethod = toPromiseMethod;
    this.phatRegistry = phatRegistry;
    this.address = this.registry.createType("AccountId", address);
    this.contractKey = contractKey;
    this.abi.messages.forEach((meta) => {
      if (meta.isMutating) {
        this.#tx[meta.method] = withMeta(
          meta,
          (options2, ...params) => {
            return this.#inkCommand(meta, options2, params);
          }
        );
        this.#query[meta.method] = withMeta(
          meta,
          (origin, options2, ...params) => {
            return this.#inkQuery(true, meta, options2, params).send(origin);
          }
        );
      } else {
        this.#query[meta.method] = withMeta(
          meta,
          (origin, options2, ...params) => {
            return this.#inkQuery(false, meta, options2, params).send(origin);
          }
        );
      }
    });
  }
  #query;
  #tx;
  get send() {
    return new Proxy(
      {},
      {
        get: (_target, prop, _receiver) => {
          const meta = this.abi.messages.filter((i) => i.method === prop);
          if (!meta || !meta.length) {
            throw new Error("Method not found");
          }
          return withMeta(meta[0], (options2, ...arags) => {
            return this.#send(prop, options2, ...arags);
          });
        }
      }
    );
  }
  get registry() {
    return this.api.registry;
  }
  get query() {
    return this.#query;
  }
  get tx() {
    return this.#tx;
  }
  #inkQuery;
  #inkCommand;
  async #send(messageOrId, options2, ...args) {
    const { cert: userCert, ...rest } = options2;
    const txOptions = {
      gasLimit: options2.gasLimit,
      value: options2.value,
      storageDepositLimit: options2.storageDepositLimit,
      plain: options2.plain,
      nonce: options2.nonce
    };
    const tx = this.#tx[messageOrId];
    if (!tx) {
      throw new Error(`Message not found: ${messageOrId}`);
    }
    const address = "signer" in rest ? rest.address : rest.pair.address;
    const cert = userCert || await this.phatRegistry.getAnonymousCert();
    const estimate = this.#query[messageOrId];
    if (!estimate) {
      throw new Error(`Message not found: ${messageOrId}`);
    }
    const { gasPrice } = this.phatRegistry.clusterInfo ?? {};
    if (!gasPrice) {
      throw new Error("No Gas Price or deposit Per Byte from cluster info.");
    }
    const [clusterBalance, onchainBalance, { gasRequired, storageDeposit }] = await Promise.all([
      this.phatRegistry.getClusterBalance(address),
      this.api.query.system.account(address),
      estimate(cert.address, { cert, deposit: BN_MAX_SUPPLY }, ...args)
    ]);
    const gasLimit = gasRequired.refTime.toBn();
    const storageDepositFee = storageDeposit.isCharge ? storageDeposit.asCharge.toBn() : BN_ZERO2;
    const minRequired = gasLimit.mul(gasPrice).add(storageDepositFee);
    if (clusterBalance.free.lt(minRequired)) {
      const deposit = minRequired.sub(clusterBalance.free);
      if (onchainBalance.data.free.lt(deposit)) {
        throw new Error(`Not enough balance to pay for gas and storage deposit: ${minRequired.toNumber()}`);
      }
      txOptions.deposit = deposit;
    }
    if (!txOptions.gasLimit) {
      txOptions.gasLimit = gasRequired.refTime.toBn();
    }
    if ("signer" in rest) {
      return await signAndSend_default(tx(txOptions, ...args), rest.address, rest.signer);
    } else {
      return await signAndSend_default(tx(txOptions, ...args), rest.pair);
    }
  }
};

// src/contracts/PinkBlueprint.ts
var PinkBlueprintSubmittableResult = class extends SubmittableResult {
  constructor(result, abi, registry, contractId) {
    super(result);
    this.#isFinalized = false;
    this.registry = registry;
    this.abi = abi;
    this.#contractId = contractId;
  }
  #contractId;
  #isFinalized;
  #contract;
  get contractId() {
    if (!this.#contractId) {
      throw new Error(`Failed to find contract ID in events, maybe instantiate failed: ${this.#contractId}`);
    }
    return this.#contractId;
  }
  async waitFinalized(timeout = 12e4) {
    if (this.#isFinalized) {
      return;
    }
    if (this.isInBlock || this.isFinalized) {
      let contractId;
      for (const event of this.events) {
        if (event.event.method === "Instantiating") {
          contractId = event.event.data.contract.toString();
          break;
        }
      }
      if (!contractId) {
        throw new Error("Failed to find contract ID in events, maybe instantiate failed.");
      }
      this.#contractId = contractId;
      const logger = this.registry.loggerContract;
      const t0 = (/* @__PURE__ */ new Date()).getTime();
      while (true) {
        if (logger) {
          const { records } = await logger.tail(10, { contract: contractId });
          if (records.length > 0 && records[0].type === "Log" && records[0].execMode === "transaction" && records[0].message.indexOf("instantiate failed") !== -1) {
            throw new Error(records[0].message);
          }
        }
        const result1 = await this.registry.api.query.phalaPhatContracts.clusterContracts(
          this.registry.clusterId
        );
        const contractIds = result1.map((i) => i.toString());
        if (contractIds.indexOf(contractId) !== -1) {
          const result2 = await this.registry.api.query.phalaRegistry.contractKeys(
            contractId
          );
          if (result2.isSome) {
            this.#isFinalized = true;
            if (this.contractId) {
              const contractKey = await this.registry.getContractKeyOrFail(this.contractId);
              this.#contract = new PinkContractPromise(
                this.registry.api,
                this.registry,
                this.abi,
                this.contractId,
                contractKey
              );
            }
            return;
          }
        }
        const t1 = (/* @__PURE__ */ new Date()).getTime();
        if (t1 - t0 > timeout) {
          throw new Error("Timeout");
        }
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
    }
    throw new Error(`instantiate failed for ${this.abi.info.source.wasmHash.toString()}`);
  }
  get contract() {
    if (!this.#contract) {
      throw new Error("contract is not ready yet, please call waitFinalized first");
    }
    return this.#contract;
  }
};
var PinkBlueprintPromise = class {
  constructor(api, phatRegistry, abi, codeHash) {
    this.#query = {};
    this.#tx = {};
    this.#deploy = (constructorOrId, { gasLimit = BN_ZERO3, storageDepositLimit = null, value = BN_ZERO3, deposit = BN_ZERO3, salt }, params) => {
      if (!salt) {
        salt = randomHex(4);
      }
      const codeHash = this.abi.info.source.wasmHash.toString();
      return this.api.tx.phalaPhatContracts.instantiateContract(
        { WasmCode: codeHash },
        this.abi.findConstructor(constructorOrId).toU8a(params),
        salt,
        this.phatRegistry.clusterId,
        value,
        // not transfer any token to the contract during initialization
        gasLimit,
        storageDepositLimit,
        deposit
      ).withResultTransform((result) => {
        let maybeContactId;
        const instantiateEvent = result.events.filter((i) => i.event.method === "Instantiating")[0];
        if (instantiateEvent) {
          const contractId = instantiateEvent.event.data.contract;
          if (contractId) {
            maybeContactId = contractId.toString();
          }
        }
        return new PinkBlueprintSubmittableResult(result, this.abi, this.phatRegistry, maybeContactId);
      });
    };
    this.#estimateGas = (constructorOrId, options2, params) => {
      const seed = hexToU8a7(hexAddPrefix6(randomHex(32)));
      const pair = sr25519PairFromSeed3(seed);
      const [sk, pk] = [pair.secretKey, pair.publicKey];
      const { cert } = options2;
      const queryAgreementKey = sr25519Agreement3(sk, hexToU8a7(hexAddPrefix6(this.phatRegistry.remotePubkey)));
      const inkQueryInternal = async (origin) => {
        if (typeof origin === "string") {
          assert(origin === cert.address, "origin must be the same as the certificate address");
        } else if (origin.hasOwnProperty("verify") && origin.hasOwnProperty("adddress")) {
          throw new Error("Contract query expected AccountId as first parameter but since we got signer object here.");
        } else {
          assert(origin.toString() === cert.address, "origin must be the same as the certificate address");
        }
        if (!this.phatRegistry.systemContract) {
          throw new Error(
            "The associated System Contract was not set up for You OnChainRegistry, causing the estimate gas to fail."
          );
        }
        const salt = options2.salt || randomHex(4);
        const payload = InkQueryInstantiate(
          this.phatRegistry.systemContract.address,
          this.abi.info.source.wasmHash,
          this.abi.findConstructor(constructorOrId).toU8a(params),
          salt,
          options2.deposit,
          options2.transfer
        );
        const rawResponse = await pinkQuery(this.phatRegistry.phactory, pk, queryAgreementKey, payload.toHex(), cert);
        const response = phalaTypes.createType("InkResponse", rawResponse);
        if (response.result.isErr) {
          return phalaTypes.createType("InkQueryError", response.result.asErr.toHex());
        }
        const result = phalaTypes.createType(
          "ContractInstantiateResult",
          response.result.asOk.asInkMessageReturn.toHex()
        );
        result.salt = salt;
        if (result.result.isErr) {
          const err = result.result.asErr;
          if (err.isModule && err.asModule.index.toNumber() === 4) {
            const contractError = phalaTypes.createType("ContractError", result.result.asErr.asModule.error);
            throw new Error(`Estimation failed: ${contractError.toHuman()}`);
          }
          throw new Error("Estimation failed: " + JSON.stringify(result.result.asErr.toHuman()));
        }
        return result;
      };
      return {
        send: this._decorateMethod((origin) => from2(inkQueryInternal(origin)))
      };
    };
    if (!api || !api.isConnected || !api.tx) {
      throw new Error("Your API has not been initialized correctly and is not connected to a chain");
    }
    if (!phatRegistry.isReady()) {
      throw new Error("Your phatRegistry has not been initialized correctly.");
    }
    this.abi = abi instanceof Abi2 ? abi : new Abi2(abi, api.registry.getChainProperties());
    this.api = api;
    this._decorateMethod = toPromiseMethod2;
    this.phatRegistry = phatRegistry;
    this.codeHash = phalaTypes.createType("Hash", codeHash);
    this.abi.constructors.forEach((meta) => {
      if (isUndefined(this.#tx[meta.method])) {
        this.#tx[meta.method] = createBluePrintTx(
          meta,
          (o, p) => this.#deploy(meta, o, p)
        );
        this.#query[meta.method] = withMeta2(
          meta,
          (origin, options2, ...params) => this.#estimateGas(meta, options2, params).send(origin)
        );
      }
    });
  }
  #query;
  #tx;
  get tx() {
    return this.#tx;
  }
  get query() {
    return this.#query;
  }
  get send() {
    return new Proxy(
      {},
      {
        get: (_target, prop, _receiver) => {
          const meta = this.abi.constructors.filter((i) => i.method === prop);
          if (!meta || !meta.length) {
            throw new Error("Method not found");
          }
          return withMeta2(meta[0], (options2, ...arags) => {
            return this.#send(prop, options2, ...arags);
          });
        }
      }
    );
  }
  #deploy;
  #estimateGas;
  async #send(constructorOrId, options2, ...args) {
    const { cert: userCert, ...rest } = options2;
    const txOptions = {
      gasLimit: options2.gasLimit,
      value: options2.value,
      storageDepositLimit: options2.storageDepositLimit
    };
    const tx = this.#tx[constructorOrId];
    if (!tx) {
      throw new Error(`Constructor not found: ${constructorOrId}`);
    }
    const address = "signer" in rest ? rest.address : rest.pair.address;
    const cert = userCert || await this.phatRegistry.getAnonymousCert();
    const estimate = this.#query[constructorOrId];
    if (!estimate) {
      throw new Error(`Constructor not found: ${constructorOrId}`);
    }
    const { gasPrice } = this.phatRegistry.clusterInfo ?? {};
    if (!gasPrice) {
      throw new Error("No Gas Price or deposit Per Byte from cluster info.");
    }
    const [clusterBalance, onchainBalance, { gasRequired, storageDeposit }] = await Promise.all([
      this.phatRegistry.getClusterBalance(address),
      this.api.query.system.account(address),
      // We estimating the gas & storage deposit cost with deposit propose.
      estimate(cert.address, { cert, deposit: BN_MAX_SUPPLY }, ...args)
    ]);
    const gasLimit = gasRequired.refTime.toBn();
    const storageDepositFee = storageDeposit.isCharge ? storageDeposit.asCharge.toBn() : BN_ZERO3;
    const minRequired = gasLimit.mul(gasPrice).add(storageDepositFee);
    if (clusterBalance.free.lt(minRequired)) {
      const deposit = minRequired.sub(clusterBalance.free);
      if (onchainBalance.data.free.lt(deposit)) {
        throw new Error(`Not enough balance to pay for gas and storage deposit: ${minRequired.toNumber()}`);
      }
      txOptions.deposit = deposit;
    }
    if (!txOptions.gasLimit) {
      txOptions.gasLimit = gasLimit;
    }
    if ("signer" in rest) {
      return await signAndSend_default(tx(txOptions, ...args), rest.address, rest.signer);
    } else {
      return await signAndSend_default(tx(txOptions, ...args), rest.pair);
    }
  }
};

// src/contracts/PinkCode.ts
var InkCodeSubmittableResult = class extends SubmittableResult2 {
  constructor(result, abi, registry) {
    super(result);
    this.#isFinalized = false;
    this.registry = registry;
    this.abi = abi;
    this.blueprint = new PinkBlueprintPromise(this.registry.api, this.registry, this.abi, this.abi.info.source.wasmHash);
  }
  #isFinalized;
  async waitFinalized(pair, cert, timeout = 1e4) {
    if (this.#isFinalized) {
      return;
    }
    if (this.isInBlock || this.isFinalized) {
      const system = this.registry.systemContract;
      const codeHash = this.abi.info.source.wasmHash.toString();
      const t0 = (/* @__PURE__ */ new Date()).getTime();
      while (true) {
        const { output } = await system.query["system::codeExists"](pair.address, { cert }, codeHash, "Ink");
        if (output && output.asOk.toPrimitive()) {
          this.#isFinalized = true;
          return;
        }
        const t1 = (/* @__PURE__ */ new Date()).getTime();
        if (t1 - t0 > timeout) {
          throw new Error("Timeout");
        }
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
    }
    throw new Error("Not in block, your Code may upload failed.");
  }
};
var PinkCodePromise = class {
  constructor(api, phatRegistry, abi, wasm) {
    this.#tx = {};
    this.#instantiate = (_constructorOrId, _params) => {
      return this.api.tx.phalaPhatContracts.clusterUploadResource(this.phatRegistry.clusterId, "InkCode", u8aToHex5(this.code)).withResultTransform((result) => {
        return new InkCodeSubmittableResult(result, this.abi, this.phatRegistry);
      });
    };
    if (!api || !api.isConnected || !api.tx) {
      throw new Error("Your API has not been initialized correctly and is not connected to a chain");
    }
    if (!phatRegistry.isReady()) {
      throw new Error("Your phatRegistry has not been initialized correctly.");
    }
    this.abi = abi instanceof Abi3 ? abi : new Abi3(abi, api.registry.getChainProperties());
    this.api = api;
    this._decorateMethod = toPromiseMethod3;
    this.phatRegistry = phatRegistry;
    if (isWasm(this.abi.info.source.wasm)) {
      this.code = this.abi.info.source.wasm;
    } else if (isU8a(wasm)) {
      this.code = wasm;
    } else if (typeof wasm === "string" && wasm.substring(0, 2) === "0x") {
      this.code = hexToU8a8(wasm);
    } else {
      throw new Error("`wasm` should hex encoded string or Uint8Array.");
    }
    if (!isWasm(this.code)) {
      throw new Error("No WASM code provided");
    }
    this.#tx = new Proxy(
      {},
      {
        get: (_target, prop, _receiver) => {
          const meta = this.abi.constructors.filter((i) => i.method === prop);
          if (!meta || !meta.length) {
            throw new Error("Method not found");
          }
          return () => this.#instantiate(meta[0], []);
        }
      }
    );
  }
  #tx;
  get tx() {
    return this.#tx;
  }
  upload() {
    return this.#instantiate(0, []);
  }
  #instantiate;
};

// src/contracts/PinkLoggerContract.ts
import { Keyring } from "@polkadot/api";
import { Abi as Abi4 } from "@polkadot/api-contract";
import { hexAddPrefix as hexAddPrefix7, hexToString, hexToU8a as hexToU8a9, u8aToHex as u8aToHex6 } from "@polkadot/util";
import { blake2AsU8a as blake2AsU8a2, sr25519Agreement as sr25519Agreement4 } from "@polkadot/util-crypto";

// src/utils/snakeToPascalCase.ts
function snakeToPascalCase(snakeStr) {
  return snakeStr.toLowerCase().split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join("");
}
var regex_pascal_case = /^[A-Z][a-zA-Z0-9]*$/;
function isPascalCase(str) {
  return regex_pascal_case.test(str);
}

// src/contracts/Errors.ts
var ContractInitialError = class extends Error {
};

// src/contracts/PinkLoggerContract.ts
function sidevmQueryWithReader({ phactory, remotePubkey, address, cert }) {
  return async function unsafeRunSidevmQuery(sidevmMessage) {
    const [sk, pk] = generatePair();
    const encodedQuery = InkQuerySidevmMessage(address, sidevmMessage);
    const queryAgreementKey = sr25519Agreement4(sk, hexToU8a9(hexAddPrefix7(remotePubkey)));
    const response = await pinkQuery(phactory, pk, queryAgreementKey, encodedQuery.toHex(), cert);
    const inkResponse = phalaTypes.createType("InkResponse", response);
    if (inkResponse.result.isErr) {
      let error = `[${inkResponse.result.asErr.index}] ${inkResponse.result.asErr.type}`;
      if (inkResponse.result.asErr.type === "RuntimeError") {
        error = `${error}: ${inkResponse.result.asErr.value}`;
      }
      throw new Error(error);
    }
    const payload = inkResponse.result.asOk.asInkMessageReturn.toString();
    const parsed = payload.substring(0, 2) === "0x" ? JSON.parse(hexToString(payload)) : JSON.parse(payload);
    if (parsed.error) {
      throw new Error(parsed.error);
    }
    return parsed;
  };
}
function postProcessLogRecord(messages, abiLike) {
  let abi;
  if (abiLike) {
    abi = abiLike instanceof Abi4 ? abiLike : new Abi4(abiLike);
  }
  return messages.map((message) => {
    var _a;
    if (message.type === "MessageOutput") {
      const execResult = phalaTypes.createType("ContractExecResult", hexToU8a9(message.output));
      const output = execResult.toJSON();
      if (execResult.result.isErr && execResult.result.asErr.isModule && ((_a = execResult.result.asErr.asModule) == null ? void 0 : _a.index) === 4) {
        const err = phalaTypes.createType("ContractError", execResult.result.asErr.asModule.error);
        output.result = {
          err: {
            ...output.result.err,
            module: {
              error: err.toJSON(),
              index: 4
            }
          }
        };
      }
      return { ...message, output };
    } else if (message.type === "Event" && abi) {
      try {
        const decoded = abi.decodeEvent(hexToU8a9(message.payload));
        return { ...message, decoded };
      } catch (_err) {
      }
    }
    return message;
  });
}
function buildGetLogRequest(params, getFrom, getDefaults) {
  let request = getDefaults();
  switch (params.length) {
    case 0:
      request.from = getFrom(request);
      break;
    case 1:
      if (typeof params[0] === "number") {
        request.count = params[0];
        request.from = getFrom(request);
      } else {
        request.from = getFrom(params[0]);
        if (params[0].count) {
          request.count = params[0].count;
        }
        request = { ...params[0], ...request };
      }
      break;
    case 2:
      request.count = params[0];
      if (typeof params[1] === "number") {
        request.from = params[1];
      } else {
        request.from = getFrom(request);
        request = { ...params[1], ...request };
      }
      break;
    case 3:
      request = { ...params[2], count: params[0], from: params[1] };
      break;
    default:
      throw new Error("Unexpected parameters.");
  }
  return request;
}
function getTopicHash(topic) {
  if (topic.indexOf("::") === -1) {
    throw new Error("Invalid topic.");
  }
  let [contract, event] = topic.split("::");
  if (!isPascalCase(contract)) {
    contract = snakeToPascalCase(contract);
  }
  event = `${contract}::${event}`;
  const length = event.length;
  const encoded = phalaTypes.createType(`(Vec<u8>, [u8; ${length}])`, [null, event]).toU8a();
  if (encoded.length > 32) {
    return u8aToHex6(blake2AsU8a2(encoded));
  } else {
    return u8aToHex6(encoded) + "00".repeat(32 - encoded.length);
  }
}
var PinkLoggerContractPromise = class _PinkLoggerContractPromise {
  #phactory;
  #remotePubkey;
  #address;
  #pair;
  #systemContractId;
  static async create(_api, registry, systemContract, pair) {
    var _a;
    let _pair = pair;
    if (!_pair) {
      const keyring = new Keyring({ type: "sr25519" });
      _pair = keyring.addFromUri("//Alice");
    }
    const cert = await signCertificate({ pair: _pair });
    const { output } = await systemContract.query["system::getDriver"](_pair.address, { cert }, "PinkLogger");
    const contractId = output.asOk.toHex();
    if (!contractId) {
      throw new ContractInitialError("No PinkLogger contract registered in the cluster.");
    }
    const systemContractId = (_a = systemContract.address) == null ? void 0 : _a.toHex();
    if (!registry.phactory || !registry.remotePubkey) {
      throw new Error("No Pruntime connection found.");
    }
    return new _PinkLoggerContractPromise(registry.phactory, registry.remotePubkey, _pair, contractId, systemContractId);
  }
  // constructor(api: ApiPromise, registry: OnChainRegistry, contractId: string | AccountId, pair: KeyringPair, systemContractId: string) {
  constructor(phactory, remotePubkey, pair, contractId, systemContractId) {
    this.#phactory = phactory;
    this.#remotePubkey = remotePubkey;
    this.#address = phalaTypes.createType("AccountId", contractId);
    this.#pair = pair;
    this.#systemContractId = systemContractId;
  }
  async getSidevmQueryContext() {
    const cert = await signCertificate({ pair: this.#pair });
    const address = this.#address;
    const phactory = this.#phactory;
    const remotePubkey = this.#remotePubkey;
    return { phactory, remotePubkey, address, cert };
  }
  /**
   * This method call `GetLog` directly, and return the raw result. All encapulation methods is based on this method.
   * We keep this one for testing purpose, and it should less likely to be used in production.
   */
  async getLogRaw(query = {}) {
    const ctx = await this.getSidevmQueryContext();
    const unsafeRunSidevmQuery = sidevmQueryWithReader(ctx);
    return await unsafeRunSidevmQuery({
      action: "GetLog",
      from: query.from,
      count: query.count,
      contract: query.contract
    });
  }
  get address() {
    return this.#address;
  }
  /**
   * Get log records from the contract.
   *
   * @deprecated
   */
  async getLog(contract, from3 = 0, count = 100) {
    const result = await this.getLogRaw({
      contract,
      from: from3,
      count
    });
    return { records: postProcessLogRecord(result.records), next: result.next };
  }
  /**
   * Get the logger info. It use for probe the logger status.
   */
  async getInfo() {
    const ctx = await this.getSidevmQueryContext();
    const unsafeRunSidevmQuery = sidevmQueryWithReader(ctx);
    return await unsafeRunSidevmQuery({ action: "GetInfo" });
  }
  async tail(...params) {
    const { abi, type, topic, nonce, ...request } = buildGetLogRequest(
      params,
      (x) => {
        if (!x.from) {
          return x.count ? -x.count : -10;
        }
        return -(x.from + (x.count || 10));
      },
      () => ({ count: 10 })
    );
    const result = await this.getLogRaw(request);
    if (type) {
      if (Array.isArray(type)) {
        result.records = result.records.filter((record) => type.includes(record.type));
      } else if (type === "Event" && topic) {
        const topicHash = getTopicHash(topic);
        result.records = result.records.filter((record) => record.type === type && record.topics[0] === topicHash);
      } else if (type === "MessageOutput" && nonce) {
        result.records = result.records.filter((record) => record.type === type && record.nonce === nonce);
      } else {
        result.records = result.records.filter((record) => record.type === type);
      }
    }
    return { records: postProcessLogRecord(result.records, abi), next: result.next };
  }
  async head(...params) {
    const { abi, type, topic, nonce, ...request } = buildGetLogRequest(
      params,
      (x) => x.from || 0,
      () => ({ from: 0, count: 10 })
    );
    const result = await this.getLogRaw(request);
    if (type) {
      if (Array.isArray(type)) {
        result.records = result.records.filter((record) => type.includes(record.type));
      } else if (type === "Event" && topic) {
        const topicHash = getTopicHash(topic);
        result.records = result.records.filter((record) => record.type === type && record.topics[0] === topicHash);
      } else if (type === "MessageOutput" && nonce) {
        result.records = result.records.filter((record) => record.type === type && record.nonce === nonce);
      } else {
        result.records = result.records.filter((record) => record.type === type);
      }
    }
    return { records: postProcessLogRecord(result.records, abi), next: result.next };
  }
  /// System Contract Related.
  setSystemContract(contract) {
    var _a;
    if (typeof contract === "string") {
      this.#systemContractId = contract;
    } else {
      this.#systemContractId = (_a = contract.address) == null ? void 0 : _a.toHex();
    }
  }
  async headSystemLog(counts = 10, from3 = 0) {
    if (!this.#systemContractId) {
      throw new Error("System contract ID is not set.");
    }
    const contract = typeof this.#systemContractId === "string" ? this.#systemContractId : this.#systemContractId.toHex();
    return this.head(counts, from3, { contract });
  }
  async tailSystemLog(counts = 10, from3 = -10) {
    if (!this.#systemContractId) {
      throw new Error("System contract ID is not set.");
    }
    const contract = typeof this.#systemContractId === "string" ? this.#systemContractId : this.#systemContractId.toHex();
    return this.tail(counts, from3, { contract });
  }
};

// src/OnChainRegistry.ts
import { Keyring as Keyring2 } from "@polkadot/api";
import { cryptoWaitReady as cryptoWaitReady2 } from "@polkadot/util-crypto";

// src/pruntime/createPruntimeClient.ts
var import_proto3 = __toESM(require_proto());
import fetch from "cross-fetch";
function createPruntimeClient(baseURL) {
  const pruntimeApi = import_proto3.pruntime_rpc.PhactoryAPI.create(async (method, requestData, callback2) => {
    try {
      const resp = await fetch(`${baseURL}/prpc/PhactoryAPI.${method.name}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/octet-stream"
        },
        body: new Uint8Array(requestData)
      });
      if (resp.status === 200) {
        const buffer = await (await resp.blob()).arrayBuffer();
        callback2(null, new Uint8Array(buffer));
      } else if (resp.status === 400 || resp.status === 500) {
        let error;
        try {
          const buffer = await (await resp.blob()).arrayBuffer();
          const prpcError = import_proto3.prpc.PrpcError.decode(new Uint8Array(buffer));
          error = new Error(`PrpcError: ${prpcError.message}`);
        } catch (err) {
          error = new Error(`ServerError: ${resp.status}: ${await resp.text()}`);
        }
        throw error;
      } else {
        throw new Error(`Unexpected Response Status: ${resp.status}`);
      }
    } catch (err) {
      callback2(err);
    }
  });
  return pruntimeApi;
}

// src/ha/ack-first.ts
async function ack(workerId, endpoint) {
  const client = createPruntimeClient(endpoint);
  const info = await client.getInfo({});
  const actually = `0x${info.ecdhPublicKey || ""}`;
  if (actually === workerId) {
    return [workerId, endpoint, client];
  }
  throw new Error("On-chain worker ID not match to the worker ECDH PublicKey.");
}
function ackFirst() {
  return async function ackFirst2(apiPromise, clusterId) {
    const workersQuery = await apiPromise.query.phalaPhatContracts.clusterWorkers(clusterId);
    const workerIds = workersQuery.map((i) => i.toHex());
    const endpointsQuery = await apiPromise.query.phalaRegistry.endpoints.multi(workerIds);
    const pairs = endpointsQuery.map((i, idx) => [workerIds[idx], i]).filter(([_, maybeEndpoint]) => maybeEndpoint.isSome).map(([workerId, maybeEndpoint]) => [workerId, maybeEndpoint.unwrap().asV1[0].toString()]);
    try {
      return await Promise.any(pairs.map(([workerId, endpoint]) => ack(workerId, endpoint)));
    } catch (_err) {
      throw new Error("No worker available.");
    }
  };
}

// src/OnChainRegistry.ts
var UnexpectedEndpointError = class extends Error {
};
var OnChainRegistry = class _OnChainRegistry {
  constructor(api) {
    this.#ready = false;
    this.api = api;
  }
  #ready;
  #phactory;
  #alice;
  #cert;
  #systemContract;
  #loggerContract;
  async getContractKey(contractId) {
    const contractKey = await this.api.query.phalaRegistry.contractKeys(contractId);
    if (!contractKey) {
      return void 0;
    }
    return contractKey.toString();
  }
  async getContractKeyOrFail(contractId) {
    const contractKey = await this.getContractKey(contractId);
    if (!contractKey) {
      throw new Error(`Contract ${contractId} not found in cluster.`);
    }
    return contractKey;
  }
  isReady() {
    return this.#ready;
  }
  get phactory() {
    if (!this.#ready || !this.#phactory) {
      throw new Error("You need initialize OnChainRegistry first.");
    }
    return this.#phactory;
  }
  get gasPrice() {
    if (!this.#ready || !this.clusterInfo || !this.clusterInfo.gasPrice) {
      throw new Error("You need initialize OnChainRegistry first.");
    }
    return this.clusterInfo.gasPrice;
  }
  /**
   * Static factory method returns a ready to use PhatRegistry object.
   */
  static async create(api, options2) {
    options2 = { autoConnect: true, ...options2 || {} };
    const instance = new _OnChainRegistry(api);
    await Promise.all([cryptoWaitReady2(), api.isReady]);
    if (options2.autoConnect) {
      if (!options2.clusterId && !options2.workerId && !options2.pruntimeURL) {
        await instance.connect();
      } else if (options2.pruntimeURL) {
        const workerInfo = {
          clusterId: options2.clusterId,
          pruntimeURL: options2.pruntimeURL
        };
        await instance.connect(workerInfo);
      } else if (options2.strategy) {
        await instance.connect({
          clusterId: options2.clusterId,
          strategy: options2.strategy
        });
      } else {
        console.warn("Failed back to legacy connection mode, please use pruntimeURL instead.");
        await instance.connect(
          options2.clusterId,
          options2.workerId,
          options2.pruntimeURL,
          options2.systemContractId,
          !!options2.skipCheck
        );
      }
    }
    return instance;
  }
  async getAllClusters() {
    const result = await this.api.query.phalaPhatContracts.clusters.entries();
    return result.map(([storageKey, value]) => {
      const clusterId = storageKey.args.map((i) => i.toPrimitive())[0];
      const clusterInfo = value.unwrap();
      return [clusterId, clusterInfo];
    });
  }
  async getClusterInfoById(clusterId) {
    const result = await this.api.query.phalaPhatContracts.clusters(clusterId);
    if (result.isNone) {
      return null;
    }
    return result.unwrap();
  }
  async getClusters(clusterId) {
    if (clusterId) {
      const result = await this.api.query.phalaPhatContracts.clusters(clusterId);
      if (result.isNone) {
        return null;
      }
      return result.unwrap();
    } else {
      return await this.getAllClusters();
    }
  }
  async getEndpoints(workerId) {
    if (workerId) {
      if (typeof workerId !== "string") {
        workerId = workerId.toHex();
      }
      return await this.api.query.phalaRegistry.endpoints(workerId);
    }
    const result = await this.api.query.phalaRegistry.endpoints.entries();
    return result.map(([storageKey, value]) => {
      const workerId2 = storageKey.args.map((i) => i.toPrimitive())[0];
      return [workerId2, value];
    });
  }
  async getClusterWorkers(clusterId) {
    let _clusterId = clusterId || this.clusterId;
    if (!_clusterId) {
      const clusters = await this.getAllClusters();
      if (!clusters || clusters.length === 0) {
        throw new Error("You need specified clusterId to list workers inside it.");
      }
      _clusterId = clusters[0][0];
    }
    const result = await this.api.query.phalaPhatContracts.clusterWorkers(_clusterId);
    const workerIds = result.toJSON();
    const infos = await this.api.query.phalaRegistry.endpoints.multi(workerIds);
    return infos.map((i, idx) => [workerIds[idx], i]).filter(([_, maybeEndpoint]) => maybeEndpoint.isSome).map(
      ([workerId, maybeEndpoint]) => ({
        pubkey: workerId,
        clusterId: _clusterId,
        endpoints: {
          default: maybeEndpoint.unwrap().asV1[0].toString(),
          v1: maybeEndpoint.unwrap().asV1.map((i) => i.toString())
        }
      })
    );
  }
  async preparePruntimeClientOrThrows(endpoint) {
    try {
      const phactory = createPruntimeClient(endpoint);
      await phactory.getInfo({});
      return phactory;
    } catch (err) {
      console.error(err);
      throw new Error(
        "Phactory API not compatible, you might need downgrade your @phala/sdk or connect to an up-to-date endpoint."
      );
    }
  }
  async prepareSystemOrThrows(clusterInfo) {
    const systemContractId = clusterInfo.systemContract;
    if (systemContractId) {
      const systemContractKey = await this.getContractKey(systemContractId);
      if (systemContractKey) {
        this.#systemContract = new PinkContractPromise(this.api, this, system_default, systemContractId, systemContractKey);
        this.#loggerContract = await PinkLoggerContractPromise.create(this.api, this, this.#systemContract);
      } else {
        throw new Error(`System contract not found: ${systemContractId}`);
      }
    }
  }
  async connect(...args) {
    var _a;
    this.#ready = false;
    if (args.length === 0 || args.length === 1) {
      if (args.length === 0) {
        const clusters = await this.getAllClusters();
        if (!clusters || clusters.length === 0) {
          throw new Error("No cluster found.");
        }
        const [clusterId2, clusterInfo2] = clusters[0];
        const [workerId2, endpoint, phactory] = await ackFirst()(this.api, clusterId2);
        this.#phactory = phactory;
        this.clusterId = clusterId2;
        this.clusterInfo = clusterInfo2;
        this.workerInfo = {
          pubkey: workerId2,
          clusterId: clusterId2,
          endpoints: {
            default: endpoint,
            v1: [endpoint]
          }
        };
        this.#ready = true;
        await this.prepareSystemOrThrows(clusterInfo2);
        return;
      }
      if (args.length === 1 && args[0] instanceof Object) {
        if (args[0].strategy) {
          let clusterId2 = args[0].clusterId;
          let clusterInfo2;
          if (!clusterId2) {
            const clusters = await this.getAllClusters();
            if (!clusters || clusters.length === 0) {
              throw new Error("No cluster found.");
            }
            ;
            [clusterId2, clusterInfo2] = clusters[0];
          } else {
            clusterInfo2 = await this.getClusterInfoById(clusterId2);
            if (!clusterInfo2) {
              throw new Error(`Cluster not found: ${clusterId2}`);
            }
          }
          if (args[0].strategy === "ack-first") {
            const [workerId2, endpoint, phactory] = await ackFirst()(this.api, clusterId2);
            this.#phactory = phactory;
            this.clusterId = clusterId2;
            this.clusterInfo = clusterInfo2;
            this.workerInfo = {
              pubkey: workerId2,
              clusterId: clusterId2,
              endpoints: {
                default: endpoint,
                v1: [endpoint]
              }
            };
            this.#ready = true;
            await this.prepareSystemOrThrows(clusterInfo2);
          } else if (typeof args[0].strategy === "function") {
            const [workerId2, phactory] = await args[0].strategy(this.api, clusterId2);
            this.#phactory = phactory;
            this.clusterId = clusterId2;
            this.clusterInfo = clusterInfo2;
            this.workerInfo = {
              pubkey: workerId2,
              clusterId: clusterId2,
              endpoints: {
                default: phactory.endpoint,
                v1: [phactory.endpoint]
              }
            };
            this.#ready = true;
            await this.prepareSystemOrThrows(clusterInfo2);
          } else {
            throw new Error(`Unknown strategy: ${args[0].strategy}`);
          }
        } else if (args[0].pruntimeURL) {
          const partialInfo = args[0];
          const pruntimeURL2 = partialInfo.pruntimeURL;
          let clusterId2 = partialInfo.clusterId;
          if (!pruntimeURL2) {
            throw new Error("pruntimeURL is required.");
          }
          const phactory = createPruntimeClient(pruntimeURL2);
          if (!clusterId2) {
            const clusterInfoQuery = await phactory.getClusterInfo({});
            if ((_a = clusterInfoQuery == null ? void 0 : clusterInfoQuery.info) == null ? void 0 : _a.id) {
              clusterId2 = clusterInfoQuery.info.id;
            } else {
              throw new Error(`getClusterInfo is unavailable, please ensure ${pruntimeURL2} is valid PRuntime endpoint.`);
            }
          }
          const clusterInfo2 = await this.getClusterInfoById(clusterId2);
          if (!clusterInfo2) {
            throw new Error(`Cluster not found: ${partialInfo.clusterId}`);
          }
          const nodeInfo = await phactory.getInfo({});
          if (!nodeInfo || !nodeInfo.publicKey) {
            throw new Error(`Get PRuntime Pubkey failed.`);
          }
          this.#phactory = phactory;
          this.clusterId = clusterId2;
          this.clusterInfo = clusterInfo2;
          this.workerInfo = {
            pubkey: nodeInfo.publicKey,
            clusterId: clusterId2,
            endpoints: {
              default: pruntimeURL2
            }
          };
          this.#ready = true;
          await this.prepareSystemOrThrows(clusterInfo2);
        } else {
          const worker = args[0];
          const clusterInfo2 = await this.getClusterInfoById(worker.clusterId);
          if (!clusterInfo2) {
            throw new Error(`Cluster not found: ${worker.clusterId}`);
          }
          this.#phactory = await this.preparePruntimeClientOrThrows(worker.endpoints.default);
          this.clusterId = worker.clusterId;
          this.clusterInfo = clusterInfo2;
          this.workerInfo = worker;
          this.#ready = true;
          await this.prepareSystemOrThrows(clusterInfo2);
        }
        return;
      }
    }
    console.warn("Deprecated: connect to dedicated worker via legacy mode, please migrate to the new API.");
    let clusterId = args[0];
    let workerId = args[1];
    let pruntimeURL = args[2];
    let systemContractId = args[3];
    const skipCheck = args[4];
    let clusterInfo;
    if (clusterId) {
      clusterInfo = await this.getClusters(clusterId);
      if (!clusterInfo) {
        throw new Error(`Cluster not found: ${clusterId}`);
      }
    } else {
      const clusters = await this.getClusters();
      if (!clusters || !Array.isArray(clusters)) {
        throw new Error("No cluster found.");
      }
      if (clusters.length === 0) {
        throw new Error("No cluster found.");
      }
      clusterId = clusters[0][0];
      clusterInfo = clusters[0][1];
    }
    if (!skipCheck) {
      const endpoints = await this.getEndpoints();
      if (!Array.isArray(endpoints) || endpoints.length === 0) {
        throw new Error("No worker found.");
      }
      if (!workerId && !pruntimeURL) {
        workerId = endpoints[0][0];
        pruntimeURL = endpoints[0][1].unwrap().asV1[0].toPrimitive();
      } else if (pruntimeURL) {
        const endpoint = endpoints.find(([_, v]) => {
          const url = v.unwrap().asV1[0].toPrimitive();
          return url === pruntimeURL;
        });
        if (endpoint) {
          workerId = endpoint[0];
        }
      } else if (workerId) {
        const endpoint = endpoints.find(([id, _]) => id === workerId);
        if (!endpoint) {
          throw new Error(`Worker not found: ${workerId}`);
        }
        pruntimeURL = endpoint[1].unwrap().asV1[0].toPrimitive();
      }
    }
    this.#phactory = createPruntimeClient(pruntimeURL);
    try {
      await this.#phactory.getInfo({});
    } catch (err) {
      console.error(err);
      throw new Error(
        "Phactory API not compatible, you might need downgrade your @phala/sdk or connect to an up-to-date endpoint."
      );
    }
    this.clusterId = clusterId;
    this.workerInfo = {
      pubkey: workerId,
      clusterId,
      endpoints: {
        default: pruntimeURL,
        v1: [pruntimeURL]
      }
    };
    this.clusterInfo = clusterInfo;
    this.#ready = true;
    if (this.clusterInfo && this.clusterInfo.systemContract) {
      systemContractId = this.clusterInfo.systemContract;
    }
    if (systemContractId) {
      const systemContractKey = await this.getContractKey(systemContractId);
      if (systemContractKey) {
        this.#systemContract = new PinkContractPromise(this.api, this, system_default, systemContractId, systemContractKey);
        this.#loggerContract = await PinkLoggerContractPromise.create(this.api, this, this.#systemContract);
      } else {
        throw new Error(`System contract not found: ${systemContractId}`);
      }
    }
  }
  get systemContract() {
    if (this.#systemContract) {
      return this.#systemContract;
    }
    console.warn("System contract not found, you might not connect to a health cluster.");
  }
  get alice() {
    if (!this.#alice) {
      const keyring = new Keyring2({ type: "sr25519" });
      this.#alice = keyring.addFromUri("//Alice");
    }
    return this.#alice;
  }
  async getAnonymousCert() {
    if (!this.#cert) {
      this.#cert = await signCertificate({ pair: this.alice });
    }
    return this.#cert;
  }
  resetAnonymousCert() {
    this.#cert = void 0;
  }
  async getClusterBalance(address, cert) {
    const system = this.#systemContract;
    if (!system) {
      throw new Error("System contract not found, you might not connect to a health cluster.");
    }
    if (!cert) {
      cert = await this.getAnonymousCert();
    }
    const [{ output: totalBalanceOf }, { output: freeBalanceOf }] = await Promise.all([
      system.query["system::totalBalanceOf"](cert.address, { cert }, address),
      system.query["system::freeBalanceOf"](cert.address, { cert }, address)
    ]);
    return {
      total: totalBalanceOf.asOk.toBn(),
      free: freeBalanceOf.asOk.toBn()
    };
  }
  transferToCluster(address, amount) {
    return this.api.tx.phalaPhatContracts.transferToCluster(amount, this.clusterId, address);
  }
  get loggerContract() {
    if (this.#loggerContract) {
      return this.#loggerContract;
    }
    console.warn("Logger contract not found, you might not connect to a health cluster.");
  }
  get remotePubkey() {
    var _a;
    return (_a = this.workerInfo) == null ? void 0 : _a.pubkey;
  }
  get pruntimeURL() {
    var _a;
    return (_a = this.workerInfo) == null ? void 0 : _a.endpoints.default;
  }
};

// src/abis/fetchers.ts
import fetch2 from "cross-fetch";
var OFFICIAL_ARTIFACTS_URL = "https://phala-network.github.io/phat-contract-artifacts";
function unsafeCheckCodeHashExists(env) {
  const { systemContract, cert } = env;
  return async function _unsafeCheckCodeHashExists(codeHash) {
    const { output } = await systemContract.query["system::codeExists"](
      cert.address,
      { cert },
      `0x${codeHash}`,
      "Ink"
    );
    return output && output.isOk && output.asOk.isTrue;
  };
}
async function unsafeGetContractCodeHash(phatRegistry, contractId) {
  var _a;
  const payload = await phatRegistry.phactory.getContractInfo({ contracts: [contractId] });
  return ((_a = payload == null ? void 0 : payload.contracts[0]) == null ? void 0 : _a.codeHash) || null;
}
async function unsafeGetAbiFromPatronByCodeHash(codeHash) {
  const codeHashWithoutPrefix = codeHash.indexOf("0x") === 0 ? codeHash.replace("0x", "") : codeHash;
  const resp = await fetch2(`https://api.patron.works/buildSessions/metadata/${codeHashWithoutPrefix}`);
  if (resp.status !== 200) {
    let payload;
    try {
      payload = await resp.json();
    } catch (_err1) {
      try {
        const text = await resp.text();
        throw new Error(`Failed to get abi from Patron: ${resp.status}: ${text}`);
      } catch (_err2) {
        throw new Error(`Unknown Error: ${resp.status}: ${_err2}`);
      }
    }
    throw new Error(`Failed to get abi from Patron: ${resp.status}: ${(payload == null ? void 0 : payload.error) || "Unknown Error"}`);
  }
  return await resp.json();
}
async function unsafeGetAbiFromGitHubRepoByCodeHash(codeHash) {
  const codeHashWithPrefix = codeHash.indexOf("0x") !== 0 ? `0x${codeHash}` : codeHash;
  const resp = await fetch2(`${OFFICIAL_ARTIFACTS_URL}/artifacts/${codeHashWithPrefix}/metadata.json`);
  if (resp.status !== 200) {
    throw new Error(`Failed to get abi from GitHub: ${resp.status}`);
  }
  return await resp.json();
}
async function unsafeGetWasmFromPatronByCodeHash(codeHash) {
  const codeHashWithoutPrefix = codeHash.indexOf("0x") === 0 ? codeHash.replace("0x", "") : codeHash;
  const resp = await fetch2(`https://api.patron.works/buildSessions/wasm/${codeHashWithoutPrefix}`);
  if (resp.status !== 200) {
    throw new Error(`Failed to get wasm from Patron: ${resp.status}`);
  }
  const buffer = await resp.arrayBuffer();
  return new Uint8Array(buffer);
}
async function unsafeGetWasmFromGithubRepoByCodeHash(codeHash) {
  const codeHashWithPrefix = codeHash.indexOf("0x") !== 0 ? `0x${codeHash}` : codeHash;
  const resp = await fetch2(`${OFFICIAL_ARTIFACTS_URL}/artifacts/${codeHashWithPrefix}/out.wasm`);
  if (resp.status !== 200) {
    throw new Error(`Failed to get wasm from GitHub: ${resp.status}`);
  }
  const buffer = await resp.arrayBuffer();
  return new Uint8Array(buffer);
}

// src/ha/periodicity-checker.ts
import fetch3 from "cross-fetch";
var PRUNTIME_NODE_LIST = "https://phala-network.github.io/pruntime-node-list/nodes.json";
function periodicityChecker(url) {
  return async function(_apiPromise, clusterId) {
    const resp = await fetch3(url || PRUNTIME_NODE_LIST);
    const data = await resp.json();
    const endpoints = (data == null ? void 0 : data[clusterId]) || [];
    if (endpoints.length === 0) {
      throw new Error("No worker available.");
    }
    const picked = endpoints[Math.floor(Math.random() * endpoints.length)];
    const client = createPruntimeClient(picked);
    const info = await client.getInfo({});
    return [`0x${info.ecdhPublicKey || ""}`, picked, client];
  };
}

// src/ha/fixture.ts
function fixture(endpoints) {
  return async function(_apiPromise, _clusterId) {
    if (endpoints.length === 0) {
      throw new Error("No worker available.");
    }
    const picked = endpoints[Math.floor(Math.random() * endpoints.length)];
    const client = createPruntimeClient(picked);
    const info = await client.getInfo({});
    return [`0x${info.ecdhPublicKey || ""}`, picked, client];
  };
}

// src/factory_functions.ts
import { ApiPromise, Keyring as Keyring3, WsProvider } from "@polkadot/api";
import { cryptoWaitReady as cryptoWaitReady3 } from "@polkadot/util-crypto";
async function getClient(opts) {
  const { transport, ...rest } = opts;
  const provider = typeof transport === "string" ? new WsProvider(transport) : transport;
  const api = await ApiPromise.create(options({ provider, noInitWarn: true }));
  return await OnChainRegistry.create(api, rest);
}
async function getContract(options2) {
  const { client, contractId, abi } = options2;
  const contractKey = await client.getContractKeyOrFail(contractId);
  return new PinkContractPromise(client.api, client, abi, contractId, contractKey);
}
async function getLogger(options2) {
  if ("transport" in options2) {
    const client = await getClient(options2);
    if (!client.loggerContract) {
      throw new Error("Logger contract not found in the cluster.");
    }
    return client.loggerContract;
  } else if ("contractId" in options2 && "pruntimeURL" in options2) {
    await cryptoWaitReady3();
    const keyring = new Keyring3({ type: "sr25519" });
    const alice = keyring.addFromUri("//Alice");
    const { contractId, pruntimeURL } = options2;
    const phactory = createPruntimeClient(pruntimeURL);
    const info = await phactory.getInfo({});
    return new PinkLoggerContractPromise(phactory, info.publicKey, alice, contractId, options2.systemContract);
  } else {
    throw new Error("Invalid options.");
  }
}

// src/index.ts
var pruntimeRpc4 = import_proto4.pruntime_rpc;
var PhactoryAPI = import_proto4.pruntime_rpc.PhactoryAPI;
var abis = { system: system_default };
export {
  InkCodeSubmittableResult,
  OnChainRegistry,
  PhactoryAPI,
  PinkBlueprintPromise,
  PinkBlueprintSubmittableResult,
  PinkCodePromise,
  PinkContractPromise,
  PinkLoggerContractPromise,
  SignAndSendError,
  UnexpectedEndpointError,
  abis,
  ackFirst,
  buildGetLogRequest,
  createEip712StructedDataSignCertificate,
  createEip712StructedDataSignQuery,
  createPruntimeClient,
  etherAddressToCompactPubkey,
  etherAddressToSubstrateAddress,
  fixture,
  generatePair,
  getClient,
  getContract,
  getLogger,
  getTopicHash,
  options,
  periodicityChecker,
  phalaRegistryTypes,
  phalaTypes,
  pruntimeRpc4 as pruntimeRpc,
  randomHex,
  signAndSend_default as signAndSend,
  signCertificate,
  types,
  unsafeCheckCodeHashExists,
  unsafeGetAbiFromGitHubRepoByCodeHash,
  unsafeGetAbiFromPatronByCodeHash,
  unsafeGetContractCodeHash,
  unsafeGetWasmFromGithubRepoByCodeHash,
  unsafeGetWasmFromPatronByCodeHash,
  unstable_signEip712Certificate
};
