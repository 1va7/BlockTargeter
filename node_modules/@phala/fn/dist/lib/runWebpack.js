"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printFileSizesAfterBuild = exports.runWebpack = exports.MAX_BUILD_SIZE = void 0;
const tslib_1 = require("tslib");
const node_fs_1 = require("node:fs");
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const upath_1 = tslib_1.__importDefault(require("upath"));
const webpack_1 = tslib_1.__importDefault(require("webpack"));
const terser_webpack_plugin_1 = tslib_1.__importDefault(require("terser-webpack-plugin"));
const webpack_virtual_modules_1 = tslib_1.__importDefault(require("webpack-virtual-modules"));
const webpack_merge_1 = require("webpack-merge");
const filesize_1 = require("filesize");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const utils_1 = require("../lib/utils");
const formatWebpackMessages_1 = require("../lib/formatWebpackMessages");
exports.MAX_BUILD_SIZE = 1024 * 400;
const BUILD_CODE_TEMPLATE = `
  // @ts-ignore
  import entry from '{filePath}';
  (globalThis as any).scriptOutput = entry.apply(null, (globalThis as any).scriptArgs);
`;
const getBaseConfig = (buildEntries, projectDir, outputDir, development) => ({
    mode: development ? 'development' : 'production',
    context: projectDir,
    entry: buildEntries,
    optimization: development ? {} : {
        usedExports: true,
        minimize: true,
        minimizer: [new terser_webpack_plugin_1.default({
                extractComments: false,
                terserOptions: {
                    output: {
                        comments: false,
                    },
                },
            })],
    },
    module: {
        rules: [
            {
                test: /\.ts$/,
                exclude: /node_modules/,
                loader: require.resolve('ts-loader'),
                options: {
                    context: projectDir,
                    configFile: require.resolve('../../tsconfig.build.json'),
                    onlyCompileBundledFiles: true,
                }
            },
        ],
    },
    resolve: {
        extensions: ['.ts', '.js'],
    },
    output: {
        path: outputDir,
        filename: '[name].js',
    },
});
function modifyFilePath(filePath) {
    let newFilePath = filePath.replace(/([^/]+)$/, '_$1');
    if (!newFilePath.endsWith('.ts')) {
        newFilePath += '.ts';
    }
    return newFilePath;
}
async function runWebpack({ buildEntries, projectDir, outputDir, outputFileName, customWebpack, isDev = false, clean = false, }) {
    const virtualModules = new webpack_virtual_modules_1.default(Object.entries(buildEntries || {}).reduce((acc, [, value]) => {
        acc[node_path_1.default.join(projectDir, modifyFilePath(value))] = BUILD_CODE_TEMPLATE.replace(/{filePath}/g, upath_1.default.join(projectDir, value));
        return acc;
    }, {}));
    const newBuildEntries = Object.entries(buildEntries || {}).reduce((acc, [key, value]) => {
        acc[key] = upath_1.default.join(projectDir, modifyFilePath(value));
        return acc;
    }, {});
    let config = (0, webpack_merge_1.merge)(getBaseConfig(newBuildEntries, projectDir, outputDir, isDev), {
        output: {
            clean,
            filename: outputFileName,
        },
        plugins: [
            virtualModules,
        ]
    });
    if (customWebpack) {
        config = (0, webpack_merge_1.mergeWithCustomize)({
            customizeArray: (0, webpack_merge_1.customizeArray)({
                'module.rules': 'replace',
            }),
        })(config, require((0, utils_1.resolveToAbsolutePath)(customWebpack)));
    }
    return new Promise((resolve, reject) => {
        (0, webpack_1.default)(config).run((error, stats) => {
            var _a;
            if (error || !stats) {
                return reject(error || new Error('Failed to compile.'));
            }
            if (stats.hasErrors()) {
                const json = stats.toJson({ all: false, errors: true });
                const messages = (0, formatWebpackMessages_1.formatWebpackMessages)(json);
                return reject(new Error((_a = messages.errors) === null || _a === void 0 ? void 0 : _a.join('\n\n')));
            }
            return resolve(stats);
        });
    });
}
exports.runWebpack = runWebpack;
function printFileSizesAfterBuild(json, maxSize = exports.MAX_BUILD_SIZE) {
    var _a;
    const assets = ((_a = json.assets) !== null && _a !== void 0 ? _a : []).map(asset => {
        var _a, _b, _c;
        const { size } = (0, node_fs_1.statSync)(upath_1.default.join((_a = json.outputPath) !== null && _a !== void 0 ? _a : '', asset.name));
        return {
            folder: upath_1.default.join(upath_1.default.basename((_b = json.outputPath) !== null && _b !== void 0 ? _b : ''), upath_1.default.dirname(asset.name)),
            name: upath_1.default.basename(asset.name),
            size: size,
            sizeLabel: (0, filesize_1.filesize)(size, { base: 2, standard: 'jedec' }),
            outputPath: (_c = json.outputPath) !== null && _c !== void 0 ? _c : '',
        };
    });
    assets.sort((a, b) => b.size - a.size);
    assets.forEach(asset => {
        const sizeLabel = asset.sizeLabel;
        const exceeded = maxSize && asset.size > maxSize;
        if (exceeded) {
            console.log([
                '  ',
                chalk_1.default.yellow(`${sizeLabel}`),
                '  ',
                chalk_1.default.dim(asset.folder + node_path_1.default.sep),
                chalk_1.default.cyan(asset.name),
                '  ',
                chalk_1.default.yellow(`(Exceeded the limit size of ${(0, filesize_1.filesize)(maxSize, { base: 2, standard: 'jedec' })})`),
            ].join(''));
        }
        else {
            console.log([
                '  ',
                sizeLabel,
                '  ',
                chalk_1.default.dim(asset.folder + node_path_1.default.sep) + chalk_1.default.cyan(asset.name),
            ].join(''));
        }
    });
    return assets;
}
exports.printFileSizesAfterBuild = printFileSizesAfterBuild;
