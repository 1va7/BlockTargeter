"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const node_fs_1 = tslib_1.__importDefault(require("node:fs"));
const upath_1 = tslib_1.__importDefault(require("upath"));
const inquirer_1 = tslib_1.__importDefault(require("inquirer"));
const dotenv = tslib_1.__importStar(require("dotenv"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const filesize_1 = require("filesize");
const core_1 = require("@oclif/core");
const sdk_1 = require("@phala/sdk");
const api_contract_1 = require("@polkadot/api-contract");
const wasm_crypto_1 = require("@polkadot/wasm-crypto");
const keyring_1 = require("@polkadot/keyring");
const runWebpack_1 = require("../lib/runWebpack");
const formatWebpackMessages_1 = require("../lib/formatWebpackMessages");
const BaseCommand_1 = tslib_1.__importDefault(require("../lib/BaseCommand"));
class PhatBaseCommand extends BaseCommand_1.default {
    async init() {
        const { flags, args, } = await this.parse(this.constructor);
        if (flags.envFilePath) {
            if (!node_fs_1.default.existsSync(flags.envFilePath)) {
                this.error(`Env file does not exist: ${flags.envFilePath}`);
            }
            dotenv.config({ path: upath_1.default.resolve(flags.envFilePath) });
        }
        else {
            dotenv.config();
        }
        this.parsedFlags = flags;
        this.parsedArgs = args;
        // temporary hijacking console.warn to ignore wrong printing
        // see: https://github.com/polkadot-js/api/issues/5760
        console.warn = function (...args) {
            if (args.length && args[0] === 'Unable to map [u8; 32] to a lookup index') {
                return;
            }
            console.log(...args);
        };
    }
    getEndpoint() {
        const isDev = this.parsedFlags.mode === 'development' || this.parsedFlags.mode === 'dev';
        let endpoint;
        if (this.parsedFlags.endpoint) {
            endpoint = this.parsedFlags.endpoint;
        }
        else {
            endpoint = isDev
                ? 'wss://poc6.phala.network/ws'
                : 'wss://api.phala.network/ws';
        }
        return endpoint;
    }
    async getBrickProfileFactoryContractId(endpoint) {
        let brickProfileFactoryContractId = this.parsedFlags.brickProfileFactory;
        if (!brickProfileFactoryContractId) {
            if (endpoint === 'wss://poc6.phala.network/ws') {
                brickProfileFactoryContractId = '0x4a7861f257568a989a9c24db60981efb745d134a138203a219da051337428b49';
            }
            else if (endpoint === 'wss://api.phala.network/ws') {
                brickProfileFactoryContractId = '0xb59bcc4ea352f3d878874d8f496fb093bdf362fa59d6e577c075f41cd7c84924';
            }
            else {
                brickProfileFactoryContractId = await this.promptBrickProfileFactory();
            }
        }
        return brickProfileFactoryContractId;
    }
    async getBrickProfileContractId({ endpoint, registry, apiPromise, pair, cert, }) {
        const brickProfileFactoryContractId = await this.getBrickProfileFactoryContractId(endpoint);
        const brickProfileFactoryAbi = await this.loadAbiByContractId(registry, brickProfileFactoryContractId);
        const brickProfileFactoryContractKey = await registry.getContractKeyOrFail(brickProfileFactoryContractId);
        const brickProfileFactory = new sdk_1.PinkContractPromise(apiPromise, registry, brickProfileFactoryAbi, brickProfileFactoryContractId, brickProfileFactoryContractKey);
        const { output: brickProfileAddressQuery } = await brickProfileFactory.query.getUserProfileAddress(pair.address, { cert });
        if (!brickProfileAddressQuery.isOk || !brickProfileAddressQuery.asOk.isOk) {
            this.action.fail('You need to create the Brick Profile before continuing.\nPlease go to: https://bricks.phala.network/');
            this.exit(1);
        }
        const brickProfileContractId = brickProfileAddressQuery.asOk.asOk.toHex();
        return brickProfileContractId;
    }
    async connect({ endpoint, pair, }) {
        this.action.start(`Connecting to the endpoint: ${endpoint}`);
        const registry = await (0, sdk_1.getClient)({
            transport: endpoint,
            pruntimeURL: this.parsedFlags.pruntimeUrl,
        });
        const cert = await (0, sdk_1.signCertificate)({ pair });
        this.action.succeed(`Connected to the endpoint: ${endpoint}`);
        const type = await registry.api.rpc.system.chainType();
        if (type.isDevelopment || type.isLocal) {
            this.log(chalk_1.default.yellow(`\nYou are connecting to a testnet.\n`));
        }
        return [registry.api, registry, cert];
    }
    async getRollupAbi() {
        const rollupAbi = new api_contract_1.Abi(await this.loadAbiByCodeHash('0x96ca5480eb52b8087b1e64cae52c75e6db037e1920320653584ef920db5d29d5'));
        return rollupAbi;
    }
    async buildOrGetScriptPath() {
        var _a;
        if (!this.parsedFlags.build) {
            return upath_1.default.join(process.cwd(), 'dist', 'index.js');
        }
        const directory = process.cwd();
        try {
            this.action.start('Creating an optimized build');
            const stats = await (0, runWebpack_1.runWebpack)({
                clean: false,
                projectDir: directory,
                customWebpack: this.parsedFlags.webpack,
                buildEntries: {
                    [upath_1.default.parse(this.parsedArgs.script).name]: this.parsedArgs.script,
                },
                outputDir: upath_1.default.resolve(directory, 'dist'),
                isDev: false,
            });
            const json = stats.toJson({
                all: false,
                warnings: true,
                assets: true,
                outputPath: true
            });
            const messages = (0, formatWebpackMessages_1.formatWebpackMessages)(json);
            if (messages.warnings && messages.warnings.length) {
                this.action.warn('Compiled with warnings.');
                this.log(messages.warnings.join('\n\n'));
            }
            else {
                this.action.succeed('Compiled successfully.');
            }
            if (!json.assets || !json.assets.length) {
                throw new Error('Build assets not found.');
            }
            const assetPath = upath_1.default.join((_a = json.outputPath) !== null && _a !== void 0 ? _a : '', json.assets[0].name);
            const { size } = node_fs_1.default.statSync(assetPath);
            if (size > runWebpack_1.MAX_BUILD_SIZE) {
                throw new Error(`The file size exceeds the limit of ${(0, filesize_1.filesize)(runWebpack_1.MAX_BUILD_SIZE, {
                    base: 2,
                    standard: 'jedec',
                })}.`);
            }
            return assetPath;
        }
        catch (error) {
            this.action.fail('Failed to compile.');
            return this.error(error);
        }
        finally {
            this.action.stop();
        }
    }
    async promptEvmAccountId({ contract, cert, }) {
        if (this.parsedFlags.externalAccountId) {
            return this.parsedFlags.externalAccountId;
        }
        try {
            this.action.start('Querying your external accounts');
            const { output } = await contract.query.getAllEvmAccounts(cert.address, {
                cert,
            });
            if (output.isErr) {
                throw new Error(output.asErr.toString());
            }
            if (output.asOk.isErr) {
                throw new Error(output.asOk.asErr.toString());
            }
            const accounts = output.asOk.asOk.map((i) => {
                const obj = i.toJSON();
                return {
                    id: obj.id,
                    address: obj.address,
                    rpcEndpoint: obj.rpc,
                };
            });
            this.action.stop();
            const { account } = await inquirer_1.default.prompt({
                name: 'account',
                message: 'Please select an external account:',
                type: 'list',
                choices: accounts.map(account => ({
                    name: `[${account.id}] ${account.address}. ${chalk_1.default.dim(account.rpcEndpoint)}`,
                    value: account.id,
                })),
            });
            return account;
        }
        catch (error) {
            this.action.fail('Failed to query your external accounts.');
            return this.error(error);
        }
    }
    async promptProjectName(defaultName) {
        const { name } = await inquirer_1.default.prompt([
            {
                name: 'name',
                type: 'input',
                message: 'Please enter your project name',
                default: defaultName,
            },
        ]);
        return name;
    }
    async promptRpc(message = 'Please enter your client RPC URL') {
        const { rpc } = await inquirer_1.default.prompt([
            {
                name: 'rpc',
                type: 'input',
                message,
            },
        ]);
        return rpc;
    }
    async promptConsumerAddress(message = 'Please enter your consumer address') {
        const { consumerAddress } = await inquirer_1.default.prompt([
            {
                name: 'consumerAddress',
                type: 'input',
                message,
            },
        ]);
        return consumerAddress;
    }
    async promptBrickProfileFactory(message = 'Please enter the brick profile factory contract ID') {
        const { brickProfileFactory } = await inquirer_1.default.prompt([
            {
                name: 'brickProfileFactory',
                type: 'input',
                message,
            },
        ]);
        return brickProfileFactory;
    }
    async getDecodedPair({ suri, accountFilePath, accountPassword }) {
        await (0, wasm_crypto_1.waitReady)();
        const keyring = new keyring_1.Keyring({ type: 'sr25519' });
        let pair;
        if (accountFilePath) {
            if (!node_fs_1.default.existsSync(accountFilePath)) {
                this.error(`Keypair account json file does not exist: ${accountFilePath}`);
            }
            if (upath_1.default.extname(accountFilePath) !== '.json') {
                this.error(`Keypair account json file is invalid: File extension should be .json: ${accountFilePath}`);
            }
            const exported = node_fs_1.default.readFileSync(upath_1.default.resolve(accountFilePath), 'utf8');
            pair = keyring.createFromJson(JSON.parse(exported));
        }
        else if (suri) {
            pair = keyring.addFromUri(suri);
        }
        else {
            pair = keyring.addFromUri((await this.promptForSuri()));
        }
        if (pair.isLocked) {
            pair = await this.requestPairDecoding(pair, {
                password: accountPassword,
            });
        }
        return pair;
    }
    async requestPairDecoding(pair, options) {
        if (!pair.isLocked) {
            return pair;
        }
        // Try decoding using empty string
        try {
            pair.decodePkcs8(options.password || '');
            return pair;
        }
        catch (e) {
            // Continue
        }
        let isPassValid = false;
        while (!isPassValid) {
            try {
                const password = await this.promptForPassword(options.message ||
                    `Please Enter ${pair.meta.name ? pair.meta.name : pair.address} account password`);
                pair.decodePkcs8(password);
                isPassValid = true;
            }
            catch (e) {
                this.warn('Invalid password, try again.');
            }
        }
        return pair;
    }
    async promptForPassword(message = `Please enter your account password`) {
        const { password } = await inquirer_1.default.prompt([
            {
                name: 'password',
                type: 'password',
                message,
            },
        ]);
        return password;
    }
    async promptForSuri(message = `Please enter your substrate uri`) {
        const { suri } = await inquirer_1.default.prompt([
            {
                name: 'suri',
                type: 'input',
                message,
            },
        ]);
        return suri;
    }
    async loadAbiByCodeHash(codeHash) {
        const dirPath = upath_1.default.join(process.cwd(), '.phat', 'abis');
        const abiPath = upath_1.default.join(dirPath, `${codeHash}.json`);
        if (node_fs_1.default.existsSync(abiPath)) {
            return node_fs_1.default.readFileSync(abiPath, 'utf8');
        }
        const codeHashWithPrefix = codeHash && codeHash.indexOf('0x') !== 0 ? `0x${codeHash}` : codeHash;
        const abi = await (0, sdk_1.unsafeGetAbiFromGitHubRepoByCodeHash)(codeHashWithPrefix);
        if (!node_fs_1.default.existsSync(dirPath)) {
            node_fs_1.default.mkdirSync(dirPath, { recursive: true });
        }
        node_fs_1.default.writeFileSync(abiPath, JSON.stringify(abi));
        return abi;
    }
    async loadAbiByContractId(registry, contractId) {
        const contractInfo = await registry.phactory.getContractInfo({
            contracts: [contractId],
        });
        if (!contractInfo.contracts.length || !contractInfo.contracts[0].codeHash) {
            this.error(`Contract code hash not found: Contract ID: ${contractId}`);
        }
        const codeHash = contractInfo.contracts[0].codeHash;
        const codeHashWithPrefix = codeHash && codeHash.indexOf('0x') !== 0 ? `0x${codeHash}` : codeHash;
        const abi = await this.loadAbiByCodeHash(codeHashWithPrefix);
        return abi;
    }
}
PhatBaseCommand.args = {
    script: core_1.Args.string({
        description: 'The function script file',
        require: true,
        default: 'src/index',
    }),
};
PhatBaseCommand.flags = {
    envFilePath: core_1.Flags.string({
        char: 'e',
        description: 'Path to env file',
        required: false,
    }),
    accountFilePath: core_1.Flags.string({
        char: 'a',
        required: false,
        description: 'Path to polkadot account JSON file',
        exclusive: ['suri'],
    }),
    accountPassword: core_1.Flags.string({
        char: 'p',
        required: false,
        description: 'Polkadot account password',
        exclusive: ['suri'],
    }),
    suri: core_1.Flags.string({
        required: false,
        description: 'Substrate uri',
        exclusive: ['accountFilePath'],
    }),
    endpoint: core_1.Flags.string({
        description: 'Phala Blockchain RPC endpoint',
        required: false,
    }),
    rpc: core_1.Flags.string({
        description: 'EVM RPC URL',
        required: false,
    }),
    brickProfileFactory: core_1.Flags.string({
        description: 'Brick profile factory contract address',
        required: false,
        default: '',
    }),
    consumerAddress: core_1.Flags.string({
        description: 'Consumer contract address',
        required: false,
    }),
    coreSettings: core_1.Flags.string({
        description: 'Core settings',
        required: false,
    }),
    pruntimeUrl: core_1.Flags.string({
        description: 'Pruntime URL',
        required: false,
    }),
    externalAccountId: core_1.Flags.string({
        description: 'External Account ID',
        required: false,
    }),
    mode: core_1.Flags.custom({
        options: ['production', 'prod', 'development', 'dev'],
        default: 'development',
    })(),
    build: core_1.Flags.boolean({
        char: 'b',
        default: true,
    }),
};
exports.default = PhatBaseCommand;
