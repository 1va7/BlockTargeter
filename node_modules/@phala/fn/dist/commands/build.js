"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const node_fs_1 = require("node:fs");
const upath_1 = tslib_1.__importDefault(require("upath"));
const core_1 = require("@oclif/core");
const utils_1 = require("../lib/utils");
const runWebpack_1 = require("../lib/runWebpack");
const formatWebpackMessages_1 = require("../lib/formatWebpackMessages");
const BaseCommand_1 = tslib_1.__importDefault(require("../lib/BaseCommand"));
class Build extends BaseCommand_1.default {
    async run() {
        var _a;
        const { flags, args: { script } } = await this.parse(Build);
        const directory = flags.directory ? (0, utils_1.resolveToAbsolutePath)(flags.directory) : process.cwd();
        const isDev = flags.mode === 'development' || flags.mode === 'dev';
        if (!(0, node_fs_1.lstatSync)(directory).isDirectory()) {
            this.error('Location directory is not a valid directory');
        }
        const outputDir = upath_1.default.resolve(directory, (_a = flags.outputDir) !== null && _a !== void 0 ? _a : 'dist');
        let buildEntries = {
            [upath_1.default.parse(script).name]: script,
        };
        const pjson_file_path = upath_1.default.join(directory, 'package.json');
        if ((0, node_fs_1.existsSync)(pjson_file_path)) {
            try {
                const pjson = JSON.parse((0, node_fs_1.readFileSync)(pjson_file_path).toString());
                if (pjson.exports && typeof pjson.exports !== 'string') {
                    buildEntries = Object.entries(pjson.exports).reduce((acc, [key, value]) => {
                        acc[key] = value;
                        return acc;
                    }, { ...buildEntries });
                }
            }
            catch (error) {
                this.error(`Error parsing package.json: ${error}`);
            }
        }
        for (const i in buildEntries) {
            if (typeof buildEntries[i] !== 'string') {
                this.warn(`Ignoring entry ${i} from build.`);
                delete buildEntries[i];
            }
        }
        if (!flags.silent) {
            this.action.start('Creating an optimized build');
        }
        try {
            const stats = await (0, runWebpack_1.runWebpack)({
                clean: flags.output ? false : flags.clean,
                projectDir: directory,
                outputDir: flags.output ? upath_1.default.resolve(upath_1.default.dirname(flags.output)) : outputDir,
                outputFileName: flags.output ? upath_1.default.basename(flags.output) : undefined,
                customWebpack: flags.webpack,
                buildEntries,
                isDev,
            });
            if (!flags.silent) {
                this.action.stop();
                const json = stats.toJson({
                    all: false,
                    warnings: true,
                    assets: true,
                    outputPath: true
                });
                const messages = (0, formatWebpackMessages_1.formatWebpackMessages)(json);
                if (messages.warnings && messages.warnings.length) {
                    this.action.warn('Compiled with warnings.');
                    this.log(messages.warnings.join('\n\n'));
                }
                else {
                    this.action.succeed('Compiled successfully.');
                }
                (0, runWebpack_1.printFileSizesAfterBuild)(json);
            }
        }
        catch (error) {
            if (!flags.silent) {
                this.action.fail('Failed to compile.');
            }
            return this.error(error);
        }
    }
}
Build.description = 'Build a production bundle of the function script';
Build.args = {
    script: core_1.Args.string({
        description: 'The function script file',
        require: true,
        default: 'src/index',
    }),
};
Build.flags = {
    directory: core_1.Flags.string({
        char: 'd',
        description: 'Specify the script directory',
    }),
    output: core_1.Flags.string({
        char: 'o',
        description: 'Output file',
    }),
    outputDir: core_1.Flags.string({
        description: 'Output directory',
    }),
    webpack: core_1.Flags.string({
        char: 'w',
        description: 'Custom webpack config',
    }),
    silent: core_1.Flags.boolean({
        char: 's',
        description: 'Silent mode'
    }),
    clean: core_1.Flags.boolean({
        char: 'c',
        description: 'Clean the output directory',
        default: false,
    }),
    mode: core_1.Flags.custom({
        options: ['production', 'prod', 'development', 'dev'],
        default: 'production',
    })(),
};
exports.default = Build;
