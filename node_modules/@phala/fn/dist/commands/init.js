"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const node_fs_1 = require("node:fs");
const upath_1 = tslib_1.__importDefault(require("upath"));
const core_1 = require("@oclif/core");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const inquirer_1 = tslib_1.__importDefault(require("inquirer"));
const simple_git_1 = tslib_1.__importDefault(require("simple-git"));
const TEMPLATE_ALIASES = {
    'phat-contract-starter-kit': {
        url: 'https://github.com/Phala-Network/phat-contract-starter-kit',
        description: 'The Phat Contract Starter Kit',
    },
    'lensapi-oracle-consumer-contract': {
        url: 'https://github.com/Phala-Network/lensapi-oracle-consumer-contract',
        description: 'Polygon Consumer Contract for LensAPI Oracle',
    },
};
const TEMPLATE_DESC = [
    'Choose one of the templates:',
    ...Object.entries(TEMPLATE_ALIASES).map(([alias, { description }]) => `- ${chalk_1.default.bold(alias)} ${description}`),
];
const git = (0, simple_git_1.default)({
    baseDir: process.cwd(),
    binary: 'git',
});
async function directoryIsEmpty(directoryPath) {
    try {
        const directory = await node_fs_1.promises.opendir(directoryPath);
        const entry = await directory.read();
        await directory.close();
        return entry === null;
    }
    catch (error) {
        if (error.code === 'ENOENT')
            return true;
        return false;
    }
}
class Init extends core_1.Command {
    async run() {
        const { args: { name }, flags: { template, dir, remove }, } = await this.parse(Init);
        const localDir = upath_1.default.resolve(dir || name);
        const isEmptyDir = await directoryIsEmpty(localDir);
        if (!isEmptyDir) {
            if (!remove) {
                return this.error(`The folder "${localDir}" already exists. Use the "-r" flag to init the project at the existing path (will clean the folder first).`);
            }
            await node_fs_1.promises.rm(localDir, { recursive: true });
        }
        let resolvedTemplate = template || '';
        if (!template) {
            const { alias } = await inquirer_1.default.prompt({
                name: 'alias',
                message: `Please select one of the templates for your "${name}" project:`,
                type: 'list',
                choices: Object.entries(TEMPLATE_ALIASES).map(([name, { description }]) => {
                    return {
                        name: `${name}. ${chalk_1.default.dim(description)}`,
                        value: name,
                    };
                }),
            });
            resolvedTemplate = alias;
        }
        const githubRepository = TEMPLATE_ALIASES[resolvedTemplate] ? TEMPLATE_ALIASES[resolvedTemplate].url : resolvedTemplate;
        core_1.ux.action.start(`Downloading the template: ${githubRepository}`);
        try {
            await git.clone(githubRepository, localDir, { '--depth': 1 });
        }
        catch (error) {
            return this.error(error);
        }
        core_1.ux.action.stop('âœ”');
        await node_fs_1.promises.rm(upath_1.default.resolve(localDir, '.git'), { recursive: true });
        this.log(`The project is created in ${localDir} ðŸŽ‰`);
        this.log('Now run:\n');
        this.log(`  cd ${name}`);
        this.log('  yarn install');
    }
}
Init.description = 'Create a new project from template';
Init.args = {
    name: core_1.Args.string({
        name: 'name',
        required: true,
    }),
};
Init.flags = {
    template: core_1.Flags.string({
        char: 't',
        description: TEMPLATE_DESC.join('\n'),
        required: false,
    }),
    dir: core_1.Flags.string({
        char: 'd',
        description: 'The target location for the project. If omitted, a new folder NAME is created.',
        required: false,
    }),
    remove: core_1.Flags.boolean({
        char: 'r',
        description: 'Clean up the target directory if it exists',
        required: false,
    }),
};
exports.default = Init;
