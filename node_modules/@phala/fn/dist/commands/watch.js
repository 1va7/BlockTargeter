"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const node_fs_1 = require("node:fs");
const core_1 = require("@oclif/core");
const ethers_1 = require("ethers");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const utils_1 = require("../lib/utils");
const runQuickJs_1 = require("../lib/runQuickJs");
class Watch extends core_1.Command {
    async run() {
        const { args, flags } = await this.parse(Watch);
        if (!(0, node_fs_1.existsSync)(args.contract)) {
            return this.error(`The Contract file ${args.contract} not found`);
        }
        if (!ethers_1.ethers.isAddress(args.address)) {
            return this.error('Invalid contract address');
        }
        let provider;
        if (flags.rpc) {
            provider = new ethers_1.ethers.JsonRpcProvider(flags.rpc);
        }
        else {
            provider = new ethers_1.ethers.JsonRpcProvider('http://127.0.0.1:8545/');
        }
        const signer = await provider.getSigner();
        let contractJson;
        try {
            contractJson = JSON.parse((0, node_fs_1.readFileSync)(args.contract, 'utf-8'));
        }
        catch (error) {
            return this.error(error);
        }
        const contract = new ethers_1.ethers.Contract(args.address, contractJson.abi, signer);
        console.log(chalk_1.default.green(`Listening for ${contractJson.contractName} MessageQueued events...`));
        contract.on('MessageQueued', async (from, to, event) => {
            const [tail, data] = event.args;
            console.info('Received event [MessageQueued]:', {
                tail,
                data,
            });
            const js = (0, node_fs_1.readFileSync)((0, utils_1.resolveToAbsolutePath)(args.js), 'utf8');
            const output = await (0, runQuickJs_1.runQuickJs)(js, [data, ...flags.scriptArgs]);
            console.info(`JS Execution output: ${output}`);
            const action = ethers_1.ethers.hexlify(ethers_1.ethers.concat([
                new Uint8Array([0]),
                output,
            ]));
            await contract.rollupU256CondEq(
            // cond
            [], [], 
            // updates
            [], [], 
            // actions
            [action]);
            if (flags.once) {
                process.exit();
            }
        });
    }
}
Watch.description = 'Watch contract events and run Phat Function';
Watch.examples = [
    '<%= config.bin %> <%= command.id %>',
];
Watch.flags = {
    rpc: core_1.Flags.string({
        description: 'RPC endpoint',
    }),
    scriptArgs: core_1.Flags.string({
        char: 'a',
        description: 'Script arguments',
        multiple: true,
        default: [],
    }),
    once: core_1.Flags.boolean({
        description: 'Process events once only',
        default: false,
    }),
};
Watch.args = {
    address: core_1.Args.string({
        description: 'The contract address',
        required: true
    }),
    contract: core_1.Args.string({
        description: 'The location of the contract JSON file',
        required: true,
    }),
    js: core_1.Args.string({
        description: 'The location of the JS file',
        required: true,
    }),
};
exports.default = Watch;
